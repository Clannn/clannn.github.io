review: 006 014 017 019 020

# Vulkan tutorial

## Logical device and queues

### Retrieving queue handles

​	The queues are automatically created along with the logical device, but we don’t have a handle to interface with them yet. So we need to store handles to the queues. Device queues are implicitly cleaned up when the device is destroyed. We can use the `vkGetDeviceQueue` function to retrieve queue handles for each queue family.

## Window surface

​	To establish the connection between Vulkan and the window system to present results to the screen, we need to use the WSI (Window System Integration) extensions. The `VK_KHR_surface` extension exposes a `VkSurfaceKHR` object that represents an abstract type of surface.

​	The `VK_KHR_surface` extension is an instance level extension. The window surface needs to be created right after the instance creation, because it can actually influence the physical device selection.

​	Although the `VkSurfaceKHR` object and its usage is platform agnostic, its creation isn’t because it depends on window system details. Therefore there is a platform-specific addition to the extension, which on Windows is called `VK_KHR_win32_surface`.

​	GLFW actually has `glfwCreateWindowSurface` that handles the platform differences for us.

### Querying for presentation support

​	We need to ensure that a device can present images to the surface we created. Since the presentation is a queue-specific feature, the problem is actually about finding a queue family that supports presenting to the surface. **Supporting drawing commands and presentation do not overlap**. The function to check for that is `vkGetPhysicalDeviceSurfaceSupportKHR`.

​	Note that it’s very likely that these end up being the same queue family.

## Swap chain

​	**The availability of a presentation queue implies that the swap chain extension must be supported.**

​	The swap chain is essentially a queue of images that are waiting to be presented to the screen. the general purpose of the swap chain is to synchronize the presentation of images with the refresh rate of the screen.

​	Since image presentation is heavily tied into the window system and the surfaces associated with windows, it is not actually part of the Vulkan core. You have to enable the `VK_KHR_swapchain` **device extension** after querying for its support.

​	Just checking if a swap chain is available is not sufficient. There are basically three kinds of properties we need to check:

- Basic surface capabilities (min/max number of images in swap chain, min/max width and height of images)
- Surface formats (pixel format, color space)
- Available presentation modes

​	We'll use a struct to pass these details:

```c++
struct SwapChainSupportDetails {
	VkSurfaceCapabilitiesKHR capabilities;
    std::vector<VkSurfaceFormatKHR> formats;
    std::vector<VkPresentModeKHR> presentModes;
};
```

