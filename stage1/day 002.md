# Foundations of Animation

## Interacting Particle System

​	it will be important to maintain a coherent notion and record of the entire system's state, and to **update that state only once per simulation timestep.** We need all of the particles' positions and velocities to remain frozen in time while we compute all of the forces acting on all of the particles.

​	In an interacting system, to compute the forces on each of $N$ particles we must consider all of the $N-1$ other particles. Therefore, **the computational complexity of the interacting particle problem is $O(N^2)$.**

### State Vectors

​	A state vector is a vector whose elements record all information necessary to keep track of the state of a system. For a particle system, this will be the positions and velocities of all of the particles in the system. **On the software side, a state vector is typically maintained as an object containing an array of particle positions and velocities, together with a set of methods.**

#### State Vectors for Single Particle

$$
s_i = \left[\begin{matrix}x_i \\ v_i\end{matrix}\right]
$$

​	At each step of the simulation, we  sum the $m$ individual forces on the particle, to obtain the total force.
$$
f_i = \sum_{j=0}^{m-1}{f_i^j}
$$
​	Dividing by the particle's mass $m_i$ we obtain the particle's acceleration.
$$
a_i=\frac{1}{m_i}f_i
$$
​	The rate of change of the state of the particle is
$$
\dot{s}_i = \left[\begin{matrix}\dot{x}_i \\ \dot{v}_i\end{matrix}\right]=\left[\begin{matrix}v_i \\ a_i\end{matrix}\right]
$$
​	An important point to note about the force calculation is that each of the individual forces $f_i^j$ acting on the particle can be thought of as a function of the state of the particle and time. **each of the force $f_i^j$ can be expressed as a function $f_i^j(s_i, t)$;** therefore, **the acceleration on the particle is also a function of its state and time:**
$$
a_i=a_i(s_i,t)=\frac{1}{m_i}f_i(s_i,t)
$$

#### State Vectors for Interacting Particles

​	It's easy to demonstrated that **the entire rate of change of the particle's state is a function of its current state and time.** We summarize this insight by adopting the notation
$$
\dot{s}_i=F_i(s_i,t)=\left[\begin{matrix}v_i \\ a_i(s_i,t)\end{matrix}\right]
$$
​	We call the function $F_i$ particle i's *particle dynamics function.* Using this function, Explicit Euler integration can be written
$$
s_i^{[n+1]}=s_i^{[n]}+F_i(s_i^{[n]},t)h
$$
​	In an Interacting particle system, the forces on an individual particle need to also include the effects of all the other particles. Thus, the forces on a particle now need to be expressed as functions of the states of the all particles in the system. If there are m forces on the particle not coming from the other particles, and there are $n$ particles, the expression for total force on particle $i$ will be rewritten
$$
f_i(s_0, \cdots, s_{n-1}, t)=\sum_{j=0}^{m-1}f_i^j(s_i,t)+\sum_{k=0}^{n-1}g_i^k(s_i,s_k,t)
$$
​	The terms $g_i^k$ are the new inter-particle forces, giving the force on particle $i$ due to particle $k$. so the acceleration can be written
$$
a_i=\frac{1}{m_i}f_i(s_0, \cdots, s_{n-1}, t)
$$
​	Now, we construct a  system state vector $S$ that holds the state of the entire particle system:
$$
S=\left[\begin{matrix}x_0 \\ x_1 \\ \vdots \\ x_{n-1} \\ v_0 \\ v_1 \\ \vdots \\ v_{n-1} \end{matrix}\right]
$$
Finally:
$$
\dot{S}=F(S,t)=\left[\begin{matrix}v_0 \\ v_1 \\ \vdots \\ v_{n-1} \\ a_0 \\ a_1 \\ \vdots \\ a_{n-1}\end{matrix}\right]
$$

$$
S^{[n+1]}=S^{[n]}+F(S^{[n]},t)h
$$

---

# Game Engine Architecture

## Tools of Trade

### Compilers, Linkers and IDEs

#### Dynamic Link Libraries

​	The executables that use a DLL contain partially linked machine code. Most of the function and data references are fully resolved within the final executable, but any references to external functions or data that exist in a DLL remain unlinked. **When the executable is run, the operating system resolves the addresses of all unlinked functions by locating the appropriate DLLs, loading them into memory if they are not already loaded.**

#### Projects and Solutions

​	In Visual Studio, a project is a collection of source files which, when compiled, produce a library, an executable or a DLL. Projects are stored in project files with a .vcxproj extension. These files are in XML format.

​	Solution files (files with a .sln extension) as a means of containing and managing collections of projects.

#### Build Configurations

​	A build configuration is really just a collection of preprocessor, compiler and linker options associated with a particular project.

- debug build: local and global optimizations are disabled
- non-debug build: local and/or global optimizations are enabled

​	A debug build runs more slowly than a non-debug build.

##### Common Build Options

***Preprocessor Settings***

​		One powerful feature of preprocessors is the ability to define preprocessor macros via command-line options. This feature allows you to communicate various build options to your code.

​	The symbol `_DEBUG` is always defined for a debug build, while in non-debug builds, the symbol `NDEBUG` is defined.

​	Every compiler identifies itself via a "magic" preprocessor macro. `_MSC_VER` is defined under the Microsoft compiler.

​	The target platform on which the code will be run is likewise identified via macros. `_WIN32` is defined when building for a 32-bit Windows machine.

***Compiler Settings***

​	One of the most common compiler options controls whether or not the compiler should include debugging information with the object files it produces. Debugging information makes your executables larger, and it is always stripped from the final shipping version.

​	The aggressiveness with which the compiler attempts to optimize your code, and the kinds of optimizations its uses, can be controlled via compiler options. All optimizations are usually turned off in a debug build.

***Linker Settings***

​	You can control what type of output file to produce—an executable or a DLL. You can also specify which external libraries should be linked into your executable, and which directory paths to search in order to find them.

##### Local and Global Optimizations

​	Local optimizations operate only on small chunks of code known as basic blocks. Including things like:

- algebraic simplification
- operator strength reduction: e.g., converting x / 2 into x >> 1
- code inlining
- constant folding: recognizing expressions that are constant at compile time
- constant propagation: replacing all instances of a variable whose value turns out to be constant
- loop unrolling
- dead code elimination: removal of code that has no effect
- instruction reordering

​	Global optimizations ideally operate across translation unit boundaries, and hence are performed by the linker rather than the compiler.

​	Optimizations performed by the linker are known as link-time optimizations (LTO). Some modern compilers support profile-guided optimizations (PGO). PGO and LTO optimizations can produce an impressive performance boost, but they come with a cost. 

##### Typical Build Configurations

​	Here are a few of the common configurations in game development:

- Debug: A debug build is a very slow version of your program, with all optimizations turned off. This build is used when testing new
  code and also to debug all problems.
- Development: A development build is a faster version, with most or all local optimizations enabled, but with debugging information and assertions still turned on.
- Ship: All debugging information is stripped out of a ship build, most or all assertions are compiled out. optimizations are cranked all the way up, including global optimizations(LTO and PGO).

***Build Configurations and Testability***

​	The more build configurations your project supports, the more difficult testing becomes. Each build configuration must be tested equally thoroughly.