review: 002 003

# Game Engine Architecture

## Tools of Trade

### Build configurations

#### Project Configuration Tutorial

***Configurations Drop-Down Combo Box***

​	All of the properties displayed on these property pages **apply separately** to each build configuration. Try to do most of your build configuration editing with "All configurations" selected.

***General Property Page***

​	On the General property page, the most useful fields are the following:

- *Output directory*: This defines where the final products of the build will go.
- *Intermediate directory*: This defines where intermediate files, primarily object files, are placed during a build. **It's a good idea to place intermediate files in a different directory than the final products.**

​	Some commonly used macros are listed below:

- `$(TargetFileName)`: The name of the final executable, library or DLL file being build by this project.
- `$(TargetPath)`: The full path of the final executable, library or DLL file.
- `$(ConfigurationName)`: The name of the build configuration.
- `$(OutDir)`: The value of the "Output Directory" field.
- `$(IntDir)`: The value of the "Intermediate Directory" field.
- `$(VCInstallDir)`: The directory in which Visual Studio's C++ standard library is currently installed.

​	The benefit of using macros is that a simple change of the global macro's value will automatically affect all configuration settings in which the macro is used.

***Debugging Property page***

​	The "Debugging" property page is **where the name and location of the executable to debug** to specified. On this page, you can also specify the command line arguments that should be passed to the program when it runs.

***C/C++ Property Page***

​	The C/C++ property page controls compile-time language settings. The settings on this page do not affect how your object files are linked into a final executable or DLL. Some of the most commonly used settings include the following:

- *General Property Page/Additional Include Directories*: This field lists the on-disk directories that will be searched when looking for `#include` header files. **It's always best to specify these directories using relative paths and/or with Visual Studio macros.**
- *General Property Page/Debug Information Format*: This field controls whether or not debug information is generated and in what format. Typically both debug and development configurations include debugging information. **The ship build will have all the debug info stripped out to prevent hacking.**
- *Preprocessor Property Page/Preprocessor Definitions*: This field lists any number of C/C++ preprocessor symbols that should be defined in the code when it is compiled.

***Linker Property Page***

​	The "Linker" property page lists properties that affect how your object code files will be linked into an executable or DLL. Some commonly used setting follow:

- *General Property Page/Output File*: This setting lists the name and location of the final product of the build.
- *General Property Page/Additional Library Directories*: This field lists zero or more directories that will be searched when looking for libraries and object files to link.
- *Input Property Page/Additional Dependencies*: This field lists external libraries that you want linked into your executable or DLL.

​	In VS, a special `#pragma` instruction in your source code can be used to instruct the linker to automatically link with a particular library.

### Debugging Your Code

#### The Start-Up Project

​	It's possible to have more than one project that builds an executable in a single solution. Start-up project is the project that is considered "current" for the purpose of the debugger. Hitting `F5` runs whatever command you type into the Command field in the Debugging property page.

​	In VS, select a line and hit `F9` to toggle a breakpoint. `F10` step over and `F11` step into.

​	The *call stack* shows you the stack of functions that have been called at any given moment.

​	The *watch window* can inspect the values of the variables in your program. You can even call functions in your program from within the watch window.

#### Data Breakpoints

​	Modern debuggers have the ability to set a breakpoint that trips whenever a specific memory address is written to. You can just type `&object` into the watch window to find object's address.

#### Conditional Breakpoints

​	This is very useful for setting breakpoints that only trip when a function is called on a particular instance of a class. Hit count for a breakpoint means only actually stop the program when that counter reaches zero. This is really useful for situations where your breakpoint is inside a loop.

#### Debugging Optimized Builds

​	Sometimes bugs only occur in your non-debug build, but they disappear whenever you run the debug build. Here are a few tips.

- *Learn to read and step through disassembly in the debugger*: Thanks to instruction reordering, you'll often see the program counter jump around erratically within the function when viewed in source code mode.
- *Use registers to deduce variables' values or address*: The debugger will sometimes be unable to display the value of a variable in a non-debug build. However, if the program counter is not too far away from the initial use of the variable, there's a good chance its address or value is still stored in one of the CPU's registers. Using the register window or typing the name of the register into a watch window to see its contents.
- *Inspect variables and object contents by address*: Given the address of a variable, you can usually see its contents by casting the address to the appropriate type in a watch window.
- *Leverage static and global variables*: If you cannot deduce the address of a variable or object, keep your eye open for a static or global that might contain its address.

# C++ Primer

- 当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。
- 编译器处理完类中的全部声明之后才会处理成员函数的定义。
- 如果类成员变量是const、引用，或者某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。
- 构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。成员的初始化顺序与它们在类定义中的出现顺序一致。最好令构造函数初始值的顺序与成员声明的顺序保持一致。
- 一个**委托构造函数**使用它所属类的其他构造函数执行它自己的初始化过程。
- 受委托的构造函数在**委托构造函数**的初始值列表中被调用，参数列表必须与类中的另一个构造函数匹配。
- 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次运行，然后控制权才会交还给委托者的函数体。
- 如果构造函数只接受一个实参，则它实际上定义了此参数类型转换为该类类型的隐式转换机制，有时称这种构造函数为 *转换构造函数*。
- 当我们用`explicit`关键字声明构造函数时，它将只能以直接初始化的形式使用。编译器不会在自动转换过程中使用该构造函数。
- 关键字`explicit`只对一个实参的构造函数有效，只能在类内声明构造函数时使用`explicit`关键字，在类外部定义时不能使用。