review: 005 008 010 011

[Codeforces706C](https://codeforces.com/problemset/problem/706/C)

# Game Engine Architecture

## Data, Code and Memory Layout

***Floating-Point Endian-Swapping***

​	you can endian-swap it just as if it were an integer. One alternative that’s guaranteed to be portable is to use a union(A union is a special class type that can **hold only one of its non-static data members at a time**), as follows:

```c++
union U32F32
{
	U32	m_asU32;
	F32	m_asF32;
};
inline F32 swapF32(F32 value)
{
	U32F32 u;
	u.m_asF32 = value;
	// endian-swap as integer
	u.m_asU32 = swapU32(u.m_asU32);
	return u.m_asF32;
}
```

 ### Declarations, Definitions and Linkage

#### Translation Units Revisited

​	An object file may contain unresolved references to functions and global variables defined in *other*.cpp files. Whenever compiler encounters a reference to an external global variable or function, it must “go on faith” and assume that the entity in question really exists. as shown below:

![image-20220822141903395](C:\Users\Clan\OneDrive\桌面\study\研一\studys\day by day\pictures\image-Unresolved external references in two translation units.png)

​	It is the linker’s job to combine all of the object files into a final executable. The linker reads all of the object files and attempts to resolve all of the unresolved cross-references between them. as shown below:

![image-20220822142122587](C:\Users\Clan\OneDrive\桌面\study\研一\studys\day by day\pictures\image-20220822142122587.png)

​	The linker can generate only two kinds of errors:

- An extern reference might not be found, in which case the linker generates an “unresolved symbol” error.
- more than one variable or function with the same name, in which case it generates a “multiply defined symbol” error.

​	As shown below:

![image-20220822142338452](C:\Users\Clan\OneDrive\桌面\study\研一\studys\day by day\pictures\image-20220822142338452.png)

#### Declaration v.s. Definition

- A *declaration* is a description of a data object or function. It provides the compiler with the *name* of the entity and its *data type* or *function signature*(return type and argument types).
- A *definition* describes a unique region of memory in the program. This memory might contain a variable, an instance of a class or the machine code of a function.

​	In other words, a declaration is a *reference* to an entity, while a definition is the *entity itself*. A definition is always a declaration, but the reverse is not always the case.

​	Functions are defined by writing the body of the function immediately after the signature. A pure declaration of function is done by writing a function signature followed by a semicolon.

​	Variables and instances of classes are defined by writing the data type followed by the name of the variable or instance. A global variable defined in one translation unit can optionally be declared for use in other translation units by using the extern keyword.

​	Any particular data object or function in a C++ program can have multiple identical *declarations*, but each can have only one *definition*.

***Definitions in Header Files and Inlining***

​	It is usually dangerous to place definitions in header files. Inline function definitions are an exception to this rule, because each invocation of an inline function gives rise to a brand new copy of that function’s machine code,  embedded directly into the calling function. In fact, inline function definitions must be placed in header files. **The compiler must be able to “see” the body of the function in order to inline it**.

​	The inline keyword is really just a hint to the compiler, and the compiler gets the final say as to whether the function will really be inlined or not. Some compilers provide syntax like `__forceinline`.

***Templates and Header Files***

​	**The definition of a templated class or function must be visible to the compiler across all translation units in which it is used.** If you want a template to be usable in more than one translation unit, the template must be placed into a header file(just like inline function).

#### Linkage

​	Every definition in C++ has a property known as *linkage*. A definition with *external linkage* is visible to and can be referenced by any other translation units. A definition with *internal linkage* can only be “seen” inside the translation unit. In a sence, linkage is the translation unit’s equivalent of the `public:` and `private:` keywords in C++ class definitions.

​	By default, definitions have external linkage. The `static` keyword is used to change a definition’s linkage to internal. Note that two or more identical `static` definitions in two or more different .cpp files are considered to be *distinct entities* by the linker.

​	Inline functions have internal linkage by default, just as if they had been declared `static`. The linker sees each copy as a distinct entity.

#### Memory Layout of a C/C++ Program

​	Most UNIX-like operating systems employ a executable file format called the *executable and linking format* (ELF). Therefore it have a .elf extension. The Windows executable format is similar to the ELF format(but with .exe extension). Whatever its format, the executable file always contains a partial *image* of the program as it will exist in memory when it runs. “Partial” image because the program generally allocates memory at runtime.

​	The image is usually comprised of at least the following four segments:

1. *Text segment*: Sometimes called the code segment, this block contains executable machine code for all functions defined by the program.
2. *Data segment*: This segment contains all **initialized** global and static variables. When the executable file is loaded into memory, the initialized global and static variables are ready to go.
3. *BSS segment*: This segment contains all of the **uninitialized** global and static variables defined by the program. The linker simply stores a count of how many zero bytes are required to account for all of the uninitialized globals and statics in the segment. When the executable is loaded into memory, the operating system reserves the requested number of bytes for the BSS section and fills it with zeros prior to calling the program’s entry point.
4. *Read-only data segment*:  This segment contains any read-only (constant) global data defined by the program. Note that integer constants are often used as *manifest constants* by the compiler, meaning that they are inserted directly into the machine code wherever they are used.

# Foundations of Animation

## Interacting Particle System

#### Implementation

​	For $N$ particles, the internal representation of the StateVector is a $2N$ array of elements of type Vector3D. The first $N$ elements, $0\cdots(N − 1)$, are the positions of the particles. The next $N$ elements, $N\cdots(2N − 1)$, are the velocities of the particles.

```c++
class StateVector;

StateVector S, S_;
n = 0; t = 0; S = S0;
while(t<t_max){
	S_ = F(S, t);
    S_new = NumInt(S, S_, h);  //integration
    //TODO: Collision detection
    S = S_new;
    n = n+1;t = n*h;
}

StateVector F(const StateVector& S, float t){
    StateVector S_;
    S_ = Accelerations(S, t);
    for(int i=0;i<N;i++){
        S_[i] = S[i+N];
    }
    return S_;
}

StateVector Accelerations(const StateVector& S, float t){
    StateVector S_;
    vec3 f;
    //compute environmental accelerations
    for(int i=0;i<N;i++){
        S_[i+N] = 1/m[i]*ff(S,i,t);
    }
    //interparticle accelerations
    for(int i=0;i<N-1;i++){
		for(int j=i+1;j<N;j++){
            f = fg(S, i, j, t);
            S_[i+N] += 1/m[i]*f;
            S_[j+N] -= 1/m[j]*f;
        }
    }
    return S_;
}
```

### Expanding the StateVector

​	It only makes sense to include a quantity in the state vector if it has a derivative that is a function of only system state and time. One solution is to copy each object’s variables to the state vector to begin the simulation calculation, and then copy them back to the objects after integration is complete.

