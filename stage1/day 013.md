review: 006 009 011 012

[Codeforces1396A](https://codeforces.com/problemset/problem/1396/A)

最大子数组的和

# Game Engine Architecture

## Data, Code and Memory Layout

​	Global variables are stored in either the data or BSS segments, depending on whether or not they have been initialized.

​	The `static` keyword can also be used to declare a global variable *within a function* (function-static). A function-static variable can only be “seen”  inside the function. It is initialized the first time the function is called. But in terms of memory layout, a function-static variable stored in either the data or BSS segment.

#### Program Stack

​	When an executable program is loaded into memory and run, the operating system reserves an area of memory for the program stack. Whenever a function is called, a contiguous area of stack memory is pushed onto the stack—we call this block of memory a **stack frame.** A stack frame stores three kinds of data:

1. the *return address* of the calling function.
2. The contents of all relevant CPU registers are saved in the stack frame. The return value of the called function is usually left in a specific register.
3. The stack frame also contains all local variables declared by the function; these are also known as *automatic variables*.

​	Pushing and popping stack frames is usually implemented by adjusting the value of a single register in the CPU, known as the stack pointer. When a function returns, its stack frame is abandoned. A common error involves returning the address of a local variable.

#### Dynamic Allocation Heap

​	The globals and statics are allocated within the executable image, as defined by the data and BSS segments of the executable file. The locals are allocated on the program stack. Both of these kinds of storage are *statically* defined, meaning that the size and layout of the memory is known when the program is compiled and linked (We don't know exactly how many stack memory the program will occupy, but we know the size of every stack frame of the program).

​	The operating system maintains a block of memory for each running process from which memory can be allocated by calling `malloc()`(or `HeapAlloc()` under Windows) and later freed by calling `free()`(or `HeapFree()` under Windows).

​	Individual classes may overload `new` and `delete` operators to allocate memory in custom ways, you cannot simply assume that new is always allocating from the global heap.

### Member Variables

​	A class or struct declaration allocates no memory. It is merely a description of the layout of the data. Once a struct or class has been declared, it can be allocated (defined) in any of the ways that a primitive data type can be allocated.

#### Class-Static Members

​	The `static` keyword has many different meanings depending on context:

- *file-static* :  restrict the visibility of this variable or function so it can only be seen inside this .cpp file.
- *function-static* : this variable is a global, but it can only be seen inside this function.
- *class-static* : this variable is not a regular member variable, but instead **acts just like a global**.

​	The visibility of a class-static variable is determined by the use of `public:`, `protected:` or `private:` keywords. Class-static variables are automatically included within the namespace of the class or struct in which they are declared. **the declaration of a class-static variable within a class allocates no memory. The memory for the class-static variable must be defined in a .cpp file.**

### Object Layout in Memory

​	we can simply draw a box for the struct or class, with horizontal lines separating data members. An example below:

```c++
struct Foo
{
	U32	mUnsignedValue;
	F32	mFloatValue;
	I32	mSignedValue;
};
```

![image-20220823155707935](C:\Users\Clan\OneDrive\桌面\study\研一\studys\day by day\pictures\image-20220823155707935.png)

#### Alignment and Packing

​	What happens when small data members are interspersed with larger members? The compiler will typically leave “holes” in the layout. For example:

```c++
struct InefficientPacking
{
	U32	  mU1; // 32 bits
	F32	  mF2; // 32 bits
	U8	  mB3; // 8 bits
	I32	  mI4; // 32 bits
	bool  mB5; // 8 bits
	char* mP6; // 32 bits
};
```

![image-20220823160010830](C:\Users\Clan\OneDrive\桌面\study\研一\studys\day by day\pictures\image-20220823160010830.png)

​	Every data type has a natural *alignment*, which must be respected in order to permit the CPU to read and write memory effectively. The *alignment* of a data object refers to **whether its address in memory is a multiple of its size**(which is generally a power of two).

- An object with 1-byte alignment resides at any memory address.
- An object with 2-byte alignment resides only at even addresses.(`0x0`, `0x2`, `0x4`, `0x8`,,,)
- An object with 4-byte alignment resides only at addresses that are a multiple of four.(`0x0`, `0x4`, `0x8`,,,)

Alignment is important because many modern processors can actually only read and write properly aligned blocks of data.

![image-20220823160516001](C:\Users\Clan\OneDrive\桌面\study\研一\studys\day by day\pictures\image-20220823160516001.png)

# Foundations of Animation

### Spatial Data Structures

​	The effect of one particle on another becomes weaker with physical distance. Specifying one or more spatial regions about each particle, ignoring the interaction effects of any particles outside of nearby regions.

#### Uniform Spatial Grids

​	Starting with a bounding box of width $W$, height $H$, and depth $D$ around all of the particles. If the grid has $L$ depth layers, $M$ rows, and $N$ columns, then the dimensions of a single voxel in the $x$, $y$, and $z$ directions are $\delta_x=W/N$, $\delta_y=H/M$, $\delta_z=D/L$. Each voxel corresponds to an element of a $3D$ array, in which we maintain a list of the particles residing in that voxel.

​	We define the location $\mathbf{x}_0=(x_0, y_0, z_0)$ to be the grid corner with minimum $x$-$y$-$z$ coordinates. the point $\mathbf{x}=(x,y,z)$ is given by the spatial hash function
$$
h(\mathbf{x})=(\lfloor(z-z_0)/\delta_z\rfloor, \lfloor(y-y_0)/\delta_y\rfloor, \lfloor(x-x_0)/\delta_x\rfloor)
$$
​	Any interacting particle algorithm using this uniform grid data structure will perform an initialization at the beginning of each timestep. The initialization will loop through each of the particles in the system, hashing each particle’s position to a grid cell, and placing that particle in the list for that voxel.

​	Neighbor finding in a uniform grid is as easy as computing offsets from a cell’s array indices.

​	The $3D$ array can be allocated as a one-dimensional array of $L \times M \times N$ cells. In this way, the index for cell $(p, r, c)$ will be $i=(pM+r)N+c$.

#### Octrees

![image-20220823191433149](C:\Users\Clan\OneDrive\桌面\study\研一\studys\day by day\pictures\image-20220823191433149.png)

​	If we know the spatial location $\mathbf{x}_i$ of a particle within a parent cell at tree level $L$, whose minimum $x$, $y$, $z$ corner is $\mathbf{x}_p$. Compute the center of the parent cell $\mathbf{x}_c=\mathbf{x}_p+[W/2^{(L+1)},H/2^{(L+1)}, D/2^{(L+1)}]^T$, and let $(\Delta{x},\Delta{y}, \Delta{z})=\mathbf{x}_i-\mathbf{x}_c$. if $\Delta{x}>0$, bit $0$ is $1$, if $\Delta{y}>0$, bit $1$ is $1$, and if $\Delta{z}>0$, bit $2$ is $1$. 

​	Most octree-based particle algorithms store the particles only in the leaves.

#### KD-Trees

![image-20220823195127812](C:\Users\Clan\OneDrive\桌面\study\研一\studys\day by day\pictures\image-20220823195127812.png)

​	Generally, the point chosen is the median from all the points in the parent node. So, there are an equal number of points above and below that value. For $n$ points, there will be $n$ nodes in the tree, and the tree will be of height $log_2n$.

​	To build a kd-tree, first a bounding box is formed around the entire set of particles. Then, one axis is picked, and a median value of all points is found for that axis, choosing the larger value if there is an even number of points.

​	If we assume the number of particles is fixed, we can allocate all space for a kd-tree at once. If we assume that the nodes are stored as an array from $0$ to $n-1$, then the children of node $i$ will be at index $2i+1$ and $2i+2$, and the parent will be at index $\lfloor\frac{i-1}{2}\rfloor$.

​	A common use for kd-trees is to **find particles within a certain distance of a given point** (which might be another particle location). We can do a range search for a kd-tree via a recursive process that checks whether the partition point is within, above, or below the range for the given axis. If it is within the range, then that node is reported, and both children are checked. If it is above or below the range, then the left or right child (respectively) is checked.

# C++ Primer

## IO类

- `<iostream>`定义了用于读写流的基本类型，`<fstream>`定义了读写命名文件的类型，`<sstream>`定义了读写内存`string`对象的类型。
- 类型`ifstream`和`istringstream`都继承自`istream`；类型`ofstream`和`ostringstream`都继承自`ostream`。
- 不能拷贝或对`IO`对象赋值，也不能将形参或返回类型设置为流类型，只能以引用方式传递和返回流。
- 一个流一旦发生错误，其上后续的IO操作都会失败。确定一个流对象的状态的最简单的方法是将它作为一个条件来使用。
- IO库定义了一个与机器无关的`iostate`类型，提供表达流状态的功能，可以当作位集合来使用，一共有四个值。
- `badbit`表示系统级错误，不可恢复；`failbit`表示可恢复错误；`eofbit`表示达到文件末尾；`goodbit`表示未处于错误状态(值为0)
- 每个输出流都管理一个缓冲区，用来保证程序读写的数据，例如执行`os<<"please enter a value:";`，文本可能立即打印，也可能被操作系统保存在缓冲区中。
- 操作系统可以将程序的多个输出操作组合成单一系统级写操作，以提高性能。
- 缓冲区刷新（即数据真正写道输出设备或文件中）的原因有：
  - 程序正常结束，缓冲区刷新是`main`函数`return`语句的一部分
  - 缓冲区满
  - 使用操作符显示刷新，如`endl`（换行）、`ends`（空格）、`flush`（只刷新）
  - `cout<<unitbuf`，之后所有输出操作都会立即刷新缓冲区。
  - 一个输出流关联到另一个流，读写被关联的流时，关联到的流会被刷新。比如读`cin`和写`cerr`的时候，`cout`会被刷新
- 如果程序异常终止，输出缓冲区是不会被刷新的。当调试一个已经崩溃的程序时，需要确认缓冲区的数据已经被刷新。
- `stream.tie`有两个重载版本（是否带参数），不带参数的版本返回与之相关联的`ostream`对象的指针，带参数的版本接受一个`ostream`的指针，将自己关联到此`ostream`。
- 文件流对象（`ifstream`、`ofstream`、`fstream`）的特有操作：
  - `fstream fstrm;` 创建一个未绑定的文件流
  - `fstream fstrm(s);` 创建一个`fstream`， 并打开名为s的文件并与之绑定，默认文件模式依赖于`fstream`的类型。
  - `fstream fstrm(s, mode);` 指定文件模式
  - `fstrm.open(s)` 打开文件并与之绑定，返回`void`
  - `fstrm.close()`、`fstrm.is_open()`