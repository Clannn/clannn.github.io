review: 001, 003, 004

# Algorithm

- STable

```c++
template<typename T, class F=function<T(const T&, const T&)>>
class STable{
public:
    int n;
    vector<vector<T>> mat;
    F func;
    
    STable(const vector<T>& a, const F& f): n(a.size()), func(f){
        int max_log = 32 - __builtin_clz(n);
        mat.resize(max_log);
        mat[0] = a;
        for(int j=1;j<max_log;j++){
            mat[j].resize(n-(1<<j)+1);
            for(int i=0;i<mat[j].size();i++){
                mat[j][i] = func(mat[j-1][i], mat[j-1][i+(1<<(j-1))]);
            }
		}
    }
    
    T get(int l,int r){
        int lg = 32 - __builtin_clz(r-l+1) - 1;
        return func(mat[lg][l], mat[lg][r-(1<<lg)+1]);
    }
};
```

---

# Game Engine Architecture

## Tools of Trade

### Profiling Tools

​	**A profiler is a tool that measures the execution time of your code.** As a rule of thumb, 80%(or more) of the clock time spent running any piece of software is accounted for by only 20%(or less) of the code.

​	A function can eat up time for two reasons: 1. it takes a long time to execute on its own, or 2. it is called frequently.

​	Profilers fall into two broad categories:

- Statistical profilers. The target code runs at almost the same speed, whether or not profiling is enabled. These profilers work by sampling the CPU program counter register periodically and noting which function is currently running.
- Instrumenting profilers: This kind of profiler is aimed at providing the most accurate and comprehensive timing data possible, but at the expense of real-time execution of the target program.

### Memory Leak and Corruption Detection

​	**A memory leak occurs when memory is allocated but never free.** This wastes memory and eventually leads to a potentially out-of-memory condition. **Memory corruption occurs when the program writes data to the wrong memory location,** overwriting the important data that was there.

​	Having a tool to help you detect potential memory corruption and leak problems is necessary.

## Fundamentals of Software Engineering for Games

### C++ Review and Best Practices

​	Inheritance creates an "is-a" relationship between classes. Composition creates a "has-a" relationship between classes.

​	A common rule of *Multiple Inheritance* is to allow only simple, parentless classes to be multiply inherited into an otherwise strictly single-inheritance hierarchy.

#### Design Patterns

​	**Resource Acquisition Is Initialization(RAII).** The acquisition and release of a resource are bound to the constructor and destructor.

---

# C++ Primer

- 当一个类满足以下条件时，我们说他是**聚合类**
  - 所有成员都是public
  - 没有定义任何构造函数、没有类内初始值、没有基类、没有virtual函数
- constexpr函数的参数和返回值必须时字面值类型。数据成员都是字面值类型的聚合类是字面值常量类。
- 如果一个类符合以下条件，则它是一个字面值常量类：
  - 数据成员类型都是字面值类型
  - 至少含有一个constexpr构造函数
  - 必须使用析构函数的默认定义
- 字面值常量类的构造函数可以是constexpr函数， constexpr构造函数可以声明成=default
- constexpr构造函数体一般是空的，只有初始化列表。

- 静态成员函数不与任何对象绑定在一起，它们不包含`this`指针。因此，静态成员函数不能声明为`const`，而且也不能在`static`函数体内使用`this`指针。
- 在类的外部定义静态成员时，不能重复`static`关键字，该关键字只出现在类内部的声明语句中。
- 不能在类内部定义非常量静态成员，可以在类内部初始化常量静态成员。
- 每个静态成员变量都应该在类外部被定义，不管它在类内部有没有被初始化。静态数据成员的定义应该与其他非内联函数的定义放在一个文件中。
- 静态数据成员定义在任何函数之外，因此一旦被定义，将一直存在于程序的整个生命周期中。
- 静态数据成员的类型可以是它所属的类类型，而非静态数据成员只能声明成它所属类的指针或引用。

