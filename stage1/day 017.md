review: 002 010 013 015 016

# Vulkan Tutorial

### What it takes to draw a triangle

#### Step 1 - Instance and physical device selection

​	A Vulkan application starts by setting up the Vulkan API through a `VkInstance`. An instance is created by **describing your application and any API extensions** you will be using. After creating the instance, you can query for Vulkan supported hardware and select one or more `VkPhysicalDevices` to use for operations. You can query for properties like VRAM size and device capabilities to select desired devices.

#### Step 2 - Logical device and queue families

​	After selecting the right hardware device to use, you need to create a `VkDevice` (logical device), where you describe more specifically which `VkPhysicalDeviceFeatures` you will be using, like multi viewport rendering and 64 bit floats.(*What are the differences between API extensions and Device Features?*) You also need to specify which queue families you would like to use. **Most operations performed with Vulkan, like draw commands and memory operations, are asynchronously executed by submitting them to a `VkQueue`.** Queues are allocated from queue families, where each queue family supports a specific set of operations in its queues. For example, there could be separate queue families for graphics, compute and memory transfer operations. The availability of queue families could also be used as a distinguishing factor in physical device selection.

#### Step 3 - Window surface and swap chain

​	We need two components to actually render to a window: a window surface (`VkSurfaceKHR`) and a swap chain (`VkSwapchainKHR`). Note the `KHR` postfix, which means that these objects are part of a Vulkan extension. The surface is a cross-platform abstraction over windows.

​	The swap chain is a collection of *render targets*. Its basic purpose is to ensure that the image that we’re currently rendering to is different from the one that is currently on the screen. Every time we want to draw a frame we have to ask the swap chain to provide us with an *image* to render to. When we’ve finished drawing a frame, the *image* is returned to the swap chain for it to be presented to the screen at some point. The number of render targets and conditions for presenting finished images to the screen depends on the *present mode*. Common present modes are double buffering (`vsync`) and triple buffering.

#### Step 4 - Image views and framebuffers

​	To draw to an *image* acquired from the swap chain, we have to wrap it into a `VkImageView` and `VkFramebuffer`. An *image view* references a specific part of an image to be used, and a *framebuffer* references *image views* that are to be used for color, depth and stencil targets. We'll create an image view and framebuffer for each of images in the swap chain and select the right one at draw time.

#### Step 5 - Render passes

​	Render passes in Vulkan **describe *the type of images*** that are used during rendering operations, **how they will be used**, and **how their contents should be treated**. ***Whereas a render pass only describes the type of images, a `VkFramebuffer` actually binds specific images to these slots.***

#### Step 6 - Graphics pipeline

​	The *graphics pipeline* describes the configurable state of the graphics card, like the viewport size and depth buffer operation and the programmable state using `VkShaderModule` objects. The `VkShaderModule` objects are created from shader byte code. The driver also needs to know which *render targets* will be used in the pipeline, which we *specify by referencing the render pass*.

​	Almost all configuration of the graphics pipeline needs to be set in advance. That means that if you want to switch to a different shader or slightly change your vertex layout, then you need to entirely recreate the graphics pipeline. That means that you will have to create many `VkPipeline` objects in advance. Only some basic configuration, like viewport size and clear color, can be changed dynamically.

#### Step 7 - Command pools and command buffers

​	Operations first need to be recorded into a `VkCommandBuffer` before they can be submitted. **These command buffers are allocated from a `VkCommandPool` that is associated with a specific queue family.** Because the image in the framebuffer depends on which specific image the swap chain will give us, **we need to record a command buffer for each possible image** and select the right one at draw time.

#### Step 8 - Main loop

​	We first acquire an image from the swap chain with `vkAcquireNextImageKHR`. We can then select the appropriate command buffer for that image and execute it with `vkQueueSubmit`. Finally, we return the image to the swap chain for presentation to the screen with `vkQueuePresentKHR`.

​	Operations that are submitted to queues are executed asynchronously. Therefore we have to use synchronization objects like semaphores to ensure a correct order of execution.

​	To draw the first triangle we need to:

- Create a `VkInstance`
- Select a supported graphics card (`VkPhysicalDevice`)
- Create a `VkDevice` and `VkQueue` for drawing and presentation
- Create a window, window surface and swap chain
- Wrap the swap chain images into `VkImageView`
- Create a render pass that specifies the render targets and usage
- Create framebuffers for the render pass
- Set up the graphics pipeline
- Allocate and record a command buffer with the draw commands for every possible swap chain image
- Draw frames by acquiring images, submitting the right draw command buffer and returning the images back to the swap chain

## Instance

​	The very first thing you need to do is initialize the Vulkan library by creating an *instance*. The instance is the connection between your application and the Vulkan library.