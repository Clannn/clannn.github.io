review: 003, 005, 006

# Game Engine Architecture

## Catching and Handling Errors

### Type of Errors

​	In any software project there are two basic kinds of error conditions: *user errors* and *programmer errors*.

### Handing Errors

​	In an ideal world, *all* programmer errors would be caught and fixed before the software ships to the public. When the "user" is the person playing your game, errors should obviously be handled within the context of gameplay. When a developer error occurs, it should make the error *obvious* and then allow the team to continue to work in the presence of the problem.

​	The best way to detect and handle programmer errors (a.k.a. bugs) is often to embed error-checking code into your source code and arrange for failed error checks to halt the program. A common approach to handling errors is to return some kind of failure code from the function in which the problem is first detected.

​	**Turning off exception handling in your game engine altogether.**

​	Assertions check a programmer's assumptions, and the cost of the assertion checks can usually be tolerated during development, but stripping out the assertions prior to shipping the game.

​	A typical assertion implementation:

```c++
#ifdef ASSERTIONS_ENABLED
	#define ASSERT(expr) \
	if(expr) { } \
	else \
	{ \
		reportAssertionFailure(#expr, __FILE__, __LINE__); \
		DebugBreak(); \
	}
#else
	#define ASSERT(expr)
#endif
```

​	Assertions should only be used to catch fatal errors and should be used to catch bugs in the program itself—*never* to catch user errors.

***Compile-Time Assertions***

​	Sometimes the condition we're checking within an assertion involves information that is entirely known at compile time. So we need  a compile-time assertion, also known as *static assertion*.

​	The c++11 standard library defines a macro named `static_assert()` for us. We can use this to implement our `STATIC_ASSERT()`

```c++
#ifdef ASSERTIONS_ENABLED
	#define STATIC_ASSERT(expr) \
	static_assert(expr, "static assert failed: "#expr)
#else
	#define STATIC_ASSERT(expr)
#endif
```

## Data, Code and Memory Layout

​	In 32-bit *two's complement* notation, the value `0xFFFFFFFF` is interpreted to mean -1, and negative values count down from there. So values from `0x00000000`(0) to `0x7FFFFFFF`(2,147,483,647) represent positive integers, and `0x80000000`(-2,147,483,648) to `0xFFFFFFFF`(-1) represent negative integers.