review: 008 011 013 014

 # Game Engine Architecture

## Data, Code and Memory Layout

***Base Pointer***

​	The base pointer (BP) contains the **base address of the current function’s stack frame** on the call stack. Stack-allocated variables occupy a range of memory addresses at a unique offset from the base pointer. Such a variable can be located in memory by simply subtracting its unique offset from the address stored in BP (assuming the stack grows down).

***Status Register***

​	Status register contains bits that reflect the results of the most-recent ALU operation.

***Register Formats***

​	the FPU and VPU typically operate on their own private sets of registers. Because the FPU’s and VPU’s registers are typically wider than the ALU’s GPRs. A 32-bit CPU has GPRs that are 32 bits wide each, but an FPU might operate on 64-bit(or even 80-bit) double-precision floats. Likewise, each register used by a VPU needs to contain a vector of input data. **It’s a good idea to avoid converting data between `int` and `float` formats**, although a VPU can handle both integer and floating-point math, and conversions between the two are much less expensive.

#### Control Unit

​	Its job is to manage the flow of data within the CPU, and to orchestrate the operation of all of the CPU’s other components.

​	The CU runs a program by reading a stream of machine language instructions, decoding each instruction by breaking it into its opcode and operands, and then issuing work requests and routing data to the ALU, FPU, VPU, the registers and the memory controller as dictated by the current instruction’s opcode.

### Clock

​	The CPU can perform at least one primitive operation on every cycle. It’s important to realize that one CPU instruction doesn’t necessarily take one clock cycle to execute. some instructions are very simple, while others are more complex. Today’s pipelined CPUs break even the simplest instruction down into multiple stages. Each stage in a pipelined CPU takes one clock cycle to execute.

#### Processing Power

​	The “processing power” of a computer can be defined as the *throughput* of the machine—the number of operations it can perform during a given interval of time. Such as millions of instructions per second (MIPS) or floating-point operations per second (FLOPS).

### Memory

​	Each "cell" of memory contain a single byte of data. Each one-byte memory cell is identified by its address—a simple numbering ranging from $0$ to $N−1$, where $N$ is the size of addressable memory in bytes.

### Buses

​	Data is transferred between the CPU and memory over connections known as *buses*.

​	A typical computer contains two buses: An *address bus* and a *data bus*. The CPU read data from a memory cell into one of its registers by supplying an address to the memory controller via the address bus. The memory controller responds by presenting the bits of the data item stored in the cell onto the data bus. Likewise, the CPU write data......

#### Bus Widths

​	The width of the *address bus* controls the range of possible addresses that can be accessed by the CPU. The width of the *data bus* determines how much data can be transferred between CPU registers and memory at a time. (The data bus is typically the same width as the general-purpose registers in the CPU.)

​	It’s possible to access data items that are narrower than the width of a machine’s data bus, but it’s typically more costly than accessing items whose widths match that of the data bus.

### Machine and Assembly Language

​	As far as the CPU is concerned, a “program” is nothing more than a sequential stream of relatively simple *instructions*. Each instruction tells the control unit (CU), and the other components within the CPU to perform an operation.

​	The set of all instructions supported by a given CPU is called its *instruction set architecture* or ISA.

#### Machine Language

​	Computers can only deal with numbers. As such, each instruction in a program’s instruction stream must be encoded numerically. When a program is encoded in this way, we say it is written in machine language. Of course, each distinct CPU/ISA has its own machine language.

​	Every machine language instruction is comprised of three basic parts:

- an *opcode*, which tells the CPU which operation to perform.
- zero or more operands which specify the inputs and/or outputs of the instruction.
- some kind of options field, specifying things like the addressing mode of the instruction and possibly other flags.

​	The way in which an instruction’s operands are interpreted and used by the CPU is known as the instruction’s addressing mode. The first byte of instruction perhaps containing the opcode, addressing mode and various options flags, followed by some number of bytes for the operands. Each ISA defines the width of an instruction word.

​	Instruction words are often multiples of 32 or 64 bits, because this matches the width of the CPU’s registers and/or data bus.

# C++ Primer

- 如果`fstream`对象调用`open`失败，`failbit`会被置位，进行`open`是否成功的检查是一个好习惯。
- 要将文件流关联到另一个文件，必须首先关闭已经关联的文件。
- 当一个`fstream`对象被销毁时，`close`会自动被调用。
- 文件模式(`ios_base::mode`)包括：1. `in`（读）2. `out`（写）3. `app`（写到文件末尾）4. `ate`（立即定位到末尾）5. `trunc`（截断）6. `binary`（二进制方式进行IO）
- 以`out`模式打开文件会丢弃已有数据。只有`app`或`in`模式会保留文件数据。
- `stringstream`特有操作：
  - `sstream strm(s);` 创建一个`stringstream`并保存`s`的拷贝
  - `strm.str();` 返回`strm`中保存的`s`的拷贝
  - `strm.str(s);` 将`s`拷贝到`strm`中，返回`void`
- `std`中的顺序容器有`vector`、`deque`、`list`、`forward_list`、`array`、`string`，`deque`支持随机访问。
- `forward_list`没有`size()`操作，其他顺序容器的`size()`操作都是`O(1)`
- 如果没有很好的理由选择其他容器，请用`vector`
- `array`不支持范围拷贝(`begin`, `end`)与列表赋值
- 所有迭代器都定义了`*`、`->`、`++`、`==`、`!=`、`--`运算，反向迭代器的`++`运算会得到上一个元素