review: 002, 004, 005

# Algorithm

- String Hash

```c++
class Hash{
public:
    static constexpr uint32_t B = 13331;

    int n;
    vector<uint64_t> pre;
    vector<uint64_t> p;

    Hash(const string& s): n(s.size()){
        if(n==0) return;
        pre.resize(n);
        p.resize(n);
        pre[0] = s[0];
        p[0] = 1;
        for(int i=1;i<n;i++){
            pre[i] = pre[i-1]*B + s[i];
            p[i] = p[i-1]*B;
        }
    }
    uint64_t get(int l,int r){
        if(l==0) return pre[r];
        else return pre[r]-pre[l-1]*p[r-l+1];
    }
    void append(const string& s){
        for(int i=0;i<s.size();i++){
            pre.push_back(pre[n-1]*B+s[i]);
            p.push_back(p[n-1]*B);
            n++;
        }
    }
};
```

- **允许k次失配的字符串匹配：**枚举所有可能匹配的子串，对于特定字串$s$，通过哈希+二分可以找到$s$与$p$第一个不同的位置$id$，从$id+1$继续寻找，最多进行$k$次。复杂度: $O(knlog_2m)$
- **最长回文：**二分答案，判断时枚举对称轴。复杂度：$O(nlog_2n)$
- **最长公共子串：** 给定$m$个总长不超过$n$的非空字符串，查找所有字符串的最长公共子串。二分答案$k$，check时将所有字符串中长度为$k$的子串进行哈希，放入$n$个哈希表中，然后求交集。复杂度：$O(nlog_2n)$
