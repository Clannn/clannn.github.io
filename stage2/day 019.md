# Game Engine Architecture

## 子系统的启动与关闭

​	游戏引擎是由许多**交互**的子系统组成的，每个子系统必须按照特定的顺序进行配置和初始化，由于子系统之间随时可能交互，所以子系统必须是全局变量或者静态变量。

### C++静态变量初始化顺序

​	c++中的静态变量与全局变量是在进入程序入口点`main()`之前构造的，**构造顺序完全不可预测**。同样，`main()`函数结束之后的**析构顺序也完全无法预测**。因此不能使用C++提供的方法。最好的方式是：

```c++
class RenderManager{
public:
    RenderManager(){
        //do nothing
    }
    ~RnederManager(){
		//do nothing
    }
    void startUp(){
        //do something
    }
    void shutDown(){
        //do something
    }
};
//global
RenderManager gRenderManager;
int main(){
    gRenderManager.startUp();
    //...
    gRenderManager.shutDown();
}
```

## 内存管理

​	软件的性能不仅仅取决于算法复杂度，还取决于如何利用内存：

- 动态分配内存（`malloc()`或`new`）是一个非常慢的操作，尽量避免使用或使用自定义的内存分配器
- 现代CPU可以非常高效的处理小的、连续的内存数据。

### 动态分配内存的优化

​	动态分配内存（`malloc()`或`new`）的高成本主要因为：1. 可以分配任意大小的内存（1B~1GB），需要大量的管理开销。2. 在大多数操作系统中，`malloc()`和`free()`必须进行内核上下文切换。因此，**尽量不要进行堆分配，永远不要在循环中进行堆内存分配**。

1. 基于栈的内存分配

   大多数情况下，在关卡切换的时候都不得不分配新的内存，然后在关卡结束时释放掉。此时，使用基于栈的内存分配是很有意义的。可以通过声明一个大的全局数组来分配一大块连续的内存，这种情况下内存是从BSS段中分配出来的。程序中将这块内存当作栈使用，通过“栈顶”指针手动管理。需要注意的是，**内存的释放必须按照与分配时相反的顺序执行**。相应声明可能如下所示：

   ```c++
   class StackAllocator{
   public:
   	explicit StackAllocator(uint32_t stackSize_bytes);
       uint8_t* alloc(uint32_t, size_bytes);
       uint8_t* getTop();
       void freeToMarker(uint8_t* marker);
       void clear();
   private:
       uint8_t* m_pBottom;
       uint8_t* m_pTop;
       uint8_t* m_pCapability；
   };
   ```

   还可以使用双端的栈来管理内存，一端用来加载和卸载关卡，另一端用来分配和释放临时内存。这样就很少出现内存碎片问题。

2. 分配池

   分配池用于分配大小相同的小块内存。使用链表来管理池中的空闲元素，分配时从链表获取一个元素，释放时将之插入链表。由链表管理时，我们需要一个指针指向下一个空闲元素，也就需要额外的`sizeof(void*)*numElements`内存。但因为元素本身就是空闲的，我们可以在其中保存指向下一个空闲元素的指针，只需要满足`sizeof(Element)>=sizeof(void*)`。这样就只需额外一个指针来指向头部。

3. 内存对齐的动态分配

   可以分配一个比实际请求多一点的内存，通过向上移动内存块来使内存地址正确对齐，然后返回移位的地址。多分配的字节数等于对齐减一。具体实现如下：

   ```c++
   uintptr_t AlignAddress(uintptr_t addr, size_t align){
       const size_t mask = align - 1;
   	assert((align & mask) == 0); // pwr of 2
   	return (addr + mask) & ~mask;
   }
   template<typename T>
   T* AlignPointer(T* ptr, size_t align){
       const uintptr_t addr = reinterpret_cast<uintptr_t>(ptr);
       const uintptr_t addrAligned = AlignAddress(addr, align);
       return reinterpret_cast<T*>(addrAligned);
   }
   void* AllocAligned(size_t bytes, size_t align){
       size_t worstCaseBytes = bytes + align - 1;
       U8* pRawMem = new U8[worstCaseBytes];
       return AlignPointer(pRawMem, align);
   }
   ```

   释放对齐的内存时，我们需要找到原始未对齐的内存地址。因为我们额外分配了内存，可以将偏移量保存在对齐的内存地址的前一个地址，但这样有一个问题是原始分配的内存就是对齐的，通过额外分配`align`字节的内存来解决这个问题。具体如下：

   ```c++
   void* AllocAligned(size_t bytes, size_t align){
       size_t actualBytes = bytes + align;
       U8* pRawMem = new U8[actualBytes];
       U8* pAlignedMem = AlignPointer(pRawMem, align);
       if (pAlignedMem == pRawMem)
           pAlignedMem += align;
       ptrdiff_t shift = pAlignedMem - pRawMem;
       assert(shift > 0 && shift <= 256);
       pAlignedMem[-1] = static_cast<U8>(shift & 0xFF);
       return pAlignedMem;
   }
   void FreeAligned(void* pMem){
       if (pMem){
           U8* pAlignedMem = reinterpret_cast<U8*>(pMem);
           ptrdiff_t shift = pAlignedMem[-1];
           U8* pRawMem = pAlignedMem - shift;
           delete[] pRawMem;
       }
   }
   ```

# 四元数

## 复数的性质

**乘法**：
$$
\begin{aligned}
z_1 z_2 &=(a+b i)(c+d i) \\
&=a c+a d i+b c i+b d i^2 \\
&=ac-bd+(bc+ad)i \\
&=
\left[\begin{matrix}
a & -b \\
b & a
\end{matrix}\right]\left[\begin{matrix}
c \\
d
\end{matrix}\right]
\end{aligned}
$$
**共轭**：
$$
||z||=\sqrt{z\overline{z}}
$$
**复数与旋转**：
$$
\begin{align}
\left[\begin{array}{cc}
a & -b \\
b & a
\end{array}\right]&=\sqrt{a^2+b^2}\left[\begin{array}{cc}
\frac{a}{\sqrt{a^2+b^2}} & \frac{-b}{\sqrt{a^2+b^2}} \\
\frac{b}{\sqrt{a^2+b^2}} & \frac{a}{\sqrt{a^2+b^2}}
\end{array}\right] \\
&=\sqrt{a^2+b^2}
\left[\begin{matrix}
cos\theta & -sin\theta \\
sin\theta & cos\theta
\end{matrix}\right] \\
&=
\left[\begin{matrix}
||z|| & 0 \\
0 & ||z||
\end{matrix}\right]
\left[\begin{matrix}
cos\theta & -sin\theta \\
sin\theta & cos\theta
\end{matrix}\right]
\end{align}
$$

## 三维空间的旋转

### 轴角

​	假设我们有一个经过原点的（如果旋转轴不经过原点可以先将旋转轴平移到原点，进行旋转，再平移回原处）旋转轴$\mathbf{u}=(x,y,z)$。我们希望将一个向量$\mathbf{v}$绕这个旋转轴旋转$\theta$角到$\mathbf{v}^\prime$。这种情况下表示旋转需要$4$个变量，将转轴$\mathbf{u}$规定为单位向量，则只需$3$个变量。正好对应旋转的$3$个自由度。

​	将向量分解为平行于转轴和垂直于转轴，显然平行于转轴的向量不会改变。对于垂直于转轴的向量：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221017092327085.png" alt="image-20221017092327085" style="zoom:80%;" />
$$
\begin{aligned}
\mathbf{v}_{\perp}^{\prime} &=\mathbf{v}_v^{\prime}+\mathbf{v}_w^{\prime} \\
&=\cos (\theta) \mathbf{v}_{\perp}+\sin (\theta) \mathbf{w} \\
&=\cos (\theta) \mathbf{v}_{\perp}+\sin (\theta)\left(\mathbf{u} \times \mathbf{v}_{\perp}\right)
\end{aligned}
$$
因此，最终的旋转表示为：
$$
\begin{aligned}
\mathbf{v}^{\prime}&=\mathbf{v}_{||}^{\prime}+\mathbf{v}_{\perp}^{\prime} \\
&=\mathbf{v}_{||}+\cos (\theta) \mathbf{v}_{\perp}+\sin (\theta)\left(\mathbf{u} \times \mathbf{v}_{\perp}\right) \\
&=\left(\mathbf{u}\cdot\mathbf{v}\right)\mathbf{u}+cos(\theta)\left(\mathbf{v}-\left(\mathbf{u}\cdot\mathbf{v}\right)\mathbf{u}\right)+sin(\theta)\left(\mathbf{u}\times\mathbf{v}\right) \\
&=cos(\theta)\mathbf{v}+\left(1-cos\theta\right)\left(\mathbf{u}\cdot\mathbf{v}\right)\mathbf{u}+sin\theta\left(\mathbf{u}\times\mathbf{v}\right)
\end{aligned}
$$

## 四元数

四元数的定义为：
$$
q=a+bi+cj+dk
$$
其中：
$$
i^2=j^2=k^2=ijk=-1
$$
写成向量形式：
$$
q=[a,b,c,d]=[s,\mathbf{v}]
$$
**四元数乘法不满足交换律**，与复数一样，四元数乘法可写成矩阵形式，直接给出结果：
$$
q1q2=
\left[\begin{matrix}
a & -b & -c & -d \\
b & a & -d & c \\
c & d & a & -b \\
d & -c & b & a 
\end{matrix}\right]
\left[\begin{matrix}
e \\
f \\
g \\
h
\end{matrix}\right]
$$
对任意四元数$q1=[s,\mathbf{v}]$，$q2=[t,\mathbf{u}]$，$q1q2$的结果为：
$$
q1q2=[st-\mathbf{u}\cdot\mathbf{v}, s\mathbf{u}+t\mathbf{v}+\mathbf{u}\times\mathbf{v}]
$$
**纯四元数表示实部为0的四元数**。

在轴角的基础上，将旋转轴与向量表示为纯四元数$u=[0,\mathbf{u}]$，有：
$$
\begin{align}
\mathbf{v}_{\perp}^\prime&=\cos (\theta) \mathbf{v}_{\perp}+\sin (\theta)\left(\mathbf{u} \times \mathbf{v}_{\perp}\right) \\
v_{\perp}^\prime&=\cos (\theta)v_{\perp}+\sin (\theta)\left(uv_{\perp}\right) \\
&=\left(cos(\theta)+sin(\theta)u\right)v_{\perp} \\
&=\left( [cos(\theta), \mathbf{0}]+[0, sin(\theta)\mathbf{u}] \right)v_{\perp} \\
&=[cos(\theta), sin(\theta)\mathbf{u}]v_{\perp} \\
&=qv_{\perp}
\end{align}
$$
综上，**当$\mathbf{v}_{\perp}$正交于旋转轴$\mathbf{u}$时，旋转$\theta$角之后的$\mathbf{v}_{\perp}^\prime$可以用四元数乘法来获得，令$v_{\perp}=[0,\mathbf{v}_{\perp}]$，$q=[cos(\theta), sin(\theta)\mathbf{u}]$，那么：$v_{\perp}^\prime=qv_{\perp}$**。其中$q$还是单位四元数。

四元数同样满足旋转的复合，令$q=p^2$，则：$p=[cos(\theta/2), sin(\theta/2)\mathbf{u}]$。再由$q^{-1}=[cos(-\theta), sin(-\theta)\mathbf{u}]=q^{\star}$有：
$$
\begin{align}
v^\prime&=v^\prime_{||}+v^\prime_{\perp} \\
&=v_{||}+qv_{\perp} \\
&=pp^{-1}v_{||}+ppv_{\perp} \\
&=pp^{\star}v_{||}+ppv_{\perp} \\
&=pv_{||}p^{\star}+pv_{\perp}p^{\star} \\
&=pvp^{\star}
\end{align}
$$
综上，**任意向量$\mathbf{v}$沿着以单位向量定义的旋转轴$\mathbf{u}$旋转$\theta$度之后的$\mathbf{v}^\prime$可以使用四元数乘法来获得。令$v=[0,\mathbf{v}]$，$q=[cos(\theta/2), sin(\theta/2)\mathbf{u}]$，那么：**
$$
v^\prime=qvq^{\star}=qvq^{-1}
$$
对于任意表示旋转的单位四元数$q=[a, \mathbf{b}]$，它对应的旋转角度：$\theta/2=cos^{-1}(a)$，它对应的旋转轴：$\mathbf{u}=\mathbf{b}/sin\left(cos^{-1}(a)\right)$。

$q$与$-q$表示的旋转是等价的。

# C++ Primer

## 动态内存管理类

​	对于“拷贝后销毁”的对象，我们可以通过移动构造函数和`std::move`来节约拷贝和销毁的开销。移动构造函数**将资源从给定对象“移动”而不是拷贝到正在创建的对象**。使用`std::move(object)`函数将返回对象的右值引用。而移动构造函数则是以右值引用作为参数。

- 标准库容器可以保存不可拷贝的类型，只要它们能被移动即可
- 右值引用是**绑定到右值的引用**，可以用`&&object`来获取对象的右值引用
- 一个左值表达式表示的是一个对象的身份，一个右值表达式表示的是对象的值
- 返回左值引用的函数、赋值运算、下标、解引用、前置自增/减，都是返回左值的例子
- 返回非引用类型的函数、算术运算、关系运算、位运算、后置自增/减，都是返回右值的例子
- 右值引用也不过是某对象的另一个名字而已，可以将右值引用或`const`左值引用绑定到右值表达式上
- 由于右值引用只能绑定到临时对象，可知：所引用的对象将要被销毁；该对象没有其他用户。这意味着使用右值引用的代码可以自由接管所引用对象的资源
- 变量是左值，因此我们不能将一个右值引用绑定到一个变量上，**即使这个变量是右值引用也不行**。
- `std::move`显式地将一个左值转换为对应地右值引用类型
- 我们可以销毁一个`move`后地原对象，也可以赋予它新的值，但不能使用一个`move`后对象的值
- **一旦资源完成移动，原对象必须不再指向被移动的资源**，否则将导致刚移动的内存被释放
- `noexcept`放在函数的参数列表之后，通知编译器该函数不抛出任何异常
- 不抛出异常的移动构造函数和移动赋值函数必须标记为`noexcept`
- 如果移动了部分元素后抛出一个异常，意味着旧空间中被移动的源元素可能已经被改变了，而新空间中未构造的元素还不存在

# Vulkan Tutorial

## Rendering and presentation

### Subpass dependencies

​	子流程依赖是用来处理渲染流程中，各个子流程之间图像布局的转换。虽然我们现在只有一个subpass，但在此子流程之前和之后的操作也被视为隐式的subpass。有两个内置的依赖项负责在管线开始和结束时处理这个问题，但是由于我们在管线的`COLOR_ATTACHMENT_OUTPUT`阶段等待信号量`ImageAvailable`，也就是说，管线开始时有可能还没获取到图像，也就没法作布局转换。

## Frames in flight

​	由于我们现在只有一个Command buffer，因此我们需要等待前一帧绘制完成后再开始下一帧的绘制，这导致CPU不必要的空闲。如果想同时渲染多帧，那么在渲染期间访问和修改的所有资源都必须复制，包括命令缓冲区，信号量和fence。还需要确定一个能同时处理的最大帧数，一般不超过$3$，因为我们不希望CPU领先GPU太多，这样会造成不必要的延迟。

## Swap chain recreation

​	我们需要捕捉一些事件，这些事件的发生会导致当前的窗口表面变得不兼容（比如窗口大小改变），捕捉到相应事件之后，重建交换链。重建时，所有与之相关的组件都应该重建，同时，为了确保这些组件的旧版本在重建之前被清理，我们将相关的清理代码转移到一个单独的函数中`clearnupSwapChain`，最终，重建交换链的定义如下：

```c++
void recreateSwapChain() {
	vkDeviceWaitIdle(device);
    
    cleanupSwapChain();
    
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
}
```

也可以在渲染的同时重建交换链，此时需要在重建交换链时传递`oldSwapChain`，并在使用完成后销毁它。

​	最后，我们只需要确定在何时重建交换链，`vkAcquireNextImageKHR`和`vkQueuePresentKHR`函数返回以下特殊值来表示交换链已经“过时”了：

- `VK_ERROR_OUT_OF_DATE_KHR`：交换链与渲染表面不兼容，通常发生在窗口大小改变之后
- `VK_SUBOPTIMAL_KHR`：交换链仍可以呈现到表面，但表面属性与交换链不再完全匹配
