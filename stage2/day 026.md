# Game Engine Architecture

## The Resource Manager

### Runtime Resource management

9. Handling Cross-References between Resources

   为了理解资源管理器如何维护数据对象之间的交叉引用，首先需要知道交叉引用在内存和硬盘上是如何表示的。在内存中，数据对象的引用是通过指针或引用来实现的，比如一个`mesh`对象可能拥有一个数据成员`Material* m_pMaterial`。但指针只是内存地址，我们不能在硬盘上用指针来表示对象间的交叉引用。

   ***GUIDs as Cross-References***

   一个好的方法是，每个交叉引用都保存为被引用对象的GUID。我们原本拥有一个防止资源重复加载的表，当从硬盘上载某个数据对象时，遍历其引用的数据对象，如果不在资源表中，则将其加载进内存。所有相互依赖的数据对象都加载进内存后，就可以用指针来表示交叉引用

   ***Pointer Fix-Up Tables***

   当我们将同一个资源文件的数据对象以二进制方式存储到硬盘时，另一种常见的方法是**将指针转化为文件偏移量**存储在硬盘中。考虑一组通过指针相互交叉引用的数据对象，当我们把这组对象存储到一个二进制文件时，需要以任意的顺序遍历它们，并且把每个对象的内存映像顺序地写到文件中。如下图所示：

   <img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221027153203688.png" alt="image-20221027153203688" style="zoom:80%;" />

   由于每个数据对象在文件中是连续的，因此我们可以通过偏移量来区分不同的数据对象。当我们将对象写进硬盘时，首先需要定位每个数据对象中的每个指针，将每个指针转换为其所指对象的偏移量。当文件从硬盘上载到内存时，我们还需要将这些偏移量还原成指针，由于对象是连续存储的，因此，如下所示：

   ```c++
   U8* ConvertOffsetToPointer(U32 objectOffset, U8* pAddressOfFileImage){
       U8* pObject = pAddressOfFileImage + objectOffset;
       return pObject;
   }
   ```

   <img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221027154329818.png" alt="image-20221027154329818" style="zoom:80%;" />

   还有一个问题是，在文件存储进硬盘时，我们如何定位每个指针？相反，将文件上载到内存时，如何定位每个需要转换为指针的偏移量？当我们将数据对象存储到硬盘时，程序知道数据对象的类型，所以应该知道所有指针的位置。同时，所有指针的位置（偏移量表示）都被存储在一个称为指针修复表的表中，与数据对象一起写入二进制文件。当文件被加载进内存时，即可遍历指针修复表并修复每个指针。如下图所示：

   ![image-20221027155528257](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221027155528257.png)

   **Storing C++ Objects as Binary Images: Construtors**

   当一个C++对象从二进制文件上载到内存时，需要调用对象的构造函数。第一种方式，可以将对象实现为无构造函数和虚函数的类，这样就不需要调用构造函数。第二种方式，使用`placement new`在已经预分配的内存上调用构造函数，如下所示：

   ```c++
   void* pObject = ConvertOffsetToPointer(objectOffset, pAddressOfFileImage);
   new(pObject) ClassName;
   ```

   **Handling External References**

   对于跨资源文件的引用，首先需要保存引用的所有资源文件路径，单独加载每个资源文件，最后更新指针。

10. **Post-Load Initialization**

    大多数类型的资源在加载到内存之后，还需要经过一些操作才能供引擎使用，比如将数据从内存转移到显存，或者去掉文件中的不相关数据。每种类型的资源文件都有其独特的加载后初始化过程，可以利用c++的多态来实现这一点。每种资源类型都定义一个`virtual`的`init()`和`destroy()`函数。

# Vulkan Tutorial

## Index buffer

​	只能拥有一个index buffer，只能对索引整个顶点，不能对顶点属性单独索引，意味着即使两个顶点除了某一属性有区别外其他都一样，也必须使用两个顶点。

​	建议将index buffer和vertex buffer存储到一个buffer里，通过偏移量来区分它们，这样是cache友好的。

## Descriptor layout and buffer

​	现在，我们需要考虑三维空间了，首先需要MVP矩阵，`uniform`变量。Descriptor可以让着色器自由的访问缓冲区和图像等资源。首先创建一个缓冲区来保存MVP矩阵，然后让顶点着色器通过descriptor来访问这个缓冲区。Descriptor的用法包括三个部分：

- 在图形管线创建期间指定一个描述符（descriptor）
- 从描述符池（descriptor pool）中分配描述符集（descriptor set）
- 在渲染过程中绑定描述符集

​	*Descriptor layout* 指定了将要被图形管线访问的资源类型，就像渲染流程绑定的缓冲区附件；*descriptor set* 指定了绑定到descriptor上实际的缓冲区或图像，就像帧缓冲将image views绑定到渲染流程的附件上。

​	Descriptor有很多种类型，目前我们只关心uniform buffer object。
