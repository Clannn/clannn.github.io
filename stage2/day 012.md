# 游戏引擎架构

## 基于锁的并发存在的问题

### 死锁

​	死锁发生时，相关的线程都处于阻塞状态，等待某些资源可用。如下所示：

```c++
void Thread1(){
    g_mutexA.lock();    //holds A
    g_mutexB.lock();    //sleeps waiting for B
}
void Thread2(){
    g_mutexB.lock();    //holds B
    g_mutexA.lock();    //sleeps waiting for A
}
```

产生死锁的关键在于线程及其资源之间的循环依赖关系。产生死锁的充分条件是：

1. 互斥：单个线程对单个资源独占
2. 持有并等待：持有资源的情况下进入阻塞状态
3. 非抢占：任何线程都不允许抢占阻塞线程持有的资源
4. 循环等待：线程依赖关系中存在一个环

避免死锁聚焦于防止第$2$条和第$4$条条件成立。可以通过减少互斥锁的数量来避免持有并等待。比如：上述例子中由同一个互斥锁管理A、B两个资源。通过对系统中所有的`lock`操作施加一定的顺序，即可避免循环等待。比如：上述例子中线程必须先获得A才能再获得B。

​	死锁的另一种解决方案是：使用`try_lock`。此时线程不会进入阻塞状态，而是休眠一段时间后继续`try_lock()`。这同样会带来一个问题，可能会使线程将大量时间花在避免死锁上。比如：上述例子两个线程释放资源后休眠相同的时间。可以通过非对称死锁算法来解决这个问题。”饥饿“是指：一个或多个线程永远无法被执行。比如低优先级的线程。

​	互斥锁可能会导致优先级反转，比如低优先级的线程持有某资源，当高优先级的线程尝试持有相同资源时，会进入阻塞状态，此时，两个线程的优先级就被颠倒了。解决方法有：随机提升优先级，主动持有锁的线程将被随机提升优先级，直到它退出临界区。

​	关于并发程序的一些经验法则：

- 基于“事务”：要么不给，要么全给
- 最小化竞争：如果可以，虚拟分配资源
- 线程安全（一个类或函数可以同时被多个线程安全地调用）

### 线程安全

​	一般而言，**线程安全是指可以同时被多线程进程中的任意线程安全地调用**，对于函数而言，线程安全通常将整个函数体视为临界区，进入函数时进入一个临界区，返回之前退出临界区。**线程安全的函数不能在同一线程内互相调用**，因为它们独立地进入和退出同一个临界区，解决方法是使用可重入锁或者提供线程不安全地版本。**创建$100\%$线程安全的类或函数库是一个坏主意**，应该朝着无锁并发而努力。

## 无锁编程

​	无锁编程并不是指消除互斥锁，而是**防止线程在等待资源时进入阻塞状态**，即不允许线程阻塞。常用的无锁编程方法有：

- 无障碍：当系统中的所有线程突然暂停时，保证单个线程总是能完成它的工作。使用互斥锁或自旋锁的算法都不可能是无障碍的。
- 基于事务的“无锁”编程：可以避免死锁，但可能会导致饥饿。同样使用互斥锁或自旋锁的算法都不可能是“无锁”的。
- 无等待：在“无锁”的基础上，消除饥饿。

### 造成数据竞争BUG的原因

​	并发程序中的数据竞争BUG有以下产生原因：

- 一个关键操作被另一个关键操作中断
- 由编译器和CPU执行的指令重排优化
- <u>由于特定硬件的内存排序语义</u>：内存控制器内部的优化可能改变关键的读写顺序

# Vulkan Tutorial

## Graphics Pipeline

### Color blending

​		片段着色器返回颜色之后，需要与帧缓冲中已经存在的颜色相混合，有两种方式：

- 将新颜色与旧颜色混合，产生新颜色
- 使用位运算组合新旧颜色值

​	有两种类型的结构可以配置颜色混合，`VkPipelineColorBlendAttachmentState`描述一个帧缓冲的配置，用于将新旧颜色混合；`VkPipelineColorBlendStateCreateInfo`包含全局的颜色混合配置，用于位运算混合。定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkPipelineColorBlendAttachmentState {
	VkBool32                           blendEnable;
	VkBlendFactor                      srcColorBlendFactor;
	VkBlendFactor                      dstColorBlendFactor;
	VkBlendOp                          colorBlendOp;
	VkBlendFactor                      srcAlphaBlendFactor;
	VkBlendFactor                      dstAlphaBlendFactor;
	VkBlendOp                          alphaBlendOp;
	VkColorComponentFlags              colorWriteMask;
} VkPipelineColorBlendAttachmentState;

// Provided by VK_VERSION_1_0
typedef struct VkPipelineColorBlendStateCreateInfo {
    VkStructureType                               sType;
    const void*                                   pNext;
    VkPipelineColorBlendStateCreateFlags          flags;
    VkBool32                                      logicOpEnable;
    VkLogicOp                                     logicOp;
    uint32_t                                      attachmentCount;
    const VkPipelineColorBlendAttachmentState*    pAttachments;
    float                                         blendConstants[4];
} VkPipelineColorBlendStateCreateInfo;
//混合伪代码
if(blendEnable){
    finalColor.rgb = (srcColorBlendFactor * newColor.rgb) <colorBlendOp> (dstColorBlendFactor * oldColor.rgb);
    finalColor.a = (srcAlphaBlendFactor * newColor.a) <alphaBlendOp> (dstAlphaBlendFactor * oldColor.a);
}else{
    finalColor = newColor;
}
finalColor = finalColor & colorWriteMash;
```

​	当你将`logicOpEnable`设置为`True`时，所有的`blendEnable`会被强制设为`False`。该模式还是会将结果与`colorWriteMask`相与。`blendConstants`用于指定R、G、B、A四个通道的混合常数。

### Dynamic state

​	某些状态可以在不重建管线的情况下进行更改，比如视口大小、线宽和混合常数。但必须填充`VkPipelineDynamicStateCreateInfo`结构。如果要求某些值可以动态更改，那就必须在绘制时指定这些值的大小。

```c++
// Provided by VK_VERSION_1_0
typedef struct VkPipelineDynamicStateCreateInfo {
	VkStructureType                     sType;
	const void*                         pNext;
	VkPipelineDynamicStateCreateFlags   flags;
	uint32_t                            dynamicStateCount;
	const VkDynamicState*               pDynamicStates;
} VkPipelineDynamicStateCreateInfo;
```

### Pipeline layout

​	在着色器中可以使用`uniform`变量，这些变量可以在绘制过程中改变。`uniform`变量需要在管线创建的过程中通过创建`VkPipelineLayout`对象来指定。

```c++
// Provided by VK_VERSION_1_0
typedef struct VkPipelineLayoutCreateInfo {
	VkStructureType                 sType;
	const void*                     pNext;
	VkPipelineLayoutCreateFlags     flags;
	uint32_t                        setLayoutCount;
	const VkDescriptorSetLayout*    pSetLayouts;
	uint32_t                        pushConstantRangeCount;
	const VkPushConstantRange*      pPushConstantRanges;
} VkPipelineLayoutCreateInfo;
```

`pushConstant`是向着色器传递动态值的另一种方式。以后再说

### Render passes

​	创建管线时，还需要告诉Vulkan在呈现时将要用到的帧缓冲。我们需要指定有多少颜色和深度缓冲以及在整个渲染流程中应该如何处理缓冲区中的内容。注意在创建管线之前创建渲染流程。

​	目前，我们渲染一帧只需要一个颜色附件，由交换链中的图像表示。附件描述的定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkAttachmentDescription {
	VkAttachmentDescriptionFlags    flags;
	VkFormat                        format;
	VkSampleCountFlagBits           samples;
	VkAttachmentLoadOp              loadOp;
	VkAttachmentStoreOp             storeOp;
	VkAttachmentLoadOp              stencilLoadOp;
	VkAttachmentStoreOp             stencilStoreOp;
	VkImageLayout                   initialLayout;
	VkImageLayout                   finalLayout;
} VkAttachmentDescription;
```

`format`指定像素格式；`samples`指定单像素采样次数；`loadOp`和`storeOp`指定渲染前后对缓冲区中数据进行的操作，`loadOp`可以有以下值：

- `VK_ATTACHMENT_LOAD_OP_LOAD`：保持现有内容
- `VK_ATTACHMENT_LOAD_OP_CLEAR`：使用一个常量来清除覆盖现有内容
- `VK_ATTACHMENT_LOAD_OP_DONT_CARE`：不关心现有内容

`storeOp`可以有以下值：

- `VK_ATTACHMENT_STORE_OP_STORE`：渲染结果会被保存起来，以便之后读取
- `VK_ATTACHMENT_STORE_OP_DONT_CARE`：渲染结束后不会读取缓冲区中的内容

`loadOp`和`storeOp`会对颜色和深度缓冲区生效，`stencilLoadOp`和`stencilStoreOp`会对模板缓冲区生效。

​	Vulkan中的纹理和帧缓冲是由`VkImage`对象表示的，**`VkImage`对象的内存布局可以根据你的意图而改变**。常见的内存布局有：

- `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`：图像作为颜色缓冲
- `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`：图像被用在交换链中进行呈现操作
- `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`：图像被用作内存拷贝操作的目标
- `VK_IMAGE_LAYOUT_UNDEFINED`：不关心图像的内存布局

`initialLayout`用于指定渲染前的图像布局，`finalLayout`用于指定渲染后的图像布局。

​	一个渲染流程可以包含多个子流程，子流程依赖于上一流程处理后的帧缓冲中的内容。每个子流程可以引用一个或多个附件，这些引用是通过`VkAttachmentReference`结构指定的。

```c++
// Provided by VK_VERSION_1_0
typedef struct VkAttachmentReference {
	uint32_t           attachment;
	VkImageLayout      layout;
} VkAttachmentReference;
```

`attachment`用于指定要引用的附件在附件描述结构体数组中的索引，与片段着色器中的`layout(location = 0)`相对应；`layout`用于指定渲染子流程中附件的内存布局。

​	使用`VkSubpassDescription`结构体来描述子流程。

```c++
// Provided by VK_VERSION_1_2
typedef struct VkSubpassDescription2 {
	VkStructureType                   sType;
	const void*                       pNext;
	VkSubpassDescriptionFlags         flags;
	VkPipelineBindPoint               pipelineBindPoint;
	uint32_t                          viewMask;
	uint32_t                          inputAttachmentCount;
	const VkAttachmentReference2*     pInputAttachments;
	uint32_t                          colorAttachmentCount;
	const VkAttachmentReference2*     pColorAttachments;
	const VkAttachmentReference2*     pResolveAttachments;
	const VkAttachmentReference2*     pDepthStencilAttachment;
	uint32_t                          preserveAttachmentCount;
	const uint32_t*                   pPreserveAttachments;
} VkSubpassDescription2;
```

`pipelineBindPoint`用于指定子流程类型（计算、渲染、光追等）；`colorAttachment`用于指定颜色附件的引用；`inputAttachment`用于指定被着色器读取的附件；`ResolveAttachment`用于指定多重采样的颜色附件；`DepthStencilAttachment`用于指定深度和模板数据的附件；

​	现在可以创建完整的渲染流程，填充`VkRenderPassCreateInfo`结构体：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkRenderPassCreateInfo {
	VkStructureType                   sType;
	const void*                       pNext;
	VkRenderPassCreateFlags           flags;
	uint32_t                          attachmentCount;
	const VkAttachmentDescription*    pAttachments;
	uint32_t                          subpassCount;
	const VkSubpassDescription*       pSubpasses;
	uint32_t                          dependencyCount;
	const VkSubpassDependency*        pDependencies;
} VkRenderPassCreateInfo;
```

`dependency`指定子流程间的内存依赖。

### 管线总结

​	至此，我们已经定义好了所有创建管线所需的对象：**着色器阶段、固定管线阶段、管线布局、渲染流程**。可以开始填充`VkGraphicsPipelineCreateInfo`结构体。

```c++
// Provided by VK_VERSION_1_0
typedef struct VkGraphicsPipelineCreateInfo {
	VkStructureType                                 sType;
	const void*                                     pNext;
	VkPipelineCreateFlags                           flags;
	uint32_t                                        stageCount;
	const VkPipelineShaderStageCreateInfo*          pStages;
	const VkPipelineVertexInputStateCreateInfo*     pVertexInputState;
	const VkPipelineInputAssemblyStateCreateInfo*   pInputAssemblyState;
	const VkPipelineTessellationStateCreateInfo*    pTessellationState;
	const VkPipelineViewportStateCreateInfo*        pViewportState;
	const VkPipelineRasterizationStateCreateInfo*   pRasterizationState;
	const VkPipelineMultisampleStateCreateInfo*     pMultisampleState;
	const VkPipelineDepthStencilStateCreateInfo*    pDepthStencilState;
	const VkPipelineColorBlendStateCreateInfo*      pColorBlendState;
	const VkPipelineDynamicStateCreateInfo*         pDynamicState;
	VkPipelineLayout                                layout;
	VkRenderPass                                    renderPass;
	uint32_t                                        subpass;
	VkPipeline                                      basePipelineHandle;
	int32_t                                         basePipelineIndex;
} VkGraphicsPipelineCreateInfo;	
```

​	`subpass`用于指定图形管线使用的子流程在子流程数组中的索引。`basePipelineHandle`用于以一个创建好了的管线为基础创建一个新的管线。`basePipelineIndex`用于将该管线设置为基础管线并设置它的索引。这两个成员变量的设置只有在`VkGraphicsPipelineCreateInfo`结构体的`flags`成员变量使用了`VK_PIPELINE_CREATE_DERIVATIVE_BIT`标记的情况下才会起效。

# C++ Primer

## 模块（modules）概述

​	模块是一组源代码文件，它独立于导入它们的编译单元，被独立的编译。这样可以减少编译时间。模块中声明的宏、预处理指令和未导出的名称在模块外部是不可见的。不必考虑宏的重定义，可以以任意顺序导入模块。<u>编译单元中的声明不会干涉被导入模块的重载解析或名称查找</u>。模块被编译后，结果保存在一个二进制文件中，该文件描述了所有导出的类型、函数和模板。编译器可以更快地处理该二进制文件并且可以在任何导入模块的地方重用它。可以同时使用`#include`与`import`。某些情况下，也可以将头文件作为模块导入。

​	微软提供了将c++标准库作为模块导入的方式，标准库被拆分为以下模块：

- `std.regex`：提供头文件`<regex>`中的内容
- `std.filesystem`：提供头文件`<fliesystem>`中的内容
- `std.memory`：提供头文件`<memory>`中的内容
- `std.threading`：提供多线程相关的内容，包括`<atomic>`、`<condition_variable>`、`<future>`、`<mutex>`、`<shared_mutex>`和`<thread>`。
- `std.core`：提供标准库中所有其他内容

​	VS中模块接口文件的扩展名必须是`.ixx`，下面是一个示例：

```c++
// Example.ixx
export module Example;
#define ANSWER 42
namespace Example_NS
{
   int f_internal() {
        return ANSWER;
      }
   export int f() {
      return f_internal();
   }
}

// MyProgram.cpp
import Example;
import std.core;
using namespace std;
int main()
{
   cout << "The result of f() is " << Example_NS::f() << endl; // 42
   // int i = Example_NS::f_internal(); // C2039
   // int j = ANSWER; //C2065
}
```

​	只有被`export`修饰的声明才会被导出。如果`export`类或者名字空间，则其中所有内容都被导出。`export`关键字只能在接口文件中使用，实现文件可以导入其他模块，但不能导出任何东西。实现文件的扩展名没有要求。主模块可以有多个分区模块，这些分区模块需要先在主模块中声明。可以`import`头文件，与模块不同的是，`imoprt`头文件会使其中的宏定义生效。
