# Vulkan Tutorial

## 交换链

```c++
// Provided by VK_KHR_swapchain
typedef struct VkSwapchainCreateInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    VkSwapchainCreateFlagsKHR     flags;
    VkSurfaceKHR                  surface;
    uint32_t                      minImageCount;
    VkFormat                      imageFormat;
    VkColorSpaceKHR               imageColorSpace;
    VkExtent2D                    imageExtent;
    uint32_t                      imageArrayLayers;
    VkImageUsageFlags             imageUsage;
    VkSharingMode                 imageSharingMode;
    uint32_t                      queueFamilyIndexCount;
    const uint32_t*               pQueueFamilyIndices;
    VkSurfaceTransformFlagBitsKHR preTransform;
    VkCompositeAlphaFlagBitsKHR   compositeAlpha;
    VkPresentModeKHR              presentMode;
    VkBool32                      clipped;
    VkSwapchainKHR                oldSwapchain;
}VkSwapchainCreateInfoKHR;
```



### 创建交换链

​	`preTransform`字段可以指定某个变换应用到交换链中的每个图像上（比如：水平翻转、旋转$90\degree$），如果不需要任何变换，则指定为`capabilities.currentTransform`。

​	`compositeAlpha`字段指定alpha通道是否用于与其他应用的窗口混合，一般情况总是忽略这个混合，即指定为`VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR`。

​	`clipped`字段用于指定是否裁剪被其他窗口遮挡的像素，一般情况为`VK_TRUE`。

​	`oldSwapchain`字段指定旧交换链的引用。程序运行过程中，交换链可能会变为无效或者未优化状态，比如窗口大小被调整时。这种情况下需要指定旧交换链的引用。目前只创建一个交换链，所以该字段的值为空。

### 检索交换链中的图像

​	最后我们需要创建`VkImage`对象来检索交换链中的图像。这些图像是由交换链创建并清理的，我们只需要保存图像的句柄即可。因为在创建交换链的时候只指定了最小的图像数，因此实际创建出的交换链图象数是未知的，需要先获取图像数量。

## 图像视图（Image View）

```c++
// Provided by VK_VERSION_1_0
typedef struct VkImageViewCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkImageViewCreateFlags      flags;
    VkImage                     image;
    VkImageViewType             viewType;
    VkFormat                    format;
    VkComponentMapping          components;
    VkImageSubresourceRange     subresourceRange;
}VkImageViewCreateInfo;
```

​	为了在渲染管线中使用交换链中的`VkImage`，我们必须创建`VkImageView`对象。**`VkImageView`描述了如何解释和访问图像，例如：`VkImage`被视为用来表示深度的2D纹理**。当前，所有的`VkImage`都只作为颜色附件。

​	`viewType`和`format`用于指定如何解释图像数据，`viewType`允许你将图像视为1D、2D、3D纹理或者cube map。格式对应于创建`swapChain`时指定的图像格式。

​	`components`字段允许随意调整颜色通道的映射关系，比如可以把所有颜色通道都映射到同一个通道，或者把某个颜色通道的值设置为$0$或$1$。一般情况请保持默认映射。

​	<u>`subresourceRange`</u>字段描述了使用图像的目的（aspectMask）、mipmapping以及arraylayers。

​	记得在程序结束时显式销毁imagesViews。**一个图像视图将图像封装成了一个纹理，**还需要创建帧缓冲来将图像封装成渲染目标。在此之前，需要首先设置好渲染管线。

## 渲染管线简介

​	**渲染管线相当于一个操作序列，它将网格的顶点和纹理渲染到渲染目标的像素中。**下图是一个简化的管线模型：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221005204201463.png" alt="image-20221005204201463" style="zoom:67%;" />

​	**每个顶点会运行一次顶点着色器**，顶点着色器通常应用坐标变换将顶点位置从模型空间转换到标准坐标空间。曲面细分着色器根据特定的规则细分几何图形，通常用于在近距离看到更多的细节。**每个图元运行一次几何着色器**，可以丢弃图元或者输出更多的图元，由于性能原因，大多数应用都不用几何着色器。**光栅化将图元离散成片元，顶点着色器的属性将被插值到片元中**，任何屏幕之外的片元将被丢弃，由于深度测试，只有最前面的片元会被保留。**保留下来的每个片元运行一次片段着色器**，确定每个片元的颜色以及写入哪个帧缓冲。混合阶段，混合映射到帧缓冲中相同像素的不同片元，可以是覆盖、相加或混合。

​	绿色的阶段称为固定管线阶段，这些阶段只允许用参数调整它们的操作，具体工作方式是预定义的。橙色阶段称为可编程阶段，意味着可以将自己的代码上载到显卡。

​	**Vulkan中的图形管线在运行时几乎是不可改变的**，如果想更改管线配置，必须重新创建管线。一些可编程阶段是可选的（比如几何着色器），如果只对深度感兴趣，也可以禁用片段着色器。

​	具体定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkGraphicsPipelineCreateInfo {
    VkStructureType                                 sType;
	const void*                                     pNext;
	VkPipelineCreateFlags                           flags;
	uint32_t                                        stageCount;
	const VkPipelineShaderStageCreateInfo*          pStages;
	const VkPipelineVertexInputStateCreateInfo*     pVertexInputState;
	const VkPipelineInputAssemblyStateCreateInfo*   pInputAssemblyState;
	const VkPipelineTessellationStateCreateInfo*    pTessellationState;
	const VkPipelineViewportStateCreateInfo*        pViewportState;
	const VkPipelineRasterizationStateCreateInfo*   pRasterizationState;
	const VkPipelineMultisampleStateCreateInfo*     pMultisampleState;
	const VkPipelineDepthStencilStateCreateInfo*    pDepthStencilState;
	const VkPipelineColorBlendStateCreateInfo*      pColorBlendState;
	const VkPipelineDynamicStateCreateInfo*         pDynamicState;
	VkPipelineLayout                                layout;
	VkRenderPass                                    renderPass;
	uint32_t                                        subpass;
	VkPipeline                                      basePipelineHandle;
	int32_t                                         basePipelineIndex;
}VkGraphicsPipelineCreateInfo;
```



## 着色器模块

​	Vulkan的着色器代码必须以字节码格式指定，这种字节码称为"SPIR-V"。使用`glslc`命令将`GLSL`文件编译为对应的字节码。

### 顶点着色器

​	**顶点着色器将顶点属性作为输入，输出包括裁剪空间的位置坐标以及需要传递给片段着色器的属性**。裁剪坐标是齐次坐标，还需要转化到规范设备坐标（NDC）。如下图所示，Z坐标的范围是（0，1）。

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221005211433565.png" alt="image-20221005211433565" style="zoom:80%;" />

​	对于三角形示例程序，我们直接在顶点着色器中指定三个顶点在NDC下的坐标。

### 片段着色器

​	**必须为每个帧缓冲附件指定自己的输出变量，片段着色器中的`layout(location = 0)`指定帧缓冲附件的索引，即第一个附件**。

