# Game Engine Architecture

## Memory Management

### 内存碎片

​	动态堆内存分配的另一个问题是，内存会随着时间的推移变得碎片化。如下图所示：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221018105327854.png" alt="image-20221018105327854" style="zoom:50%;" />

内存碎片会导致一个很严重的问题：**即使有足够的空间，分配也可能失败**，因为分配的内存必须是连续的。在支持虚拟内存的操作系统上，不连续的内存碎片也可以映射到连续的虚拟地址。虽然现代游戏机大多支持虚拟内存，但由于其固有的性能开销，大多数游戏引擎仍不使用虚拟内存。

1. 使用栈分配和分配池来避免内存碎片

   栈分配显然不会产生内存碎片。对于分配池，因为所有内存块的大小都是相同的，所以即使会产生碎片，也不会过早出现内存不足的情况。

2. 内存碎片整理和重定向

   当确实需要以随机顺序分配和释放不同大小的对象时，可以通过定期对堆内存进行碎片整理来避免碎片。如下图所示：

   <img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221018110607882.png" alt="image-20221018110607882" style="zoom:67%;" />

   有一个很严重的问题是，**所有指向已分配的内存块的指针，在整理完毕后全都失效**。将指针调整到整理后的内存地址，这一过程叫指针重定向。但找到所有指向某地址的指针也是很困难的事情，一般通过智能指针或句柄来实现。句柄通常是一个不可重定向的数组，每个索引保存一个指针，每当分配的块在内存中移动时，就扫描数组并更新相关的指针。使用句柄的对象只保存索引值，不保存具体的地址。有些内存块无法重定向，比如第三方库中使用的指针，这种情况下只能将它们的内存分配在可重定向之外的内存区域。如果不可重定向的指针很少，影响也不是很大。

   碎片整理是一个非常缓慢的操作，因为它要拷贝内存。可以将碎片整理分摊到多个帧进行，比如允许每帧最多移动$N$个分配的块，只需要整理速度不小于分配和释放的速度。

## 字符串

​	运行时处理动态处理字符串是非常昂贵的操作。