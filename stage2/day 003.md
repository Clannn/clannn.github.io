# 游戏引擎架构

## 隐式并行

#### 分支预测

​	当遇到一个分支指令时，CPU猜测哪个分支会被执行，并且将这个分支的指令放入流水线。如果猜测错误，**管道必须被刷新（flushed）并且回退到正确分支的第一个指令处。**这称为分支处罚。

​	最简单的预测方式是不预测，CPU顺序执行指令，如果预测错误再回退。这种方式是I-cache友好的，CPU总是希望被预测的分支在缓存中。还有一种方式是总是采用向后（地址在后）的分支而不采用向前（地址在前）的分支。大多数CPU都有一个的分支预测硬件。

​	还有一种消除分支依赖的方式是**尽量不使用分支代码。使用条件语句生成一个二进制掩码，然后两个分支都执行相同的代码，并利用掩码生成不同的答案。**比如：

```c++
return (b!=0.f)?a/b:d;

const unsigned mask = 0U - (unsigned)(b!=0.f);
const float q = a/b;
return (q & mask) | (d & ~mask);
```

​	上述代码有一个bug，当执行位运算时(& | ~)，操作数会被转换为`unsigned`类型，c++中最好使用`union`来解决此问题。但是，**费这么大劲避开这么个小分支显然有点过头了。**

### 超标量CPU

​	标量CPU是指一个时钟周期只能启动一条指令，而超标量是指一个时钟周期可以启动两条指令。超标量CPU中有两个（或更多）的相同模块来管理每一个流水线阶段。在每个时钟周期，都会有两条指令被取指。超标量CPU执行指令的最优情况如下图：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220920110105746.png" alt="image-20220920110105746" style="zoom:80%;" />

​	除了数据和分支依赖，超标量CPU还容易产生第三种依赖：资源依赖。当两条（或更多）连续的指令都需要CPU中相同的功能组件时，就会产生资源依赖。假设某超标量CPU中仅有一个FPU，当遇到两条连续的浮点运算指令时，显然不能在一个时钟周期内同时启动它们。为了释放晶体管，超标量CPU一般是精简指令集处理器。

### 超长指令字

​	由于超标量CPU需要很复杂的指令分派逻辑，并且在分析依赖关系时也只能提前查看少量的指令流。这限制了CPU动态优化的有效性。实现指令级并行的一个更简单方式是，将分配计算单元（ALU、FPU、VPU）的任务交给程序员或编译器。这样就能消除CPU内复杂的指令分派逻辑。为了实现上述目标，指令字被扩展，每个指令都包含两个（或多个）“槽”，每个“槽”对应芯片上的一个计算单元。

​	假设CPU包含两个ALU和两个FPU，程序员或编译器就能在每个指令字中编码两个ALU和两个FPU的操作。这被称为超长指令字。

# 基于物理的建模与动画

## 群集系统

### 核心算法

​	假设有一只鸟$i$，位于$\mathbf{x}_i$，以速度$\mathbf{v}_i$飞行，与其相邻的鸟$j$，位于$\mathbf{x}_j$，速度为$\mathbf{v}_j$。从$i$到$j$的向量为$\mathbf{x}_{ij}=\mathbf{x}_j-\mathbf{x}_i$，从$i$到$j$的距离为$d_{ij}=||\mathbf{x}_{ij}||$，从$i$到$j$的方向向量为$\hat{\mathbf{x}}_{ij}=\mathbf{x}_{ij}/d_{ij}$。如下图所示：

![image-20220920133319978](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220920133319978.png)

​	由于$j$而产生的影响$i$的三个加速度分别为：

- **碰撞规避**：$\mathbf{a}_{ij}^a=-\frac{k_a}{d_{ij}}\hat{\mathbf{x}}_{ij}$，将$i$推离$j$
- **速度匹配**：$\mathbf{a}_{ij}^v=k_v(\mathbf{v}_j-\mathbf{v}_i)$，调整$i$的速度与$j$匹配
- **集中**：$\mathbf{a}_{ij}^c=k_c\mathbf{x}_{ij}$，将$i$拉向$j$

​	以上公式中的$k_a$、$k_v$、$k_c$均为控制加速度强度的、可调节的标量因子。三个标量首先初始化为较小的值，然后先调节$k_a$，再调节$k_v$，最后调节$k_c$。因为鸟$i$的加速度是由它自己决定的，所以不需要考虑牛顿第三定律了。碰撞规避最好设置一个上限值，以保证稳定性。

### 距离与视域

​	对象应把更多的注意力放在与其相邻的对象上。还应该给三种加速度划分优先级，将力量贡献在此时最重要的一项。比如快要碰撞时，完全没必要再考虑聚集。

​	有一种方法采用一个额外的关于距离的函数作为每项加速度的权重因子。设定两个阈值$r_1$、$r_2$，且$r_1<r_2$。假设$d$为两对象间的距离，那么权重因子定义为：
$$
k_d(d)=
\left\{
\begin{array}{l}
1.0 && d<r_1\\
\frac{r_2-d}{r2-r1} && r1\leq{d}\leq{r_2}\\
0.0 && d>r_2
\end{array}
\right.
$$
​	由$d=d_{ij}$计算得$k_d$，在各项加速度生效前与其相乘。

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220920141207399.png" alt="image-20220920141207399" style="zoom:80%;" />

​	一般动物地视域也是有限的，典型鸟类的视域如下图所示：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220920141832980.png" alt="image-20220920141832980" style="zoom: 67%;" />

​	可以参照常数$k_d$，我们也可以通过视域范围定义一个权重因子：
$$
k_d(d)=
\left\{
\begin{array}{l}
1.0 && |\theta|\leq{\theta_1/2}\\
\frac{\theta_2/2-|\theta|}{\theta_2/2-\theta_1/2} && \theta_1/2<|\theta|<\theta_2/2\\
0.0 && d\ge{\theta_2/2}
\end{array}
\right.
$$
​	其中$\theta$表示两个对象之间速度向量的夹角。

​	在统计对象的可互动列表时，应该只考虑距离小于$r_2$并且不在盲区的所有其他对象。最终的加速度计算如下：
$$
\mathbf{a}_i^a=\sum_jk_\theta(\theta_{ij})k_d(d_{ij})\mathbf{a}_{ij}^a\\
\mathbf{a}_i^v=\sum_jk_\theta(\theta_{ij})k_d(d_{ij})\mathbf{a}_{ij}^v\\
\mathbf{a}_i^c=\sum_jk_\theta(\theta_{ij})k_d(d_{ij})\mathbf{a}_{ij}^c
$$

​	关于加速度的优先级：碰撞规避拥有最高优先级，速度匹配其次，最后是集中。将对象所能产生的有限的力表示为一个加速度的上限，三个加速度按顺序累加，但最多不超过允许的加速度上限。

### 转向与侧飞

​	如果对象的加速度$\mathbf{a}$没有与它的速度$\mathbf{v}$对齐，那么对象不仅要改变它的速度，还要改变它的方向。方向的改变体现在速度向量绕一个轴发生旋转，**这个轴与对象的速度方向和加速度方向都垂直。**由此，定义一个朝向坐标系如下：
$$
\hat{\mathbf{u}}_x=\hat{\mathbf{v}}\\
\hat{\mathbf{u}}_y=\frac{\mathbf{v}\times\mathbf{a}}{||\mathbf{v}\times\mathbf{a}||}\\
\hat{\mathbf{u}}_z=\hat{\mathbf{u}}_x\times\hat{\mathbf{u}}_y
$$
​	则使对象与该坐标系对齐的旋转矩阵是：
$$
R=
\left[\begin{array}{l}
\hat{\mathbf{u}}_x & \hat{\mathbf{u}}_y & \hat{\mathbf{u}}_z
\end{array}\right]
$$
​	将加速度分解为平行于速度方向和垂直于速度方向：
$$
\mathbf{a}_v=(\mathbf{a}\cdot\hat{\mathbf{u}}_x)\hat{\mathbf{u}}_x\\
\mathbf{a}_T=\mathbf{a}-\mathbf{a}_v
$$
​	以飞机为例，计算侧飞的角度：

![image-20220920151915442](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220920151915442.png)

​	假设水平飞行的飞机要转向而产生上图所示的倾斜。总升力$\mathbf{L}$应该满足$\mathbf{L}\cdot\hat{\mathbf{u}}_y=-m\mathbf{g}\cdot\hat{\mathbf{u}}_y$，且$\mathbf{L}\cdot\hat{\mathbf{u}}_z=-m\mathbf{a}_T\cdot\hat{\mathbf{u}}_z$。由此可得：
$$
\phi=-arctan\frac{\mathbf{a}_T\cdot\hat{\mathbf{u}}_z}{\mathbf{g}\cdot\hat{\mathbf{u}}_y}
$$
​	水平飞行的假设很不合理，而且集群算法会忽略重力，上式中，分母总是负数，再将整个分母替换为常系数$k_\phi$。可得：
$$
\phi=arctank_\phi\mathbf{a}_T\cdot\hat{\mathbf{u}}_z
$$
​	最后，还要做平滑处理，通过计算一个滑动平均值$\phi_{avg}^{[n]}$，每个时间步长按如下方式更新：
$$
\phi_{avg}^{[n]}=(1-\alpha)\phi_{avg}^{[n-1]}+\alpha\phi
$$
​	其中，$\alpha(0<\alpha\leq1)$是一个平滑常数，可以调节这个值达到一个满意的平滑过渡。至此，要让对象在侧飞时旋转，我们只需要将对象在变换到世界坐标之前，先让其围绕自己的$x$轴旋转$\phi_{avg}^{[n]}$角度即可。