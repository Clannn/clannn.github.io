# 游戏引擎架构

## 操作系统基础

#### 进程的虚拟内存映射

**共享库**

​	程序链接静态库意味着：库中的所有机器码被拷贝到可执行文件中。链接共享库时，程序只包含库中API函数的引用，不拷贝所有机器码。当共享库中的内容第一次被进程使用时，**操作系统将库加载到物理内存中并映射到进程的虚拟地址空间**。共享库提供的函数和全局变量被填充到程序的机器码中。当第二个进程使用相同的共享库时，不再重新加载库，**直接做内存映射和填充机器码**。当更新共享库时，理论上所有使用该共享库的程序都不必重新编译链接。

**内核页面**

​	内存分为用户空间和内核空间两大块，用户空间通过每个进程唯一的虚拟页表映射；**内核空间使用独立的虚拟页面**，此页表在所有进程之间共享。当用户进程进行系统调用时，内核将执行*上下文切换*，内核在内核态代替用户程序运行代码，根据需要可更新用户程序内部数据，结束后返还控制权。

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220927102757443.png" alt="image-20220927102757443" style="zoom: 67%;" />

进程的内存映射如上图所示，每一块的具体大小都是无法预知的。

### 线程

​	线程是封装了单个机器语言指令流的运行实例。**线程提供了执行指令流所需的最小资源**，进程中的每个线程由以下内容组成：

- 线程ID（TID），进程中唯一，系统中可能不唯一
- 线程调用栈
- 所有寄存器的值
- 与每个线程相关联的通用内存块，称为线程本地存储(TLS)

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220927104735996.png" alt="image-20220927104735996" style="zoom:67%;" />

#### 线程库

​	不同的线程库都支持以下基本操作：

- 生成新线程的函数或构造函数
- 终止调用的线程
- 允许一个线程请求另一个线程退出
- 使当前线程休眠一段时间
- 使线程处于休眠状态，直到另一个线程终止（join）

#### 线程的创建与终止

​	进程的“主线程”可以调用操作系统API（`CreateThread()` on Windows）或者实例化一个线程类（`std::thread`）来生成新线程。**新线程从调用者提供的入口点函数开始执行**。线程可以通过多种方式终止：

- 线程自然执行结束
- 可以调用如`pthread_exit()`函数，在返回前显式的终止
- 可以被另一个外部线程“杀死”。线程回应“杀死”请求的优先级在线程创建时确定
- 进程结束时，所包含的线程都被强制结束

#### 轮询，阻塞和让步

​	有时正在运行的线程需要等待一些事件的发生，此时有三种选择：轮询，阻塞或让步。

**轮询**

​	轮询使线程在循环中不停询问事件是否发生`while (!CheckCondition())`。这种方法非常消耗CPU资源。

**阻塞**

​	使线程休眠，并依靠内核在未来某个时间点将其唤醒。线程通过调用阻塞函数（系统调用）自行阻塞。好多事件可以触发阻塞，例如：打开文件、显式休眠（`std::this_thread::sleep_until()`）、调用join、等待互斥锁。

**让步**

​	线程在循环中轮询条件，但每次迭代都显式的释放时间片（`while(!CheckCondition()){pthread_yield(nullptr);}`）。释放时间片的操作是系统调用，也比较昂贵，有些CPU提供轻量级的”暂停“（`_mm_pause()`），这些指令只是简单的等待CPU流水线清空。

#### 上下文切换

​	每个线程都处于三种状态之一：运行态、就绪态、阻塞态。当线程从一种状态转换到另一种状态时，就会在内核态发生上下文切换。线程状态转换图如下所示：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220927135547947.png" alt="image-20220927135547947" style="zoom:67%;" />

​	线程的执行上下文包括相关寄存器的内容以及一个调用栈。当一个线程从就绪或运行态切换到阻塞态时，寄存器中的内容会被保存到一块内存中，这块内存是内核为该线程预留的。**上下文切换时，不需要显式的保存或恢复线程的调用栈。**因为每个线程的调用栈已经保存在进程的虚拟内存中，只需要保存和恢复寄存器堆栈指针（SP和BP），就能”免费“保存和恢复线程的调用栈。

​	上下文切换时，如果两个线程位于不同的进程中，那实际发生的就是进程上下文切换，比进程内的线程切换昂贵许多。

# 基于物理的建模与动画

## 龙格-库塔（Runge-Kutta）积分

### 一阶和二阶龙格-库塔法

​	**假设有一个可以得到当前状态的导数的函数**，即$\dot{\mathbf{S}}=\mathbf{F}(\mathbf{S},t)$。在一阶的龙格-库塔积分中，假设初始状态为$s^{[0]}$，作如下迭代：

$$
\begin{align}
\mathbf{K}_1&=\mathbf{F}(\mathbf{S}^{[i]})\\
\mathbf{S}^{[i+1]}&=\mathbf{S}^{[i]}+h\mathbf{K}_1
\end{align}
$$
​	注意，$\mathbf{F}(\mathbf{S})=\dot{\mathbf{S}}$，所以一阶龙格-库拉就是欧拉积分。更高阶$RK$法的基础思想是：**用之前计算的导数估计后面的导数**。比如对于半步积分而言，我们需要知道$\mathbf{S}(t+0.5h)$，我们估计：$\mathbf{S}(t+0.5h)=\mathbf{S}(t)+0.5h\dot{\mathbf{S}}(t)$。因此，$RK2$写作：
$$
\begin{align}
\mathbf{K}_1 &= \mathbf{F}(\mathbf{S}^{[i]}) \\
\mathbf{K}_2 &= \mathbf{F}(\mathbf{S}^{[i]}+0.5h\mathbf{K}_1) \\
\mathbf{S}^{[i+1]} &= \mathbf{S}^{[i]}+h\mathbf{K}_2
\end{align}
$$


​	注意，**$RK2$需要计算两次导数$\mathbf{F}$**。$KR$法的阶数越高，需要的求导次数就越多，而求导又是最耗时的操作。$KR4$写作：
$$
\begin{align}
\mathbf{K}_1 &= \mathbf{F}(\mathbf{S}^{[i]}) \\
\mathbf{K}_2 &= \mathbf{F}(\mathbf{S}^{[i]}+0.5h\mathbf{K}_1) \\
\mathbf{K}_3 &= \mathbf{F}(\mathbf{S}^{[i]}+0.5h\mathbf{K}_2) \\
\mathbf{K}_4 &= \mathbf{F}(\mathbf{S}^{[i]}+h\mathbf{K}_3) \\
\mathbf{S}^{[i+1]} &= \mathbf{S}^{[i]}+\frac{h}{6}(\mathbf{K}_1+2\mathbf{K}_2+2\mathbf{K}_3+\mathbf{K}_4)
\end{align}
$$
<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220927151101330.png" alt="image-20220927151101330" style="zoom: 80%;" />

​	当我们尝试积分未知的模拟时，$RK4$是一个又好又“安全”的选择。

### 用高阶积分做碰撞检测

​	使用欧拉积分，粒子将做线性移动，使用高阶积分，如$KR4$，粒子将沿着多项式曲线移动，如图所示：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220927151125015.png" alt="image-20220927151125015"  />

​	可以很容易的计算射线与平面求交，计算曲线与平面求交会复杂很多。在使用$KR$积分法时，第一步要求出计算欧拉要用的导数，可以先用欧拉推进一个步长，检测并处理碰撞，如果没有碰撞，再用完整的$KR$法。但有时使用欧拉积分没有碰撞，而$KR$积分会产生碰撞。另一种方法是：总是使用高阶积分，使用二分步长的方法求曲线与平面的交点。这种方法处理碰撞非常费时。

## 积分的精度与稳定性

### 指数衰减和正弦振荡

​	描述指数衰减的微分方程写作：
$$
\dot{x}=-\frac{1}{T}x
$$
这个方程的解是：
$$
x(t)=x_0e^{-\frac{t}{T}}
$$
其中，$x_0$表示初始条件。表达式中的$T$称为时间常数，该常数决定了衰减的速度，$T$越大，衰减越慢。经过一个时间常数后函数值大约衰减$73\%$。如下图所示：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220927161423199.png" alt="image-20220927161423199" style="zoom:67%;" />

​	描述频率为$\omega$的正弦振荡的微分方程为：
$$
\ddot{x}=-\omega^2x
$$
周期$P$与频率的关系为：$\omega=2\pi/P$，所以上述方程也可以写成：
$$
\ddot{x}=-\left(\frac{2\pi}{P}\right)^2x
$$
方程的解是：
$$
x(t)=Ccos(\omega t-\phi)或x(t)=Ccos(2\pi\frac{t}{P}-\phi)
$$
其中，$C$是振幅，$\phi$是初始相位。若初始相位为0，函数如下图所示：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220927161738416.png" alt="image-20220927161738416" style="zoom:67%;" />

### 指数衰减的积分

​	指数衰减的系统动态函数是：
$$
f(x)=\dot{x}=-\frac{1}{T}x
$$
该函数的欧拉积分是：
$$
\begin{align}
x^{[n+1]}&=x^{[n]}+f(x)h \\
x^{[n+1]}&=x^{[n]}-\frac{1}{T}x^{[n]}h=\left(1-\frac{h}{T}\right)x^{[n]}
\end{align}
$$
如果这个迭代收敛，则必须有$\left|1-\frac{h}{T}\right|\leq1$，否则每一步迭代$x$都会变大，积分就会发散。一般结论是：**以指数衰减的欧拉积分要保持稳定，必须使$h\leq2T$**。

​	$RK2$的积分过程是：
$$
\begin{align}
k1 &= -\frac{1}{T}x^{[n]} \\
k2 &= -\frac{1}{T}\left(x^{[n]}-\frac{1}{T}x^{[n]}\frac{h}{2}\right) \\
x^{[n+1]} &= x^{[n]}-\frac{h}{T}x^{[n]}+\frac{h^2}{2T^2}x^{[n]}=\left( \frac{h^2}{2T^2}-\frac{h}{T}+1 \right)x^{[n]}
\end{align}
$$
同样，要想系统收敛，等式右边的系数必须小于$1$。一般结论与欧拉一样：$h\leq2T$。

​	对$RK4$做类似分析可得，积分稳定的条件是：$h<2.78T$。三者比较如下图：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220927163733950.png" alt="image-20220927163733950" style="zoom:80%;" />

### 正弦振荡的积分

1. 欧拉法对正弦振荡进行积分时，不管步长$h$多小都是不稳定的
2. $RK2$同样是不稳定的
3. 对于$RK4$，当$h<P/2.3$时算法达到稳定

​	一般使用$RK4$对正弦振荡积分，步长$h$小于最小正周期的$\frac{1}3$。

# C++ Primer

## 动态内存与智能指针

### 直接管理内存

​	直接管理内存的类不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。用`new`分配const对象是合法的，此时`new`返回的指针是一个指向const的指针。可以将nothrow传递给`new`（`new (nothrow) T`）表示它不能抛出异常。

​	`delete`一块并非`new`分配的内存，或者将相同的指针值`delete`多次，其行为是未定义的。因为编译器不能分辨指针指向的是动态还是静态分配的对象，也不能分辨指针指向的内存是否已经被释放。**动态对象的生命期直到被释放时为止**。所以，当一个指针离开其作用域时，它所指向的对象什么也不会发生。

​	直接管理内存存在三个常见问题：1. 忘记`delete`；2. 使用已经释放的内存；3. 同一块内存释放两次。即使`delete`之后重置指针值，也只能起到有限的保护，因为可能有多个指针指向同一块内存，而重置指针值只对当前指针有效。

### `shared_ptr`和`new`结合使用

​	可以用**`new`返回的指针**初始化智能指针，但接受指针参数的智能指针构造函数是explicit的。智能指针默认使用`delete`释放它所关联的对象。虽然但是，**不要混用普通指针和智能指针**。**使用`make_shared`而不是`new`初始化智能指针**，这样能在分配对象的同时将`shared_ptr`与之绑定，从而避免无意中将同一块内存绑定到多个独立的`shared_ptr`上，造成悬空指针。

​	智能指针定义了一个名为`get`的函数，返回一个内置指针，指向智能指针管理的对象。只有当我们需要向不使用智能指针的代码传递一个内置指针时，才使用`get`。并且**`get`返回的指针是不能`delete`的**。永远不要用`get`初始化另一个智能指针。

​	调用`process(shared_ptr<T>(p.get()))`会有什么问题？

​	当我们创建`shared_ptr`时，可以传递一个删除器函数，当`shared_ptr`管理的对象销毁时，就不会调用默认的`delete`而是调用我们传递进去的函数。`shared_ptr<T> p(new T(), delete_function);`

# Vulkan编程指南

## 交换链

### 交换链的支持细节

​	创建交换链之前需要先查询设备支持的交换链细节，有三种最基本的属性：

- 基础的表面特性`VkSurfaceCapabilities`（交换链的最小/最大图像数量，最小/最大图像宽度、高度）
- 表面格式`VkSurfaceFormatKHR`（像素格式，颜色空间）
- 可用的呈现模式`VkPresentModeKHR`

查询到相关信息后，扩展`isDeviceSuitable`函数检测设备支持的交换链特性是否满足需求。然后，我们为上述每种属性查找合适的设置。

​	每一个`VkSurfaceFormatKHR`条目包含了一个format和colorSpace成员变量。format成员变量用于指定颜色通道和存储类型。如果format的值为`VK_FORMAT_B8G8R8A8_SRGB`表示我们以B，G，R，A的顺序，每个颜色通道用8位无符号整型表示。colorSpace成员使用`VK_COLOR_SPACE_SRGB_NONLINEAR_KHR`标志来表示SRGB颜色空间是否被支持。

​	呈现模式决定了图像什么时候会被显示到屏幕上，Vulkan提供了四种呈现模式：

- `VK_PRESENT_MODE_IMMEDIATE_KHR`：应用程序提交的图像会被立即传输到屏幕上，可能会造成撕裂现象。
- `VK_PRESENT_MODE_FIFO_KHR`：交换链变成一个先进先出的队列，每次从队列头部取出一张图像进行显示，应用程序渲染的图像提交到队列尾部。当队满时，应用程序需要进行等待。这一模式非常类似于垂直同步。刷新显示的时刻被称为“垂直回扫”。
- `VK_PRESENT_MODE_FIFO_RELAXED_KHR`：这一模式与上一模式的唯一区别是，如果上一次垂直回扫时队列为空，那么图像会在提交到队列时立即被显示。这一模式也可能造成撕裂现象。
- `VK_PRESENT_MODE_MAILBOX_KHR`：这一模式是第二种模式的变种，它不会在队满时阻塞应用程序，队尾的图像会被直接替换为新渲染的图像。这一模式可以用来实现三倍缓冲。

​	上述四种模式中，只有`VK_PRESENT_MODE_FIFO_KHR`模式保证一定可用。