# Game Engine Architecture

## SIMD/Vector Processing

### 向量矩阵乘与SSE

​	我们需要将输入矩阵的**每一列**与输入向量执行点积。我们将一个$4\times4$的矩阵封装成$4$个SSE向量，同时，我们还希望能方便地访问矩阵的各个成员，因此，使用union来定义$Mat44$，具体如下：

```c++
union Mat44{
    float c[4][4];   //elements
    __m128 row[4];   //rows
};
```

向量与矩阵相乘的函数实现如下：

```c++
__m128 MulVecMat_sse(const __m128& v, const Mat44& M){
    __m128 vX = _mm_shuffle_ps(v, v, 0x00); // (vx,vx,vx,vx)
    __m128 vY = _mm_shuffle_ps(v, v, 0x55); // (vy,vy,vy,vy)
    __m128 vZ = _mm_shuffle_ps(v, v, 0xAA); // (vz,vz,vz,vz)
    __m128 vW = _mm_shuffle_ps(v, v, 0xFF); // (vw,vw,vw,vw)
    __m128 r = _mm_mul_ps(vX, M.row[0]);
    r = _mm_add_ps(r, _mm_mul_ps(vY, M.row[1]));
    r = _mm_add_ps(r, _mm_mul_ps(vZ, M.row[2]));
    r = _mm_add_ps(r, _mm_mul_ps(vW, M.row[3]));
    return r;
}
```

**可以用向量矩阵乘来实现矩阵矩阵乘以及矩阵向量乘**。现代编译器会自动将单通道的循环优化为矢量的形式。

### 向量预测

​	当遇到有条件分支的时候，编译器很难优化，但我们仍然可以手动向量化，例如，对大量浮点数求平方根，单通道循环实现如下：

```c++
void SqrtArray(float* r, const float* a, int count){
    for(int i=0;i<count;++i){
		if(a[i]>=0.0f) r[i] = std::sqrt(a[i]);
        else r[i] = 0.0f;
    }
}
```

​	`_mm_cmpge_ps(a, b)`函数比较两个`__m128`变量的四个分量，返回`__m128`表示四个分量的比较结果（全0或全1）。**我们可以利用该函数以及之前的掩码去掉分支的思路**，实现SSE版本，具体如下：

```c++
void SqrtArray_sse(float* r, const float* a, int count){
    __m128 vz = _mm_set1_ps(0.0f);       //all zeros
    for(int i=0;i<count;i+=4){
        __m128 va = _mm_load_ps(a + i);
        __m128 vq = _mm_sqrt_ps(va);     //可能存在NaN
        __m128 mask = _mm_cmpge_ps(va, vz);
        // (vq & mask) | (vz & ~mask)
        __m128 qmask = _mm_and_ps(mask, vq);
        __m128 znotmask = _mm_andnot_ps(mask, vz);
        __m128 vr = _mm_or_ps(qmask, znotmask);
        _mm_store_ps(r + i, vr);
    }
}
```

