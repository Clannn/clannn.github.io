# Game Engine Architecture

## Lock-Free Concurrency

### 内存排序语义

5. Memory Fences

   当两个内存指令的执行顺序被缓存一致性协议颠倒时，称为第一条指令（程序顺序）“穿过”了第二条指令。有四种类型：1. 读穿过读；2. 读穿过写；3. 写穿过写；4. 写穿过读。现代CPU提供被称为内存屏障的特殊指令来防止这些情况的发生。

   CPU提供四种单独的指令来防止上述四种情况，每种指令又可分为单向、反向、双向。单向意味着它之前的读/写指令不能“穿过”它，反向意味着它不能穿过它之后的读/写指令。内存屏障指令还提供两个附带效果：同时是编译屏障并且还能防止CPU跨过屏障“乱序”执行。

6. 获取和释放语义

   实际上，我们通常只考虑三种内存排序语义：

   - 释放语义：保证对共享内存的写操作永远不会被其他读写操作“穿过”。称为“写释放”。
   - 获取语义：保证对共享内存的读永远不会“穿过”其他读写操作。称为“读获取”。
   - 全屏障语义：同时作用于读和写的双向屏障。该操作比较昂贵。

7. 什么时候使用获取和释放语义

   当某线程执行两个连续的写入，并且需要确保所有其他线程将以正确的顺序看到这两个写入时，可以使用“写释放”指令。当某线程执行两个连续的读，并且第二个读以第一个读为条件时，我们需要保证第一个读不会穿过第二个读，使用“读获取”指令。下面是生产-消费的例子：

   ```c++
   int32_t g_data = 0;
   bool    g_ready = false;
   
   void Producer(){   //running on Core 1
       g_data = 42;
       RELEASE_FENCE(); //写释放
       g_ready = 1;
   }
   void Consumer(){    //running on Core 2
       while(!g_ready()) PAUSE();
       ACQUIRE_FENCE(); //读获取
       ASSERT(g_data == 42);
   }
   ```

### 原子变量

​	直接使用原子指令和内存屏障显然是比较繁琐的。c++11提供了模板类`std::atomic`，几乎支持将所有数据类型转换为原子变量。`std::atomic_flag`专门实现了原子布尔类型。`std::atomic`默认为其变量提供了全屏障。这样就无需担心数据竞争错误的任何一个原因。使用原子变量的生产-消费可以写成：

```c++
std::atomic<float> g_data;
std::atomic_flag g_ready = false;

void Producer(){   //running on Core 1
    g_data = 42;
    g_ready = 1;
}
void Consumer(){    //running on Core 2
    while(!g_ready()) PAUSE();
    ASSERT(g_data == 42);
}
```

可以调用`std::atomic::is_lock_free()`检查`atomic`变量是否真正无锁。

1. C++ Memory Order

   可以向`std::atomic`的`store`（写）和`load`（读）函数传递一个`std::memory_order_...`参数来降低该操作对内存屏障的要求（默认全屏障比较昂贵）。可选的内存等级有：

   - Relaxed：不使用任何屏障
   - Consume：设置重排屏障。但没有内存屏障。
   - Release：“写释放”
   - Acquire：“读获取”

   这些说明符只保证语义至少是这么强，在Intel x86上，Relaxed等同于Acquire。上述代码可改为：

   ```c++
   std::atomic<float> g_data;
   std::atomic<bool> g_ready = false;
   
   void Producer(){   //running on Core 1
       g_data.store(42, std::memory_order_relaxed);
       g_ready.store(true, std::memory_order_release);
   }
   void Consumer(){    //running on Core 2
       while (!g_ready.load(std::memory_order_acquire)) PAUSE();
       ASSERT(g_data.load(std::memory_order_relaxed) == 42);
   }
   ```

### 解释性编程语言的并发性

​	解释性语言的代码运行在虚拟机中，提供自己的“线程”概念，并由自己处理线程调度，因此可以提供强大的并发能力。比如在Java和C#中，`volatile`限定符保证变量的原子性。

### 自旋锁

1. 基础自旋锁

   在获取自旋锁时使用“读获取”语义，在释放自旋锁时使用“写释放”语义：

   ```c++
   class SpinLock{
       std::atomic_flag m_atomic;
   public:
       SpinLock(): m_atomic(false) {}
       bool TryAcquire(){
           bool alreadyLocked = m_atomic.test_and_set(std::memory_order_acquire);//读获取
           return !alreadyLocked;
       }
       void Acquire(){
           while(!TryAcquire()){
               _mm_pause();
           }
       }
       void Release(){
           m_atomic.clear(std::memory_order_release);//写释放
       }
   };
   ```

2. 作用域锁

   手动释放自旋锁非常不方便，就像手动释放内存一样。

   ```c++
   template<typename LOCK>
   class ScopedLock{
       using lock_t = LOCK;
       lock_t* m_pLock;
   public:
       explicit ScopedLock(lock_t& lock): m_pLock(&lock){
           m_pLock->Acquire();
       }
       ~ScopedLock(){
           m_pLock->Release();
       }
   };
   ```

# 基于物理的建模与动画

## 碰撞

### 碰撞的类型

​	对于有体积的三维物体，碰撞不再只是点与面的碰撞，并且两个相互碰撞的物体都应该有碰撞响应。三维物体的碰撞可以是一个物体的点、面、边分别与另一个物体的点、面、边相碰撞，一共$9$种组合。这$9$种组合可以分为两类：

- 泛型（genericity）：泛型类型表示即使两物体在碰撞点发生轻微的移动，也不会改变碰撞组合。包括：顶点-面、边-边、面-顶点
- 退化（degenerate）：退化类型表示两物体在碰撞点发生轻微移动，会改变他们的碰撞组合。

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221011141604860.png" alt="image-20221011141604860" style="zoom:80%;" />

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221011141925186.png" alt="image-20221011141925186" style="zoom:80%;" />

简单起见，我们只需要处理好泛型碰撞，退化碰撞可能包含泛型或者会退化为泛型。因此，我们只考虑点-面与边-边碰撞。

### 碰撞检测

**顶点-面检测**

​	顶点-面检测与确定碰撞的流程与之前没有任何区别。根据面的法线确定顶点是否穿过这个面，然后再判断点是否在**三角形**内。不同点在于，需要考虑物体的每个顶点与另一个物体的每个面。而且两个物体都会有碰撞响应。

**边-边检测**

​	假设有两条边分别为$\mathbf{p}_1\mathbf{p}_2$和$\mathbf{q}_1\mathbf{q}_2$，参数形式分别为：$\mathbf{p}_1+\left(\mathbf{p}_2-\mathbf{p}_1\right)s=\mathbf{p}_1+\mathbf{a}s$，$\mathbf{q}_1+\left(\mathbf{q}_2-\mathbf{q}_1\right)t=\mathbf{q}_1+\mathbf{b}t$。注意$s$与$t$的取值范围都是$\left(0,1\right)$。边-边检测需要找到分别离两条边最近的点，假设分别为$\mathbf{p}_a$，$\mathbf{q}_a$。如下图所示：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221011152042280.png" alt="image-20221011152042280" style="zoom:80%;" />

注意，**线段$\mathbf{p}_a\mathbf{q}_a$必须同时与两条边垂直，才有可能发生边-边碰撞**。因此线段$\mathbf{p}_a\mathbf{q}_a$的方向向量$\hat{\mathbf{n}}$为：
$$
\hat{\mathbf{n}}=\frac{\mathbf{a}\times\mathbf{b}}{||\mathbf{a}\times\mathbf{b}||}
$$
要计算$\mathbf{p}_a$、$\mathbf{q}_a$分别对应的$s$、$t$的值，先将$\mathbf{p}_1\mathbf{p}_2$投影到$\mathbf{q}_1\mathbf{q}_2$所在的，以$\hat{\mathbf{n}}$为法向量的平面上，计算$s$的值，如下图所示：

![image-20221011154315613](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221011154315613.png)

构造一个轴$\hat{\mathbf{z}}=\hat{\mathbf{b}}\times\hat{\mathbf{n}}$，计算$s$的值，即计算$\mathbf{p}_1\mathbf{p}_a$与$\mathbf{p}_1\mathbf{p}_2$长度的比值，**也是将它们投影到$\hat{\mathbf{z}}$轴后，投影长度的比值**，又因为$\mathbf{p}_1\mathbf{p}_a$投影到$\hat{\mathbf{z}}$轴的长度与$\mathbf{p}_1\mathbf{q}_1$投影到$\hat{\mathbf{z}}$轴的长度相同，最终$\mathbf{p}_a$对应的$s$的值为：
$$
s=\frac{\left(\mathbf{q}_1-\mathbf{p}_1\right)\cdot\left(\hat{\mathbf{b}}\times\hat{\mathbf{n}}\right)}{\mathbf{a}\cdot\left(\hat{\mathbf{b}}\times\hat{\mathbf{n}}\right)}
$$
同理，$\mathbf{q}_a$对应的$t$的值为：
$$
t=\frac{\left(\mathbf{p}_1-\mathbf{q}_1\right)\cdot\left(\hat{\mathbf{a}}\times\hat{\mathbf{n}}\right)}{\mathbf{b}\cdot\left(\hat{\mathbf{a}}\times\hat{\mathbf{n}}\right)}
$$
**如果求出的$s$和$t$超出了$(0,1)$的范围，则意味着两条边没有碰撞或者最近点在顶点**。检测碰撞时，计算向量$\mathbf{m}=\mathbf{q}_a-\mathbf{p}_a$，如果两个步时的$\mathbf{m}$满足：$\mathbf{m}^-\cdot\mathbf{m}^+<0$，则意味着发生了碰撞。

​	还有一种检测方法是：考虑一个由点$\mathbf{p}_1$和法向量$\hat{\mathbf{n}}$组成的平面，由于线段$\mathbf{q}_1\mathbf{q}_2$一定与$\hat{\mathbf{n}}$垂直，因此，发生了碰撞就意味着线段上一点（比如$\mathbf{q}_1$）由平面的一边移动到另一边，这意味着表达式$\left(\mathbf{q}_1-\mathbf{p}_1\right)\cdot\hat{\mathbf{n}}$的符号发生改变。注意，**此方法的两个步时必须用同一个$\hat{\mathbf{n}}$且法向量$\hat{\mathbf{n}}$不需要归一化**。
