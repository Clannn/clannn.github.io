# Game Engine Architecture

## Multiprocessor Game Loops

### Job Systems

2. A Simple Job System Based on a Thread Pool

   一个好方法是：为每个CPU核心都创建一个工作线程，并将线程与对应的核心绑定。每个工作线程都执行一个死循环来请求并执行工作。请求工作时，可能会使用互斥锁和条件变量来保证线程同步以及避免忙等待。具体定义可能如下所示：

   ```c++
   void JobWorkerThread(){
       while(true){
           Declaration declCopy;
           pthread_mutex_lock(&g_lock);
           while(!g_ready){
               pthread_cond_wait(&g_jobCv, &g_lock);
           }
           declCopy = GetNextJobFromQueue();
           pthread_mutex_unlock(&g_lock);
           declCopy.m_pEntryPoint(declCopy.m_param);
       }
   }
   ```

3. A Limitation of Thread-Based Jobs

   这个简单的工作系统有一个很严重的问题，**每个运行中的job与工作线程共享同一个调用栈**，这意味着，当运行中的job需要等待某事件发生时，我们不能休眠这个job转而执行其他job，因为休眠job等同于休眠工作线程。如果想要单独休眠job，我们需要保存job的调用栈以及参数值，然后改变工作线程的调用栈，这显然不是一个简单的问题。

4. Jobs as Coroutines

   可以将基于线程的job变成基于协程的job来解决这个问题，因为**协程可以主动让步给其他协程，并且当其他协程将控制权返还给它时，能从它停止的地方继续执行**。这样，当一个job中包含其他job时，我们可以将当前的线程让步给其他job，做到只休眠job而不休眠工作线程。

5. Jobs as Fibers

   Fiber与协程类似，不同的是，**Fiber可以从一个线程迁移到另一个线程**，这使得Fiber更符合工作系统的概念。

6. Job Counters

   虽然Fiber与协程为我们提供了等待另一个job结束的能力，但是，**不能很好的处理同时等待多个job的情况**。引入计数器以解决这个问题，当某个工作被kick时，用一个初始值为$0$的计数器与之绑定，每当这个工作kick一个新的工作时，计数器就加$1$，当计数器为$0$时才“唤醒”该工作。

7. Job Synchronization Primitives

   与许多线程库提供的线程同步原语类似，一个作业系统也必须提供作业同步原语。作业同步原语不能简单的套用线程同步原语，因为作业在工作线程内部运行，使用线程同步原语会反馈到工作线程上。比如当作业申请互斥锁不成功而被休眠时，工作线程也同样会被休眠。

   当线程间锁的竞争不是很激烈时，使用自旋锁可以较好的解决这个问题，当竞争激烈时，需要自定义“互斥”机制。

8. Job Visualization and Profiling Tools

   使用作业系统时，运行中的作业及其依赖关系会在短时间内变得非常复杂，需要一个可视化和分析工具。

# Foundations of Animation

## Rigid Body Motion

### Torque

​	**力引起线性动量的变化，力矩引起角动量的变化**，与力$\mathbf{F}=\dot{\mathbf{P}}$相同：
$$
\boldsymbol{\tau}=\dot{\mathbf{L}}
$$
假设某刚体质心位于$\mathbf{x}$，在$\mathbf{p}$点受到一个大小为$\mathbf{f}$的力，如下图所示：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221103161753186.png" alt="image-20221103161753186" style="zoom:80%;" />

**只要力不是作用在物体的质心位置，都会产生一个力矩**。为了计算力矩，首先要计算力臂：$\mathbf{r}=\mathbf{p}-\mathbf{x}$，然后：
$$
\boldsymbol{\tau}=\mathbf{r}\times\mathbf{f}
$$
显然，对于相同大小的力，力臂越长，力与力臂越垂直，得到的力矩就越大。**如果一个力均匀的施加在刚体上，也不会产生力矩**，比如重力和离心力。作用在同一刚体上的不同力矩可以通过矢量相加来组合。

### Updating Rigid Body State

​	现在，我们可以将刚体状态$\mathbf{S}$定义为：
$$
\mathbf{S}=\left[\begin{array}{l}
\mathbf{x} \\
R \\
\mathbf{P} \\
\mathbf{L}
\end{array}\right]
$$
状态的导数为：
$$
\dot{\mathbf{S}}=\left[\begin{array}{c}
\mathbf{v} \\
\omega^* R \\
\mathbf{F} \\
\boldsymbol{\tau}
\end{array}\right]
$$
注意：$\mathbf{v}=\frac{1}{m}\mathbf{P}$，$\boldsymbol{\omega}=I^{-1}\mathbf{L}$，即线速度和角速度可以从状态中获取。$\mathbf{F}$表示所有力的和，$\boldsymbol{\tau}$表示所有力矩的和。

### Quaternion Representation

​	目前为止，我们用旋转矩阵$R$来表示刚体的朝向，这种方式在积分过程中会遇到问题。比如，我们使用显示欧拉，只考虑朝向的积分：
$$
R^{[n+1]}=R^{[n]}+h\boldsymbol\omega^{*} R^{[n]}
$$
我们在旋转矩阵上加了一些东西，也就意味着$R$不再正交，也就不再是一个旋转矩阵。为了解决此问题，我们使用一个四元数$\mathbf{q}$来表示朝向，只需将计算后的四元数化为单位四元数即可。四元数$\mathbf{q}$的导数为：
$$
\dot{\mathbf{q}}=\frac{1}{2}\boldsymbol{\omega}\mathbf{q}
$$
其中，$\boldsymbol{\omega}=(0, \boldsymbol{\omega})$以计算四元数乘法。至此，状态与状态导数变为：
$$
\mathbf{S}=\left[\begin{array}{l}
\mathbf{x} \\
\mathbf{q} \\
\mathbf{P} \\
\mathbf{L}
\end{array}\right]&
\dot{\mathbf{S}}=\left[\begin{array}{c}
\mathbf{v} \\
\frac{1}{2}\boldsymbol{\omega}\mathbf{q} \\
\mathbf{F} \\
\boldsymbol{\tau}
\end{array}\right]
$$
​	假设作用在物体身上的“点”力为$\mathbf{f}$，均匀的力为$\mathbf{g}$，则状态导数的所有计算过程为：
$$
\begin{aligned}
\mathbf{v} &=\frac{1}{m} \mathbf{P}, \\
R &=R(\mathbf{q}), \\
I^{-1} &=R I_{0}^{-1} R^{T}, \\
\boldsymbol{\omega} &=I^{-1} \mathbf{L}, \\
\dot{\mathbf{q}} &= \frac{1}{2}\boldsymbol{\omega}\mathbf{q} \\
\mathbf{F} &=\sum_{i} \mathbf{g}_{i}+\sum_{j} \mathbf{f}_{j}, \\
\boldsymbol{\tau} &=\sum_{j}\left(\mathbf{r}_{j} \times \mathbf{f}_{j}\right) .
\end{aligned}
$$
