# Game Engine Architecture

## The Game Loop

​	一个游戏由许多交互的子系统组成，包括设备I/O，渲染，动画，碰撞检测与处理，刚体模拟，音效等待。大多数子系统都需要定期“维护”，比如动画需要至少$60$帧，物理需要$120$帧，AI需要$2$帧，**它们不需要与渲染循环进行同步**。

# Vulkan Tutorial

## Descriptor layout and buffer

​	在vertex shader中加入uniform变量，如下所示：

```glsl
layout(binding = 0) uniform UniformBufferObject{
    mat4 model;
    mat4 view;
    mat4 proj;
}ubo;
```

我们将会在descriptor layout中引用`binding`，着色器的`mat4`类型与`glm::mat4`类型是二进制兼容的，因此我们可以直接使用`memcpy`将`glm::mat4`的内容拷贝到`VkBuffer`中。我们需要提供shader中使用的每个descriptor binding的详细信息，就像描述每个顶点的顶点属性一样。**每个binding都需要通过`VkDescriptorSetLayoutBinding`描述**，具体定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkDescriptorSetLayoutBinding {
	uint32_t              binding;
	VkDescriptorType      descriptorType;
	uint32_t              descriptorCount;
	VkShaderStageFlags    stageFlags;
	const VkSampler*      pImmutableSamplers;
}VkDescriptorSetLayoutBinding;
```

`binding`与shader中的`layout(binding = 0)`对应，由于shader中的变量可能是一个数组，因此需要指定`descriptorCount`，`pImmutableSamplers`只跟图像采样有关。

​	所有的descriptor binding都要组合进一个`VkDescriptorSetLayout`对象中，`CreateInfo`定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkDescriptorSetLayoutCreateInfo {
	VkStructureType                        sType;
	const void*                            pNext;
	VkDescriptorSetLayoutCreateFlags       flags;
	uint32_t                               bindingCount;
	const VkDescriptorSetLayoutBinding*    pBindings;
} VkDescriptorSetLayoutCreateInfo;
```

只需要指定binding数量和数组即可。记得在创建图形管线的过程中指定着色器代码将要使用的`DescriptorSetLayout`。

​	现在，我们需要创建一个Buffer来保存UBO数据，这个Buffer每帧更新一次。由于我们同时渲染多帧，因此也应该同时有多个UBO buffer。