# Game Engine Architecture

## Foundations of Depth-Buffered Triangle Rasterization

### Describing a Scene

1. Triangle Meshes

   **Tessellation**

   镶嵌是指把表面分割为一组离散多边形（三角形）的过程。镶嵌程度是由美工决定的，通常中途不能改变。但理想情况下，我们希望按物体离相机的距离来增加或减少面片。通常以一系列不同密度的三角形网格来模拟这一过程，每个版本称为一个层次细节（LOD），LOD 0表示最密的三角网格。

2. Constructing a Triangle Mesh

   可通过任意两条边的叉积计算法向量，但要知道法向量的方向，需要定义哪一面是正面，可以用缠绕顺序来定义，缠绕循序分为顺时针和逆时针。当使用三角形带描述物体时，需要统一三角形带的缠绕顺序（how？）。

   为了在光栅化阶段保持三角形的完整性，顶点必须按照其位于三角形中的次序来处理，当顶点着色器处理每个顶点后，其结果会被缓存，当之后的图元使用了重复的顶点时，直接读取缓存中的内容即可。使用三角形带表示物体能很好的改善GPU的缓存一致性。

3. World Space and Mesh Instancing

   每个网格可以在场景中多次出现，每个这样的物体被称为网格实例。每个网格实例包含共享的网格数据以及一个独有的变换矩阵。

   **为了正确变换法向量，必须把法向量乘以变换矩阵的逆转置矩阵**，但如果变换矩阵（$3\times3$）是正交的，也可以直接乘。

   有些网格是完全静止且独一无二的，例如建筑、地形等，这些网格可以直接在世界空间表示。

### Describing the Visual Properties of a Surface

​	为了正确地渲染物体表面，我们需要描述表面的视觉属性，即光与表面交互的方式，比如：漫反射颜色、粗糙度/光滑度、反射率、纹理、透明度/不透明度、折射率等。

1. Introduction to Light and Color

   ***Light-Object Interactions***

   光的颜色是由其强度及波长决定的，一束光可能包含单一波长，也可能由多种波长混合而成。光只做$4$件事：

   - 光可被吸收
   - 光可被反射
   - 光可在物体中传播，过程中会被折射
   - 通过很窄的缺口时，光会被衍射

   通常，渲染引擎都只处理前三种行为。

   一个平面只会吸收某些波长的光，其他波长的光会被反射。光的反射可以是漫反射，即入射光往所有方向平均散射，也可以是镜面反射，即反射成很窄的锥形。反射可以是各向异性的，即不同角度观察表面时，光的反射有所不同。

   当光穿过物体时，光会被折射，不同波长的光有不同的折射角度。光可穿过半固体的表面，在表面下发生反射，再从另一个位置离开表面，这个现象称为次表面散射。比如：皮肤、蜡、大理石等会发生次表面散射。

   ***Color Spaces and Color Models***

   颜色模型是测量颜色的三维坐标系（比如：RGB），颜色空间是一个具体的标准，描述空间内的数值化颜色如何映射到真实世界的颜色（比如：sRGB）。

2. Vertex Attributes

   要描述表面的视觉特性，最简单的方法是把这些特性记录在表面的离散点上，称为顶点属性。顶点属性一般有：

   - 位置$\mathbf{p}$：位置通常以模型空间的坐标表示、
   - 法向量$\mathbf{n}$：计算光照必不可少的信息
   - 切向量$\mathbf{t}$：可以与法向量一起描述切线空间，此空间能计算多种逐像素光照，如：法线贴图、环境贴图等
   - 漫反射颜色$\mathbf{d}$：一般是四维向量，或者用一张纹理表示
   - 镜面反射颜色$\mathbf{s}$：也可以用纹理表示
   - 纹理坐标$\mathbf{u}_j$：二维向量，可以有多张纹理
   - 蒙皮权重$\mathbf{k}_j$：二维向量，可以受多个关节影响

   显然，顶点属性可以有任意数量，任意格式。通常引擎都会对顶点属性做出一定限制，比如最多$3$张纹理，最多$4$个关节权重。

3. Textures

   当逐个顶点表示表面性质过于粗糙时，可以使用纹理来表示某表面性质。比如：漫反射贴图、法相贴图、环境光贴图等。纹理的尺寸一般为$2$的幂，通常是$256\times256$、$512\times512$、$1024\times1024$等。**纹理可以存储任何在计算着色时需要的信息**。

   纹理空间：纹理的左下角为（$0,0$），右上角为（$1,1$）

   纹理坐标可以延伸至$[0,1]$范围之外，可以用以下几种方式处理范围之外的纹理坐标：

   - 缠绕模式：纹理在各个方向上不断重复
   - 镜像模式：纹理在各个方向上镜像重复
   - 截取模式：纹理的边缘纹素简单的延伸
   - 边缘颜色模式：手动设置范围$[0,1]$之外的纹理颜色

# Foundations of Animation

## Collisions of Rigid Bodies

### Frictionless Collision with a Static Object

​	假设已经能确定碰撞点$\mathbf{p}$，一个运动物体$a$与静态物体$b$发生碰撞，运动物体$a$位于$\mathbf{x}_a$、线速度$\mathbf{v}_a$、角速度$\boldsymbol{\omega}_a$，如下图所示：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221105153309087.png" alt="image-20221105153309087"  />

为了处理该碰撞，我们需要更新刚体的状态，实际只需要更新刚体的线动量与角动量（物体的位置与朝向未改变）。而刚体动量的改变实际上就是碰撞点处产生的冲量：
$$
\mathbf{J}=j \hat{\mathbf{n}}
$$
有：
$$
\begin{align}
\Delta \mathbf{P}&=\mathbf{J}\\
\Delta \mathbf{L}&=\mathbf{r}_{a} \times \mathbf{J}=j\left(\mathbf{r}_{a} \times \hat{\mathbf{n}}\right)
\end{align}
$$
因此我们只需要确定系数$j$即可，先将碰撞点$\mathbf{p}$写作：
$$
\mathbf{p}=\mathbf{p}_{a}=\mathbf{x}_{a}+\mathbf{r}_{a}
$$
则，发生碰撞后$\mathbf{p}$点的速度为：
$$
\dot{\mathbf{p}}_{a}=\mathbf{v}_{a}+\boldsymbol{\omega}_{a} \times \mathbf{r}_{a}
$$
只考虑法向量方向的速度变化，有：
$$
\mathbf{v}^{-}=\dot{\mathbf{p}}_{a} \cdot \hat{\mathbf{n}}
$$
$c_r$为恢复系数，则：
$$
\mathbf{v}^{+}=-c_r\mathbf{v}^{-}
$$
$\mathbf{v}^{+}$还可表示为$\mathbf{v}^{+}=\dot{\mathbf{p}}_{a}^{+} \cdot \hat{\mathbf{n}}$，而：
$$
\begin{aligned}
\dot{\mathbf{p}}_{a}^{+} &=\left(\mathbf{v}_{a}+\Delta \mathbf{v}_{a}\right)+\left(\boldsymbol{\omega}_{a}+\Delta \boldsymbol{\omega}_{a}\right) \times \mathbf{r}_{a} \\
&=\mathbf{v}_{a}+\boldsymbol{\omega}_{a} \times \mathbf{r}_{a}+\Delta \mathbf{v}_{a}+\Delta \boldsymbol{\omega}_{a} \times \mathbf{r}_{a} \\
&=\dot{\mathbf{p}}_{a}+\Delta \mathbf{v}_{a}+\Delta \boldsymbol{\omega}_{a} \times \mathbf{r}_{a}
\end{aligned}
$$
其中：
$$
\begin{align}
\Delta\mathbf{v}_{a}&=\frac{1}{m} \Delta \mathbf{P}=\frac{1}{m} j \hat{\mathbf{n}} \\
\Delta \boldsymbol{\omega}_{a}&=I^{-1} \Delta \mathbf{L}=j I^{-1}\left(\mathbf{r}_{a} \times \hat{\mathbf{n}}\right)
\end{align}
$$
综上，$\dot{\mathbf{p}}_{a}^{+}$可写作：
$$
\dot{\mathbf{p}}_{a}^{+}=\dot{\mathbf{p}}_{a}+j\left(\frac{1}{m} \hat{\mathbf{n}}+I^{-1}\left(\mathbf{r}_{a} \times \hat{\mathbf{n}}\right) \times \mathbf{r}_{a}\right) .
$$
将$\mathbf{v}^{+}=\dot{\mathbf{p}}_{a}^{+} \cdot \hat{\mathbf{n}}$与$\mathbf{v}^{-}=\dot{\mathbf{p}}_{a} \cdot \hat{\mathbf{n}}$带入上式有：
$$
\begin{align}
\mathbf{v}^{+}&=\mathbf{v}^{-}+j\left[\frac{1}{m}+\hat{\mathbf{n}} \cdot\left(I^{-1}\left(\mathbf{r}_{a} \times \hat{\mathbf{n}}\right) \times \mathbf{r}_{a}\right)\right] \\
-c_{r} \mathbf{v}^{-}-\mathbf{v}^{-}&=j\left[\frac{1}{m}+\hat{\mathbf{n}} \cdot\left(I^{-1}\left(\mathbf{r}_{a} \times \hat{\mathbf{n}}\right) \times \mathbf{r}_{a}\right)\right] \\
j&=\frac{-\left(1+c_{r}\right) \mathbf{v}^{-}}{\frac{1}{m}+\hat{\mathbf{n}} \cdot\left(I^{-1}\left(\mathbf{r}_{a} \times \hat{\mathbf{n}}\right) \times \mathbf{r}_{a}\right)}
\end{align}
$$
至此，我们只要计算出$j$，即可对刚体做碰撞处理。

### Frictionless Collision of Two Moving Objects

![image-20221105162406491](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221105162406491.png)

​	对于两个移动的物体，实际上我们还是只需要计算碰撞产生的冲量，若物体$a$受到的冲量为：$\mathbf{J}_a=j \hat{\mathbf{n}}$，则物体$b$受到的冲量为：$\mathbf{J}_b=-j \hat{\mathbf{n}}$。

​	以物体$b$作为参考，假设法向量从$b$指向$a$，则物体$a$相对于物体$b$在法线方向的速度为：
$$
\mathbf{v}_{r e l}^{-}=\hat{\mathbf{n}} \cdot\left(\dot{\mathbf{p}}_{a}-\dot{\mathbf{p}}_{b}\right)
$$
其中$\dot{\mathbf{p}}_{a}$、$\dot{\mathbf{p}}_{b}$的计算方式与上节相同，$j$的计算方式也与上节相同，为：
$$
j=\frac{-\left(1+c_{r}\right) \mathbf{v}_{r e l}^{-}}{\frac{1}{m_{a}}+\frac{1}{m_{b}}+\hat{\mathbf{n}} \cdot\left(I_{a}^{-1}\left(\mathbf{r}_{a} \times \hat{\mathbf{n}}\right) \times \mathbf{r}_{a}+I_{b}^{-1}\left(\mathbf{r}_{b} \times \hat{\mathbf{n}}\right) \times \mathbf{r}_{b}\right)} .
$$
最后：
$$
\begin{aligned}
\Delta \mathbf{P}_{a} &=j \hat{\mathbf{n}} & \Delta \mathbf{L}_{a} &=j\left(\mathbf{r}_{a} \times \hat{\mathbf{n}}\right) \\
\Delta \mathbf{P}_{b} &=-j \hat{\mathbf{n}} & \Delta \mathbf{L}_{b} &=-j\left(\mathbf{r}_{b} \times \hat{\mathbf{n}}\right)
\end{aligned}
$$

## Collision Detection

​	碰撞检测分为粗略检测和精确检测两大类。粗略检测是为了检测空间中明显不会发生碰撞的物体，精确检测会精确判断是否发生碰撞，并求出碰撞点。如下图：

![image-20221105172524621](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221105172524621.png)

### Bounding Volumes

​	包围体的核心思想是：若物体未与包围体发生碰撞，则不可能与包围体内的任何物体发生碰撞。常见的包围体有：

- **包围球**：用球心$(x,y,z)$与半径$r$表示，球心一般选择质心，半径为各顶点到球心的最大距离。

  优点：包围球与物体的方向无关，随着物体的运动，只需要更新包围球的球心即可。判断球与球的碰撞非常快

  缺点：包围球的体积通常比其包围的物体要大很多，可能导致更多的误报

- **AABB**：轴对齐包围盒是平行于世界坐标轴的包围体，可以用$6$个数来表示$(x_{min},x_{max},y_{min},y_{max},z_{min},z_{max})$。

  计算：遍历所有顶点即可，判断AABB之间的碰撞时，若三个坐标轴方向都有重叠，则发生了碰撞。

  优点：AABB计算快速

  缺点：物体方向改变后，通常需要重新计算AABB，对于自由移动的物体，意味着每帧重新计算整个AABB

# C++ Primer

- 静态类型在编译时就是已知的，它是变量声明时的类型或表达式生成的类型。动态类型则是变量或表达式表示在内存中的对象模型。
- 基类的指针或引用的静态类型可能与其动态类型不一致。
- 即使一个基类指针绑定到一个派生类对象上，也不能执行基类向派生类的类型转换，因为编译器只能检查静态类型。
- 如果我们已知从一个类型转换到另一个类型是安全的，则可以使用`static_cast`
- 用派生类对象初始化或赋值一个基类对象时，由于拷贝/赋值函数接受一个基类对象的引用，实际会将派生类传递过去，但基类的拷贝/赋值函数只能处理基类自己的成员变量
- 必须为每一个虚函数都提供定义，不管它是否被用到，因为**虚函数的调用可能在运行时才被解析**，编译器也无法确定到底会使用哪个虚函数
- 当虚函数的返回类型是类本身的指针或引用时，派生类中对应的虚函数返回类型可以是派生类的指针或引用。只不过这样的返回类型要求派生类到基类的类型转换是可访问的
- 只有虚函数才能被覆盖
- 可以把某个虚函数指定为`final`，表示不允许被派生于此类的类所覆盖
- 如果虚函数使用默认实参，则基类和派生类中定义的默认实参值最好一致
- 如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使运行的是派生类中的函数版本
- 有时我们希望对虚函数的调用不要进行动态绑定，强制执行基类的虚函数版本，可以通过作用域描述符实现`base->Base::func()`
- 通常情况下，只有成员函数或友元函数才需要避免虚函数的动态绑定

