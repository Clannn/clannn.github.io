# Game Engine Architecture

## 引擎配置

​	引擎的可配置选项一般实现为全局变量或单例类中的成员变量，最常见的是将选项置于一个或多个文本文件中，比如`ini`文件或`XML`文件，`ini`文件由键值对构成，这些键值对可以以逻辑段分组。

​	其他实现读/写可配置选项的方法有：

- 压缩的二进制文件：一般用于记忆卡
- Windows注册表：注册表以树状形式存储，每个非叶子节点称为注册表项，作用如文件夹，叶子节点以键值对存储个别选项。任何程序都可预留整个子树（注册表项）供该软件使用，在子树下存储任意选项集合
- 命令行选项：扫描命令行获取选项
- 环境变量
- 线上用户设定文档（user profile）

### 用户个人选项

​	每个玩家只能“看见”自己的选项，不会遇见同一主机上其他玩家的选项。Windows下，每位用户在C:\Users中有各自的文件夹，其中有一个名为APPData的隐藏文件夹，用来存储应用程序的用户个人选项。

## 文件系统

​	游戏引擎的文件系统通常需要以下几个功能：

- 操作文件名和路径
- 开、关、读、写单独的文件
- 扫描目录下的内容
- 处理异步文件I/O请求（串流）

基本文件I/O见c++20高级编程13章

### 异步文件I/O

​	串流是指在后台载入数据，实质是使用另一个线程进行文件I/O。主线程调用异步函数时，会把请求放入一个队列，并立即返回，同时I/O线程从队列中取出请求，以阻塞I/O函数来处理这些请求。异步I/O通常有不同的优先级。

# 无约束刚体动力学

## 模拟基础

​	总结一下，我们模拟粒子的方法是：令函数$\mathbf{x}(t)$表示粒子在$t$时刻的位置（粒子所在空间），函数$\mathbf{v}(t)=\dot{x}(t)=\frac{d}{dt}\mathbf{x}(t)$表示粒子在$t$时刻的速度。粒子在$t$时刻的状态$\mathbf{X}(t)$由位置和速度共同决定，写作：
$$
\mathbf{X}(t)=\left( \begin{matrix} \mathbf{x}(t) \\ \mathbf{v}(t) \end{matrix} \right)
$$
​	将$n$个粒子的状态写在一起，称为状态向量。为了模拟粒子的运动，我们还需要知道$t$时刻粒子所受的力，函数$\mathbf{F}(t)$表示$t$时刻施加在粒子上的合外力，假设粒子质量为$m$，则有：
$$
\dot{\mathbf{X}}(t)=\frac{d}{dt}\mathbf{X}(t)=\frac{d}{dt}\left( \begin{matrix} \mathbf{x}(t) \\ \mathbf{v}(t) \end{matrix} \right)=\left( \begin{matrix} \mathbf{v}(t) \\ \mathbf{F}(t)/m \end{matrix} \right)
$$
​	刚体模拟的思路与粒子相同，只是刚体在$t$时刻的状态应该包含更多信息，导数也要相应复杂一些。

## 刚体概念

### 位置和朝向

​	粒子在$t$时刻的位置可以描述为一个向量$\mathbf{x}(t)$，它描述了粒子相对于原点的平移量。刚体除了平移之外，还可以被旋转。为了在空间中定位刚体，首先使用向量$\mathbf{x}(t)$来描述物体的平移，除此之外，还必须描述物体的“朝向”。目前，使用一个$3\times3$的矩阵$R(t)$表示。将$\mathbf{x}(t)$和$R(t)$一起称为刚体的空间变量。

​	由于刚体本身占据一定空间的体积，且具有特定不变的形状。因此我们在一个固定不变的空间中定义刚体的形状，这个空间称为模型空间。为了数学推导的方便，物体的质心位于模型空间的原点。如果规定$R(t)$表示的是绕过质心的某个轴的旋转，那么在模型空间中刚体上任意一点$\mathbf{p}_0$，在世界空间中$t$时刻的位置是：
$$
\mathbf{p}(t)=R(t)\mathbf{p}_0+\mathbf{x}(t)
$$
<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221020143327996.png" alt="image-20221020143327996" style="zoom:67%;" />

​	由于物体的质心在原点，世界空间中物体的质心位置就在$\mathbf{x}(t)$。也就是说，**$\mathbf{x}(t)$表示刚体质心在世界空间中$t$时刻的位置**。同理，$R(t)$则表示对模型空间的$\mathbf{x}$、$\mathbf{y}$、$\mathbf{z}$轴分别做旋转。如果我们将$R(t)$写作：
$$
R(t)=\left( \begin{matrix}
r_{xx} & r_{yx} & r_{zx} \\
r_{xy} & r_{yy} & r_{zy} \\
r_{xz} & r_{yz} & r_{zz} \\
\end{matrix}\right)
$$
则$R(t)$的第一、二、三列分别表示在$t$时刻，刚体的$\mathbf{x}$、$\mathbf{y}$、$\mathbf{z}$轴在世界空间中指向的方向。

### 线速度

​	下一步，我们需要定义$\mathbf{x}(t)$与$R(t)$如何随时间变换，即需要求$\dot{\mathbf{x}}(t)$与$\dot{R}(t)$。由于$\mathbf{x}(t)$表示刚体质心在世界空间中$t$时刻的位置，则$\dot{\mathbf{x}}(t)$表示刚体质心在世界空间中$t$时刻的速度，即：
$$
\mathbf{v}(t)=\dot{\mathbf{x}}(t)
$$
刚体质心的速度，也就相当于刚体的线速度。

### 角速度

​	由于我们将模型空间的原点固定为刚体的质心，那么刚体上每一点的运动都必须是围绕过质心的某个轴自转，否则，刚体的质心将会发生改变。将这个自转描述为角速度$\mathbf{\omega}(t)$，$\mathbf{\omega}(t)$的方向也就是旋转轴的方向，$\mathbf{\omega}(t)$的模$||\mathbf{\omega}(t)||$表示旋转速度（弧度/秒）。

​	我们知道$\mathbf{v}(t)=\dot{\mathbf{x}}(t)$，那么$R(t)$与$\mathbf{\omega}(t)$之间是否存在相似的关系呢？我们知道$R(t)$表示$t$时刻，刚体的$\mathbf{x}$、$\mathbf{y}$、$\mathbf{z}$轴在世界空间中指向的方向，那么$\dot{R}(t)$就应该表示刚体的$\mathbf{x}$、$\mathbf{y}$、$\mathbf{z}$轴在世界空间中随时间的变换率。

​	考虑一个世界空间中随时间变化的向量$\mathbf{r}(t)$，它固定在刚体上，即刚体的平移与$\mathbf{r}(t)$独立，$\dot{\mathbf{r}}(t)$与$\mathbf{v}(t)$无关。为了获取$\dot{\mathbf{r}}(t)$，我们将$\mathbf{r}(t)$分解为平行于$\mathbf{\omega}(t)$的向量$\mathbf{a}$和垂直于$\mathbf{\omega}(t)$的向量$\mathbf{b}$，$\mathbf{r}(t)$在$\mathbf{\omega}(t)$的作用下，绕半径$\mathbf{b}$作圆周运动，因此：
$$
\dot{\mathbf{r}}(t)=\mathbf{\omega}(t)\times\mathbf{b}=\mathbf{\omega}(t)\times\mathbf{r}(t)
$$
将之应用于刚体的$\mathbf{x}$、$\mathbf{y}$、$\mathbf{z}$轴，则有：
$$
\dot{R}(t)=\left( \begin{matrix}
\mathbf{\omega}(t)\times\left( \begin{matrix}r_{xx} \\ r_{xy} \\ r_{xz}\end{matrix}\right) &
\mathbf{\omega}(t)\times\left( \begin{matrix}r_{yx} \\ r_{yy} \\ r_{yz}\end{matrix}\right) &
\mathbf{\omega}(t)\times\left( \begin{matrix}r_{zx} \\ r_{zy} \\ r_{zz}\end{matrix}\right)
\end{matrix}\right)
$$

# C++ Primer

- 所有的输入流都有一个关联的来源，所有的输出流都有一个关联的目的地
- 缓冲流和未缓冲流的区别是缓冲流不会立即将数据发送到目的地
- 缓冲的目的是为了提高性能，可以使用`flush()`方法刷新缓冲输出流的缓冲区
- 流不仅包含普通数据，还包含一个称为“当前位置”的特殊数据，当前位置是指流下一次要进行读写的位置
- 可以调用标准库的`make_move_iterator`函数将一个普通迭代器转换为一个移动迭代器
- 移动迭代器的解引用返回一个右值引用
- 只有确定不会再使用到对象时，才能使用`std::move`或移动迭代器
- 成员函数也可以同时提供拷贝版本（`const T&`）和移动版本（`T&&`），比如`push_back`
- 在成员函数的参数列表后放置一个引用限定符`&`，可以强制要求只有左值属性的`this`对象才能调用该函数，同理，在参数列表后放置`&&`则要求只有右值属性的`this`对象才能调用该函数
- 引用限定符必须同时出现在函数的声明和定义中，如果同时使用引用限定符和`const`，则引用限定符必须在`const`之后
- 引用限定符和`const`一样，可以区分重载
- 重载`=`、`[]`、`()`、`->`运算，必须作为成员函数
- 改变对象状态的运算符（自增/减、解引用等）应该是成员函数
- 具有对称性的运算符（算数、关系等）应该是非成员函数