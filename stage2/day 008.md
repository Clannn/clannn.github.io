# 游戏引擎架构

## 并发编程

### 竞争条件（Race Conditions）

​	存在竞争条件的情况下，当整个系统中发生的事件的相对顺序发生变化时，程序的结果可能会发生变化。有时，虽然程序的行为可能会根据时间而有所改变，但不会造成不良影响。另一方面，关键竞争（critical race）是一种可能会导致不正确程序行为的竞争条件。由关键竞争引起的错误通常有：1. 看似随机的bug或崩溃；2. 不正确的结果；3. 数据损坏；4. 切换到debug build时，bug消失了；5. 时有时无的bug；6. log调试时，bug消失了

#### 数据竞争

​	两个或多个控制流在读写共享数据时相互干扰，导致数据损坏。**数据竞争是并发编程的核心问题**。对于下述代码：

```c++
int g_count = 0;

inline void IncrementCount()
{
    ++g_count;
}
```

假设编译出的汇编代码如下：
```assembly
mov eax, [g_count]
inc eax
mov [g_count], eax
```

​	现在考虑两个线程A和B分别调用一次`IncrementCount`，A线程先调用，执行第一个`mov`之后切换到B线程，B线程执行完之后再返回到A线程，最终结果如下图：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220929113218072.png" alt="image-20220929113218072" style="zoom:67%;" />

​	在并行CPU上运行这两个线程更容易出错，如下图所示：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220929113509172.png" alt="image-20220929113509172" style="zoom:67%;" />

### 关键操作和原子性

​	关键操作是指**任何可能读取或改变特定共享对象的操作**。为了保证共享对象不发生数据竞争错误，我们必须确保它的任何关键操作都不能互相中断，当关键操作不可被中断时，他被称为原子操作。任何一个操作都可以分解为两个瞬时事件：调用（开始时刻）和响应（结束时刻）。对于任何包含关键操作的代码片段，它被调用和响应划分为三个部分：

- *Preamble*部分：关键操作之前的代码
- 临界区：关键操作本身的代码
- *Postamble*部分：关键操作之后的代码

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220929133538420.png" alt="image-20220929133538420" style="zoom:67%;" />

​	**如果关键操作的调用和响应没有被同一对象的另一个关键操作中断，则可以说该关键操作是原子执行的**。这里的中断还包括：多个关键操作在多个内核上重叠时。**只有同一个共享对象的两个关键操作互相中断时，才会发生数据竞争错误**。

​	将关键操作变为原子操作最简单可靠的方式是利用**互斥锁**。对特定共享数据对象的两个关键操作，通过获取互斥锁来保护两个操作的调用，并在每个操作“响应”时释放互斥锁。**操作系统保证一个互斥锁只能被一个线程获取**，所以我们可以确定一个操作的调用或响应永远不会发生在另一个操作的调用和响应之间。

## 线程同步原语

​	每个支持并发的操作系统都提供了一套称为线程同步原语的工具。这些工具提供了两种服务：

1. 使关键操作原子化
2. 同步多个线程
   1. 当线程等待资源或等待其他线程完成任务时，使其进入阻塞态
   2. 正在运行的线程负责唤醒一个或多个阻塞态的线程

需要注意的是，线程同步原语通常十分昂贵，因为这些工具是内核提供的，与它们中的任何一个交互都需要进行内核上下文切换（1000个时钟周期）。因此，应该尽量提供自己的同步工具或者使用无锁编程。

### 互斥锁

​	互斥锁是一个操作系统对象，用于将关键操作变成原子操作。互斥锁有两种状态：解锁（*unlocked*）和锁定（*locked*）。互斥锁由常规的c++对象或内核对象的句柄组成，通常由以下函数构成：

- `create()`或`init()`：创建互斥锁的函数或构造函数
- `destroy()`：销毁互斥锁的函数或析构函数
- `lock()`或`acquire()`：表示互斥锁被调用线程锁定（*locked*），如果互斥锁已经被锁定，则是调用线程进入阻塞态
- `try_lock()`或`try_acquire()`：尝试锁定互斥锁，如果无法锁定则立即返回
- `unlock()`或`release()`：对互斥锁进行解锁（unlocked），只有锁定互斥锁的线程才被允许解锁它

​	c++11通过`std::mutex`公开内核互斥锁，可以通过如下方式使用它：

```c++
#include <mutex>

int g_count = 0;
std::mutex g_mutex;

inline void IncrementCount()
{
    g_mutex.lock();
    ++g_count();
    g_mutex.unlock();
}
```

# 基于物理的建模与动画

## 数值积分

#### 隐式欧拉的精度和稳定性

​	隐式欧拉的稳定性优于显式积分方法。对于正弦振荡和指数衰减函数，隐式欧拉都是无条件稳定的。

指数衰减$f(x)=-\frac{1}{T}x$：
$$
\begin{align}
x^{[n+1]}&=x^{[n]}+f(x^{[n+1]})h \\
x^{[n+1]}&=x^{[n]}-\frac{1}{T}x^{[n+1]}h \\
\left(1+\frac{h}{T}\right)x^{[n+1]}&=x^{[n]} \\
\frac{x^{[n+1]}}{x^{[n]}}&=\frac{1}{1+\frac{h}{T}}
\end{align}
$$
正弦振荡$f(\mathbf{s})=\left[\begin{matrix}v\\-\omega^2x\end{matrix}\right]$：
$$
\begin{align}
\left[\begin{matrix}x^{[n+1]}\\v^{[n+1]}\end{matrix}\right]&=\left[\begin{matrix}x^{[n]}\\v^{[n]}\end{matrix}\right]+\left[\begin{matrix}v^{[n+1]}\\-\omega^2x^{[n+1]}\end{matrix}\right]h\\
\left[\begin{matrix}x^{[n+1]}\\v^{[n+1]}\end{matrix}\right]&=\left[\begin{matrix}x^{[n]}\\v^{[n]}\end{matrix}\right]+\left[\begin{matrix}0&1\\-\omega^2&0\end{matrix}\right]\left[\begin{matrix}x^{[n+1]}\\v^{[n+1]}\end{matrix}\right]h \\
\mathbf{s}^{[n+1]}&=\mathbf{s}^{[n]}+\left[\begin{matrix}0&h\\-\omega^2h&0\end{matrix}\right]\mathbf{s}^{[n+1]} \\
\left[\begin{matrix}1&-h\\\omega^2h&1\end{matrix}\right]\mathbf{s}^{[n+1]}&=\mathbf{s}^{[n]} \\
\mathbf{s}^{[n+1]}&=M^{-1}\mathbf{s}^{[n]}
\end{align}
$$
$M^{-1}$的行列式为$\frac{1}{1+\omega^2h^2}$。

​	两种函数状态之比都小于1，故一定是收敛的，但隐式欧拉的精度没有任何提升。**隐式欧拉可以保证积分的稳定性，但积分步骤复杂很多，每一步都要求解线性方程组**。

## 可形变弹性网格

### 阻尼弹性连接件

​	采用一种称为风门闭门器的器件作为模型的连接件，风门闭门器如下图所示：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220929151418224.png" alt="image-20220929151418224" style="zoom:80%;" />

​	下图是简化后的一维模型，弹簧连接着质量为$m$的物体和一面不可移动的墙。阻尼器与弹簧平行，同样连接着物体和墙。弹簧的强度常数为$k$，对物体施加反方向的力，大小与弹簧相对于平衡位置的距离成正比。阻尼器的阻尼常数为$d$，对物体施加的力只取决于物体的速度。

![image-20220929151928918](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220929151928918.png)

假设平衡状态时，物体位置$x=0$。可得任一时刻弹簧施加的力为：$f_k=-kx$；阻尼器施加的力为：$f_d=-dv$。如果物体被外力$f_e$推拉，则根据牛顿第二定律有：
$$
m\ddot{x}=f_e+f_k+f_d=f_e-kx-d\dot{x}
$$
通常写作：
$$
m\ddot{x}+d\dot{x}+kx=f_e
$$
当外力$f_e=0$时，我们得到方程的齐次形式：$m\ddot{x}+d\dot{x}+kx=0$。

**无物体质量的弹簧-阻尼**

​	若令物体质量$m=0$可得：$\dot{x}=-\frac{k}{d}x$，就是指数衰减的形式，解为：$x(t)=x_0e^{-\frac{k}dt}$，其中时间常数$T=\frac{d}{k}$。**时间常数是一个比值**。

![image-20220929154143022](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220929154143022.png)

**无弹簧弹性的物体-阻尼**

​	若令弹簧的刚度$k=0$，可得：$\ddot{x}=-\frac{d}{m}\dot{x}$，重写为速度的表达式：$\dot{v}=-\frac{d}mv$，也是指数衰减的形式，时间常数$T=\frac{m}d$。两边积分可得：$x(t)=x_0+v_0\frac{m}d\left(1-e^{-\frac{d}{m}t}\right)$。

![image-20220929154700366](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220929154700366.png)

**无阻尼的弹簧-物体**

​	若令阻尼常数$d=0$，可得：$\ddot{x}=-\frac{k}mx$，是正弦振荡的形式，解为：$x(t)=Ccos(\sqrt{k/mt}+\phi)$，振幅$C$和相位$\phi$由初始位置$x_0$和速度$v_0$决定，关系如下：$\phi=-arctan\left(\sqrt{\frac{m}k}\frac{v_0}{x_0}\right)$；$C=\sqrt{x_0^2+\frac{m}kv_0^2}$。同时，振荡的频率和周期分别为：$\omega=\sqrt{k/m}$；$P=2\pi\sqrt{m/k}$。

![image-20220929155506608](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220929155506608.png)

**弹簧-物体-阻尼**

​	由上述分析可知，物体的运动应表现为某种正弦振荡的形式，且随时间呈指数衰减。下面给出求解过程：两边除以质量$m$：
$$
\ddot{x}+d/m\dot{x}+k/m=0 \tag{1}
$$
定义无阻尼的自然频率及其周期：
$$
\omega_n=\sqrt{k/m}且P_n=2\pi\sqrt{m/k} \tag{2}
$$
定义阻尼因子：
$$
\zeta=\frac{d}{2\sqrt{km}} \tag{3}
$$
将$(2)$、$(3)$带入$(1)$中有：
$$
\ddot{x}+2\zeta\omega_n\dot{x}+\omega_n^2=0
$$
其解为：
$$
x(t)=Ce^{-\zeta\omega_nt}cos(\omega_n\sqrt{1-\zeta^2t}+\phi)
$$
其中，$\zeta$的范围为$[0,1]$。对于大多数弹簧阻尼问题普遍适用。这个解由两部分的乘积组成，一个是指数衰减，其时间常数为：
$$
T=\frac{1}{\zeta\omega_n}=\frac{2m}d
$$
另一个是正弦振荡，其频率为：
$$
\omega=\omega_n\sqrt{1-\zeta^2}=\sqrt{k/m-\left(d/2m\right)^2}
$$
当阻尼因子很高时，时间常数会很小，振荡很快停止，频率也会变低。当阻尼因子很低时，时间常数大，振荡持续时间长，频率增大。需要注意的是，如果阻尼因子大于$1$，方程的解将不再有效。

# C++ Primer

### Allocator类

​	`new`有一个局限性，**它将内存分配和对象构造组合在了一起**。类似的，`delete`将对象析构和内存释放组合在了一起。当分配一个大块内存时，通常希望将内存分配和对象构造分离。先分配内存，在需要的时候再执行对象创建。**`new`还有一个很严重的问题，没有默认构造函数的类就不能动态分配数组了**。可以通过以下方式使用`Allocator`类：

```c++
#include <memory>

std::allocator<T> alloc;
using traits_t = std::allocator_traits<decltype(alloc)>;
T* p = traits_t::allocate(alloc, n);
for(int i=0;i<n;i++){
    traits_t::construct(alloc, P+i, _Args);
}
// ......................
for(int i=0;i<n;i++){
    traits_t::destroy(alloc, p+i);
}
traits_t::deallocate(alloc, p, n);
```

​	`std::allocator_traits::deallocate(alloc, p, n)`释放从`p`开始的内存，`p`一定是先前由`std::allocator_traits::allocate(alloc, n)`返回的指针，且`n`必须是`p`创建时要求的大小。调用`deallocate`之前，用户必须对每个再这块内存中创建的对象调用`std::allocator_traits::destory`。

​	`std::allocator_traits::construct(alloc, p, args)`用来构造对象，`args`被传递给类型为`T`的构造函数，用来在`p`指向的内存中构造一个对象。使用只分配而未构造的内存，结果是未定义的。

​	`std::allocator_traits::destory(alloc, p)`用来析构对象，对`p`指向的对象执行析构函数。

​	可以用`uninitialized_copy`将元素拷贝到未初始化的内存中，用`uninitialized_fill`填充未初始化的内存。

### 拷贝构造函数

​	**定义类对象时，建议显式定义对象的拷贝、移动、赋值、析构相关的函数**。

​	与默认构造函数不同，只要我们没有定义拷贝构造函数，编译器就会为我们生成一个。合成的拷贝构造函数从给定对象中依次将每个非static成员拷贝到正在创建的对象中。对于类类型的成员，会使用其构造函数来拷贝。对于数组类型的成员，会逐元素进行拷贝。拷贝构造函数通常不应该是`explicit`的。有四种情况会发生拷贝初始化：

1. 用等号（=）定义变量时
2. 将实参对象传递给非引用的形参时
3. 从一个返回类型为非引用类型的函数返回时
4. 用花括号列表初始化时

情况2表明，**拷贝构造函数的参数必须是引用类型，因为拷贝构造函数会用来初始化非引用类型的形参**。编译器可能跳过拷贝构造函数，直接创建对象。编译器可能将`string a = "hello";`改为`string a("hello");`。虽然编译器跳过了，但还是要求拷贝构造函数必须存在。

# Vulkan编程指南

## 交换链

​	对于四种呈现模式，因为只有`FIFO`是保证一定可用的，所以我们还需要查找最佳的可用呈现模式。一般来说，三缓冲模式（`MAILBOX`）表现最好，但在移动设备上，由于资源不够，建议使用`FIFO`模式。

### 交换范围

​	还需要选择最后一个属性：交换范围。交换范围是指交换链中图像的分辨率，它几乎完全等于正在绘制的窗口的分辨率。分辨率范围在`VkSurfaceCapabilitiesKHR`结构中定义。Vulkan通过`currentExtent`成员变量来告知与当前窗口匹配的交换范围。一些窗口系统会使用一个特殊值（`max uint32`）来表示允许我们自己选择交换范围（`minImageExtent`与`maxImageExtent`之间）。GLFW使用屏幕坐标表示窗口尺寸，而Vulkan使用像素表示窗口尺寸。如果使用高DPI或者较高像素密度的显示器，二者可能不匹配。创建窗口时指定的`WIDTH`和`HEIGHT`是在屏幕坐标中测量的。我们需要使用`glfwGetFramebufferSize`来查询以像素为单位的窗口大小。

### 创建交换链

​	现在，可以在创建逻辑设备之后创建交换链。指定交换链绑定到的表面之后，除了需要指定交换链的表面格式、呈现模式以及范围之外，还需要指定交换链中的图像数量、`imageArrayLayers`和`imageUsage`。`capabilities.maxImageCount=0`意味着不限制最大数量，否则，设置的数量应该在`min`与`max`之间。 `imageArrayLayers`表示图像的层次，除非是VR应用，否则该值始终为$1$。`imageUsage`用于指定我们将使用交换链中的图像进行哪种操作。因为将直接渲染它们，这意味着它们被作为**颜色附件**（color attachment）。如果希望渲染出的图像还要做后处理等操作。可以使用`TRANSFER_DST`之类的值，在之后使用内存操作将渲染出的图象转移为交换链图像。

​	此外，如果交换链中的图像会被多个队列族所使用，那么还需要指定如何处理这种情况。有两种方式：

- `VK_SHARING_MODE_EXCLUSIVE`：一个图像被一个队列族独占，另一个队列使用它之前，必须显式地转移其所有权。<u>该选项提供了最佳性能</u>
- `VK_SHARING_MODE_CONCURRENT`：并发式，图像可以跨多个队列族使用，无需显式转移所有权
