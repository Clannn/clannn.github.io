# Game Engine Architecture

## Lock-Free Concurrency

### Implementing Atomicity

- **通过关中断实现原子性**：在执行操作之前关中断，确保操作完成后重新开中断。但这种方法只适用于单核CPU，因为开关中断只对当前核心有效。

- **原子指令**：CPU保证有些指令天然具有原子性，不可被中断。有些CPU还可以通过在汇编语言的指令上指定一个前缀，将指令强制原子化。

- **原子读写**：在大多数CPU上，我们可以确定对四字节对齐的$32$为整数的读写操作具有原子性。因为读写一个对齐的整数（宽度小于等于寄存器）可以在一个时钟周期内执行，<u>CPU使用离散时钟以“锁步”执行其操作，因此内存访问不可被中断，即使是另一个内核也不行</u>。未对齐的对象通常需要两次对齐的内存访问，因此可能被中断。

- **原子读-改-写（RMW）**：只有原子读写还不够，我们需要能够从内存中读取变量，然后修改，再写回内存。这三个步骤都不能被中断。现在CPU都支持至少一条原子RMW指令，主要有以下几种类型：

  - **Test and Set**：该原子指令的伪代码如下所示

    ```c++
    bool TAS(bool* pLock){
    	const bool old = *pLock;
        *pLock = true;
        return old;
    }
    ```

    可以利用TAS实现自旋锁，如下所示（无内存保护）：

    ```c++
    void SpinLockTAS(bool* pLock){
    	while(TAS(pLock) == true) _mm_pause();
    }
    ```

  - **Exchange**：原子交换指令用于交换两个寄存器的值或者寄存器与内存某位置的值。同样可以利用原子交换指令实现自旋锁，如下所示（无内存保护）：

    ```c++
    void SpinLockXCHG(bool *pLock){
        bool old = true;
        while(true){
    		_InterlockedExchange8(old, pLock); //8bit exchange
            if(!old) break;
            _mm_pause();
        }
    }
    ```

    在Visual Studio中，所有以`_interlocked`为前缀的函数都是编译器的内在特性，它们只是将对应的汇编指令嵌入代码中。Windows SDK提供了一组没有下划线的同名函数，但它们的成本会高很多，因为涉及内核调用。

  - **Compare and Swap**：这个原子指令检查内存中的现有值，当且仅当现有值与程序员提供的期望值相匹配时，原子地将新值写入内存。伪代码如下所示：

    ```c++
    bool CAS(int* pValue, int expectedValue, int newValue){
        if(*pValue == expectedValue){
            *pValue = newValue;
            return true;
        }
        return false;
    }
    ```

  - **ABA problem**：一般运行CAS指令前，会先读取内存的值。如果读取到内存值为A，然后被其他线程抢占，对该内存改为B，然后改为A。当CAS指令最终执行时，它会认为没有发生数据竞争。

  - **Load Linked/Store Conditional**：有些CPU将CAS指令分解为加载链接（LL）和存储条件（SC）指令。LL指令原子地读取内存地址的值，并将值<u>地址</u>在链接寄存器中。SC指令将一个值写入给定地址，但只有当地址与链接寄存器中的地址匹配时才写入。返回是否写入成功。**总线上的任何写操作都会将链接寄存器的值置为0**。LL与SC指令更加流水线友好

  - **Strong and Weak Compare-Exchange**：c++11提供了原子比较交换的可移植函数，由于存储条件指令可能出现错误，c++11提供了强和弱两种比较交换。

### Barriers

​	中断并不是数据竞争BUG产生的唯一原因，编译器和CPU的指令重排也会在并发程序中引入BUG。因为编译器和CPU的优化只保证对单个线程没有影响。

# 基于物理的建模与动画

## 可变弹性网格

### 空气阻力与风

​	跟单个粒子不同，弹性网格受到的空气阻力横跨每个多边形面，不仅仅作用在粒子上。考虑一面由弹性网格构成的旗子，如果风力仅作用于顶点粒子，那么粒子就只会沿着风的方向被推动，不会产生旗子摆动的效果。实际上，旗子的每个多边形面都应该被看成一个小翅膀，施加作用在多边形上的升力和拖拽力。这些力会随着面与风的朝向而变化，并且有一个垂直于风向的分量。

​	假设所有多边形都是三角形，$\mathbf{w}$为局部空气速度向量，$\mathbf{v}$为三角形的速度，则三角形中心穿过空气的相对速度为：$\mathbf{v}_r=\mathbf{v}-\mathbf{w}$。下图展示了升力$\mathbf{f}_l$与拖拽力$\mathbf{f}_d$与$\mathbf{v}_r$之间的关系：

![image-20221009141414514](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221009141414514.png)

**升力与拖拽力的大小与多边形穿过空气时的相对速度的平方成正比，同时也与三角形的有效面积$A_e$成正比**。三角形的有效面积是其法向量和相对速度夹角的余弦乘以实际面积$A$，即：
$$
A_e=A(\hat{\mathbf{n}}\cdot\hat{\mathbf{v}}_r)
$$
因此，升力和拖拽力可被表示为：
$$
\begin{align}
\mathbf{f}_d&=-C_dA\left(\hat{\mathbf{n}}\cdot\mathbf{v}_r\right)\mathbf{v}_r \\
\mathbf{f}_l&=-C_lA\left(\hat{\mathbf{n}}\cdot\mathbf{v}_r\right)\left(\mathbf{v}_r\times\frac{\hat{\mathbf{n}}\times\mathbf{v}_r}{\left|\left|\hat{\mathbf{n}}\times\mathbf{v}_r\right|\right|}\right)
\end{align}
$$

计算好三角形的受力之后，还需要将力传播到顶点上。一种简单的方式是**将力按各顶点对应角度的比例分配**。

​	弹性网格中每个粒子的加速度计算过程如下：

1. 遍历每个粒子，计算所有作用在粒子上的外力，如空气阻力，摩擦力，重力等
2. 遍历每个支撑杆，将支撑杆的弹力与阻尼力加到与其相连的粒子上
3. 遍历每个三角面，将作用在该面上的升力和拖拽力分配到面的顶点粒子上
4. 遍历每个粒子，计算每个粒子的加速度

### 结构刚度

​	如果只是将物体的每条边都替换成支撑杆，可能无法保持物体原本的形状。比如，如果把一个立方体的每条边都换成支撑杆，顶点变成质点，那么立方体会因为重力作用最终摊平在地面上，同时每根支撑杆也能保持原本的长度。可以通过添加支撑杆的方式增加物体的结构稳定性，如下图所示：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221009145715261.png" alt="image-20221009145715261" style="zoom: 80%;" />

​	**确保结构稳定性的另一种方法是，使用弹性四面体**。四面体具有维持其形状的特性。因此，**如果一个几何体能表示为若干四面体的集合，那么它就能成为一个弹性物体。**

## 扭转弹簧

​	还有一种保持结构稳定性的思路：**物体表面任意两个共边的多边形，如果其对应邻接面的夹角不变，那么弹性物体的结构稳定性就可以被保证**。一种方法是：在所有邻接面之间引入扭转弹簧，当两个邻接的三角形面绕公共边旋转时，扭转弹簧会施加一个力矩，试图将三角形之间的夹角扭转回平衡角度。若$\theta_0$是平衡角度，$\theta$是当前夹角，则力矩$\mathbf{\tau}$的模长为：
$$
||\mathbf{\tau}||=k_\theta|\theta-\theta_0|
$$
<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221009151437790.png" alt="image-20221009151437790" style="zoom:80%;" />

### 力矩

​	力矩之于旋转运动如同力之于平移运动。力矩产生角加速度，改变物体绕某中心旋转的速度。力矩是矢量，力矩的方向与旋转轴的方向相同，与旋转平面垂直。只有垂直于旋转半径的力$\mathbf{f}$才会产生力矩，并且产生的力矩与$\mathbf{f}$垂直，如下图所示：

![image-20221009152337022](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221009152337022.png)

### 根据扭转弹簧计算力矩

​	下图尝试以向量图的形式表示扭转弹簧问题，记从顶点$i$到顶点$j$的边向量为$\mathbf{x}_{ij}=\mathbf{x}_j-\mathbf{x}_i$，边长$l_{ij}=||\mathbf{x}_{ij}||$，边的方向$\hat{\mathbf{x}}_{ij}=\mathbf{x}_{ij}/l_{ij}$，旋转轴方向$\hat{\mathbf{h}}=\hat{\mathbf{x}}_{01}$，表面法向量为$\hat{\mathbf{n}}$。左边三角形的相关属性多一个$l$下标，右边三角形的相关属性多一个$r$下标。如下图所示：

![image-20221009160424892](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221009160424892.png)

过顶点$\mathbf{x}_2$和$\mathbf{x}_3$各自做一条垂直于旋转轴的垂线，方向指向顶点朝外，记这两个向量为$\mathbf{r}_l$和$\mathbf{r}_r$。可由下列式子求出：
$$
\begin{align}
\mathbf{r}_l&=\mathbf{x}_{02}-\left(\mathbf{x}_{02}\cdot\hat{\mathbf{h}}\right)\hat{\mathbf{h}} \\
\mathbf{r}_r&=\mathbf{x}_{03}-\left(\mathbf{x}_{03}\cdot\hat{\mathbf{h}}\right)\hat{\mathbf{h}}
\end{align}
$$
​	将两三角形当前的夹角$\theta$视为它们法向量的夹角，并记平衡位置的夹角为$\theta_0$。由于$\theta$的取值范围是($0\degree$-$360\degree$)，所以需要同时考虑$cos\theta=\hat{\mathbf{n}}_l\cdot\hat{\mathbf{n}}_r$与$sin\theta=(\hat{\mathbf{n}}_l\times\hat{\mathbf{n}}_r)\cdot\hat{\mathbf{h}}$。并且有：
$$
\theta = arctan\frac{\left(\hat{\mathbf{n}}_l\times\hat{\mathbf{n}}_r\right)\cdot\hat{\mathbf{h}}}{\hat{\mathbf{n}}_l\cdot\hat{\mathbf{n}}_r}
$$
注意，要确定夹角所在的象限，还是需要知道分子分母各自的符号。c++提供了`atan2(double y, double x)`函数，接受分子、分母两个参数，并返回$360\degree$范围的角度值。计算出角度之后，弹簧产生的力矩为：
$$
\mathbf{\tau}_k=k_\theta(\theta-\theta_0)\hat{\mathbf{h}}
$$
当力矩向量与旋转轴方向相同时，力矩所产生的旋转会使角度差减小，反之，角度差会增大。

​	与支撑杆类似，扭转弹簧也应该包含阻尼项来抑制振荡，阻尼大小应该与角速度成正比。角速度等于外侧顶点在其法向上的速度除以顶点到旋转轴的距离，即：
$$
\begin{align}
\dot{\theta}_l&=\mathbf{v}_2\cdot\hat{\mathbf{n}}_l/||\mathbf{r}_l|| \\
\dot{\theta}_r&=\mathbf{v}_3\cdot\hat{\mathbf{n}}_r/||\mathbf{r}_r||
\end{align}
$$
​	这两个角速度的和可以用来衡量两个表面接近得有多快，最终的阻尼力矩为：
$$
\mathbf{\tau}_d=-d_\theta(\dot{\theta}_l+\dot{\theta}_r)\hat{\mathbf{h}}
$$

### 根据扭转弹簧计算顶点受力

​	最后，将扭转弹簧产生的力分配到四个顶点上，记$\mathbf{f}_i$表示顶点$i$上的力，由于没有外力作用：$\mathbf{f}_0+\mathbf{f}_1+\mathbf{f}_2+\mathbf{f}_3=0$。因此我们只需要找到$3$个力便可确定第四个力。

# C++ Primer

## 拷贝、赋值与销毁

### 拷贝赋值运算符

​	重载运算符的本质是函数，其名字由operator关键字后接要定义的运算符。比如`operator=`。重载运算符的参数表示运算符的运算对象。某些运算符（比如赋值运算符）必须定义为成员函数。如果一个运算符是成员函数，则其第一个运算对象就绑定到隐式的`this`参数，其余运算对象作为显式参数传递。赋值运算符通常返回一个指向其左侧对象的引用，标准库要求保存在容器中的类型要具有赋值运算符。

​	合成的拷贝赋值运算符与拷贝构造函数类似，它会将右侧运算对象的每个非static成员赋值给左侧运算对象的相应成员，对于数组类型，逐元素赋值。**对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值**。

### 析构函数

​	析构函数释放对象使用的资源，并销毁对象的非static数据成员。由于析构函数不接受参数，因此它不能被重载，每个类只会有唯一析构函数。析构函数首先执行函数体，然后按成员初始化的逆序顺序销毁成员，**析构函数自身并不直接销毁成员**。成员销毁时发生什么完全依赖于成员类型，类类型成员需要执行自己的析构函数，内置类型没有析构函数，销毁时什么也不做。对于临时创建的对象，创建它的表达式结束时临时对象就会被销毁。当指向对象的引用或指针离开作用域时，对象的析构函数不会执行。**对于某些类，合成析构函数用来阻止该类型的对象被销毁，其他情况下，合成析构函数为空**。

​	**需要自定义析构函数的类一定需要自定义拷贝和赋值函数**。

​	**可以将默认构造函数和拷贝控制成员定义为`=default`来显式要求编译器生成合成版本**。类内使用`=default`的函数将隐式声明为内敛的，也可以在类外函数定义时使用`=default`，此时就不是内联的。

​	某些类不应该被拷贝或赋值（比如`iostream`），此时应该**将拷贝构造函数和赋值运算符定义为删除的函数**，用`=delete`修饰成员的声明。`=delete`必须出现在函数第一次声明的时候。可以对任何函数指定`=delete`，包括析构函数，但删除析构也意味着无法构造。**如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数被定义为删除的**。

# Vulkan编程指南

## Framebuffer

​	在创建管线的过程中描述了帧缓冲附件，但我们并没有真正配置和创建帧缓冲。我们在创建渲染流程时描述的所有附件需要绑定到一个帧缓冲对象上，同时，帧缓冲对象引用了真正用于表示所有附件的`VkImageView`对象们。在检索用于呈现的图像时，交换链返回给我们的图像决定了当前与所有附件绑定的`VkImageView`对象们。这意味着交换链中的所有图像都有其对应的缓冲区，在绘制时，使用检索到的用于呈现的图像所对应的缓冲区。

```c++
// Provided by VK_VERSION_1_0
typedef struct VkFramebufferCreateInfo {
	VkStructureType                 sType;
	const void*                     pNext;
	VkFramebufferCreateFlags        flags;
	VkRenderPass                    renderPass;
	uint32_t                        attachmentCount;
	const VkImageView*              pAttachments;
	uint32_t                        width;
	uint32_t                        height;
	uint32_t                        layers;
} VkFramebufferCreateInfo;
```

​	首先要指定与之兼容的`renderpass`，渲染流程与帧缓冲兼容意味着它们使用相同数量和类型的附件。`pAttachments`将render pass中使用的所有附件与Image View绑定。

## Command buffers

​	必须将所有想要执行的命令录入command buffer对象中，才能给Vulkan执行。这样便于Vulkan做指令优化，并且可以多线程地录入命令。

### Command pools

​	在创建command buffers之前，必须先创建command pool，command buffer由command pool分配。创建command pool只需要指定`flags`和`queueFamilyIndex`两个参数。`flags`的值可以是：

- `VK_COMMAND_POOL_CREATE_TRANSIENT_BIT`：表示command buffer中的命令经常被重新记录
- `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`：允许command buffer单独被重置，否则将被一起重置

​	只能通过将command buffer提交到queue中来执行其中的命令。每个command pool只能分配在特定类型的queue中提交的command buffer。
