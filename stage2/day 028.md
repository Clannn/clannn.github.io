# Game Engine Architecture

## Game Loop Architectural Styles

### Event-Based Updating

​	大多是游戏引擎都有事件系统，允许子系统注册特定类型的时间，当事件发生时就响应该事件。有些引擎还利用事件系统，通过周期性地提交事件来实现子系统的周期性更新。

## Abstract Timelines

​	CPU有一个用于保存时间的高精度寄存器，以CPU的始终周期为单位，可以通过除以CPU时钟频率将其转换为以秒为单位。不同的子系统可以使用不同的时间线。

​	可以不更新时间使引擎暂停，如果想让游戏进入慢动作，可以简单地使游戏时间慢于实际时间。暂停或慢动作对于debug也非常有用。可以暂停动画，同时渲染和相机继续运行，这样就可以从各个角度观察有问题的动画。也可以实现一个单步时的按钮，每按一次前进一个步时。

​	需要注意的是，虽然游戏暂停了，但game loop并没有暂停，只是$\Delta t=0$而已。可以通过一些简单的操作实现动画或音乐的快放、慢放或者倒放。$t^\prime=t_{start}+Rt$

​	当我们计算两帧之间的$\Delta t$时，实际上是用渲染上一帧所需的时间来估算渲染当前帧的所需时间。这会有一个问题，对于$30$帧的游戏而言，由于某个突发情况使得上一帧的渲染时间为$61ms$，为了物理的稳定性，可能需要做$4$次物理模拟，这又会导致当前帧需要更多的时间，陷入恶性循环。

# Vulkan Tutorial

## Descriptor pool and sets

​	创建了Descriptor binding及其对应的UBO buffer之后，需要为每个UBO buffer创建一个descriptor set来将buffer绑定到descriptor binding。

​	不能直接创建descriptor set，只能从descriptor pool中分配，首先需要描述descriptor set中需要的descriptor类型以及数量，通过`VkDescriptorPoolSize`描述：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkDescriptorPoolSize {
	VkDescriptorType    type;
	uint32_t            descriptorCount;
} VkDescriptorPoolSize;
```

然后描述descriptor pool：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkDescriptorPoolCreateInfo {
	VkStructureType                sType;
	const void*                    pNext;
	VkDescriptorPoolCreateFlags    flags;
	uint32_t                       maxSets;
	uint32_t                       poolSizeCount;
	const VkDescriptorPoolSize*    pPoolSizes;
} VkDescriptorPoolCreateInfo;
```

`maxSets`表示最多可以分配descriptor set的数量。

​	然后从descriptor pool中分配descriptor sets：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkDescriptorSetAllocateInfo {
	VkStructureType                  sType;
	const void*                      pNext;
	VkDescriptorPool                 descriptorPool;
	uint32_t                         descriptorSetCount;
	const VkDescriptorSetLayout*     pSetLayouts;
} VkDescriptorSetAllocateInfo;
```

由于我们同时渲染多帧，因此也需要创建多个descriptor sets。<u>`VkDescriptorBufferInfo`</u>

Vulkan要求的数据对齐：

- 常量必须$4$字节对齐
- `vec2`必须$8$字节对齐
- `vec3`和`vec4`必须$16$字节对齐
- 嵌套数据结构必须$16$字节对齐

## Images

​	为了向程序中添加一个纹理，我们需要：

- 创建一个设备内存支持的image对象
- 从图像文件中获取像素，并填充进内存
- 创建一个图像采样器
- 创建一个descriptor从纹理中进行采样

我们首先创建一个buffer，然后将像素值填充进去，再创建一个image对象，最后将buffer中的内容拷贝到image对象中。创建image对象的过程与创建vertex buffer的过程差不多：查询内存需求、分配内存并绑定。需要注意的是，image有不同的布局（*layout*），会影响像素在内存中的排列。简单的按行存储可能不会有非常好的性能，应该根据不同的操作调整图像的内存布局。图像的内存布局有：

- `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`：最适合用来呈现
- `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`：最适合用来从片段着色器写入颜色的布局
- `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`：最适合用来作为传输操作中的源
- `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`：最适合用来作为传输操作中的目的地
- `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`：最适合在shader中被采样

​	最常见的转换图像布局方式是管线“屏障”，管线屏障主要用来异步访问资源，比如确保在写操作执行前完成读操作。我们需要填充一个`VkImageCreateInfo`来创建一个image对象，具体定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkImageCreateInfo {
	VkStructureType          sType;
	const void*              pNext;
	VkImageCreateFlags       flags;
	VkImageType              imageType;
	VkFormat                 format;
	VkExtent3D               extent;
	uint32_t                 mipLevels;
	uint32_t                 arrayLayers;
	VkSampleCountFlagBits    samples;
	VkImageTiling            tiling;
	VkImageUsageFlags        usage;
	VkSharingMode            sharingMode;
	uint32_t                 queueFamilyIndexCount;
	const uint32_t*          pQueueFamilyIndices;
	VkImageLayout            initialLayout;
} VkImageCreateInfo;
```

​	`tiling`表示像素的排列形式，有两种常用取值：

- `VK_IMAGE_TILING_LINEAR`：像素按行存储在内存，可以随机访问
- `VK_IMAGE_TILING_OPTIMAL`：根据不同的操作选择合适的排列，不可以随机访问

​	`initialLayout`有两种取值：

- `VK_IMAGE_LAYOUT_UNDEFINED`：GPU不可见，每次布局转换后丢弃像素值
- `VK_IMAGE_LAYOUT_PREINITIALIZED`：GPU不可见，每次布局转换后保留像素值
