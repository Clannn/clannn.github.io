# Game Engine Architecture

## Lock-Free Concurrency

## Barriers

1. 指令重排怎样造成并发BUG

   如下代码：

   ```c++
   a = b+1;
   b = 0;
   ```

   对应的汇编代码为：

   ```assembly
   mov eax, [b]
   add eax, 1
   mov [a], eax
   mov [b], 0
   //指令重排后可能是
   mov eax, [b]
   mov [b], 0
   add eax, 1
   mov [a], eax
   ```

   第二个线程可能等待`b`置为$0$后读取`a`，实际上`a`的值还没有被修改，便可能会造成并发BUG。

2. Volatile in C/C++

   在C/C++中，`volatile`类型限定符试图保证对变量的连续读写不会被编译器“优化”，**但它并不能可靠的工作**。`volatile`提供的唯一保证是：变量的内容不会缓存到寄存器中。

3. Compiler Barriers

   防止编译器跨过临界区边界对读写指令重排的一种可靠方法是：显式地指明它不能这样做。通过在代码中插入一个称为Compiler barrier的特殊伪指令来实现。不同的编译器用不同的语法表示barrier，在VS中，`_ReadWriteBarrier()`有相同地效果：

   ```c++
   a = b+1;
   _ReadWriteBarrier(); //指令重排不允许越过该区域
   b = 0;
   ```

   大多数函数调用都包含隐式地barrier。compiler barriers并不能阻止CPU的“乱序执行”。

### 内存重排语义（Semantics）

​	除了对机器语言指令进行重排之外，读写指令在并发系统中也会被重新排序。在具有多级缓存和多核机器中，不同核心有时会对一系列读写指令发生的顺序产生分歧，即使这些指令是按我们预期的顺序执行的。更离谱的是，不同的CPU有不同的内存排序行为，即同样的源程序产生的效果可能因机器而异。每个CPU都提供了一套严格的内存重排语义，用于保证读写指令在内核间传播的稳定性。

1. Memory Caching

   **只要数据对象存在于缓存中，CPU将总是处理该缓存副本，而不是访问主存中的副本**。该缓存行的内容会被延迟“写回”主存中。

2. 多核缓存一致性协议

   多核机器中的内存缓存更加复杂，假设一个双核机器，每个核心有自己独立的缓存。在两个核心上分别运行生产、消费程序。当核心A将`g_ready`赋值为$1$时，一段时间内这个新值不会写回到内存中。此时若核心B读取`g_ready`，它会向核心A请求`g_ready`的副本，而不是直接读取内存。这种通信机制称为缓存一致性协议，它允许内核在各自的L1缓存间共享数据。

3. MESI缓存一致性协议

   在MESI协议下，每个缓存行可以处于以下四种状态之一：

   - Modified：该缓存行已被修改
   - Exclusive：该缓存行对应的主存块只保存在该核心的L1缓存中，其他核心没有它的副本
   - Shared：该缓存行对应的主存块保存在不止一个核心的L1缓存中
   - Invalid：该缓存行的数据不再有效，下次读取需要在其他核心或者主存中进行

   每次修改缓存行都会把缓存行置为Modified状态并把其他核心的相同缓存行置为Invalid状态。

4. MESI也可能会出错

   大多数硬件上，MESI协议会被高度优化，以最小化延迟。意味着当缓存通信总线收到消息时，并不会立即执行。与指令重排一样，MESI只保证单线程程序能正确执行。MESI的优化可能使两个读/写指令以与指令实际执行顺序相反的顺序发生。

# 基于物理的建模与动画

## 扭转弹簧

### <u>根据扭转弹簧计算顶点受力</u>

​	现在的目标是计算作用在四个顶点上的力，以解释由扭转弹簧所产生的力矩。由于没有外力作用：
$$
\mathbf{f}_0+\mathbf{f}_1+\mathbf{f}_2+\mathbf{f}_3=0
$$
因此我们只需要计算出$\mathbf{f}_1$、$\mathbf{f}_2$、$\mathbf{f}_3$。由于$\mathbf{f}_2$和$\mathbf{f}_3$是由弹簧产生的力矩作用在两个外部顶点的力，因此它们必须平行于表面法向量$\hat{\mathbf{n}}_l$和$\hat{\mathbf{n}}_r$。对于左边三角形而言：
$$
\mathbf{\tau}=\mathbf{r}_l\times\mathbf{f}_2
$$
等式两边同时点乘旋转轴向量，并将$\mathbf{r}_l$的模长提取出来有：
$$
\frac{\mathbf{\tau}\cdot\hat{\mathbf{h}}}{||\mathbf{r}_l||}=\left(\hat{\mathbf{r}}_l\times\mathbf{f}_2\right)\cdot\hat{\mathbf{h}}
$$
由于等式右边$\mathbf{r}_l$、$\mathbf{f}_2$、$\hat{\mathbf{h}}$相互正交，且$\mathbf{f}_2$与左边三角形的表面法向量平行，因此：
$$
\mathbf{f}_2=\frac{\mathbf{\tau}\cdot\hat{\mathbf{h}}}{||\mathbf{r}_l||}\hat{\mathbf{n}}_l
$$
同理可得：
$$
\mathbf{f}_3=\frac{\mathbf{\tau}\cdot\hat{\mathbf{h}}}{||\mathbf{r}_r||}\hat{\mathbf{n}}_r
$$
考虑力$\mathbf{f}_1$、$\mathbf{f}_2$、$\mathbf{f}_3$在点$\mathbf{x}_0$处产生的使转轴旋转的力矩：
$$
\begin{align}
\mathbf{\tau}_1&=l_{01}\hat{\mathbf{h}}\times\mathbf{f}_1 \\
\mathbf{\tau}_2&=\left(\mathbf{x}_{02}\cdot\hat{\mathbf{h}}\right)\hat{\mathbf{h}}\times\mathbf{f}_2 \\
\mathbf{\tau}_3&=\left(\mathbf{x}_{03}\cdot\hat{\mathbf{h}}\right)\hat{\mathbf{h}}\times\mathbf{f}_3
\end{align}
$$
由$\mathbf{\tau}_0+\mathbf{\tau}_1+\mathbf{\tau}_2+\mathbf{\tau}_3=0$且$\mathbf{\tau}_0=0$可得：
$$
\hat{\mathbf{h}}\times\mathbf{f}_1=\hat{\mathbf{h}}\times-\frac{d_{02}\mathbf{f}_2+d_{03}\mathbf{f}_3}{l_{01}}
$$
<u>由于$\mathbf{f}_1$、$\mathbf{f}_2$、$\mathbf{f}_3$都垂直于$\hat{\mathbf{h}}$</u>，所以：
$$
\mathbf{f}_1=-\frac{d_{02}\mathbf{f}_2+d_{03}\mathbf{f}_3}{l_{01}}
$$
总结，计算两个三角面由扭转弹簧产生的力，总共需要计算：

![image-20221010154949743](C:\Users\Clan\AppData\Roaming\Typora\typora-user-images\image-20221010154949743.png)

## 选择好的参数

​	首先确定物体的质量，然后按三角形面积的比例将质量分配到每个三角形，最后根据每个顶点邻接的三角形对应的角度来将质量分配给每个顶点。

