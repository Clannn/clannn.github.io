# Game Engine Architecture

## Lock-Free Concurrency

### 自旋锁

3. 可重入锁

   如果一个自旋锁试图重新获取它已经持有的锁，将会导致线程死锁。当多个线程安全的函数尝试从同一个线程内重入调用另一个时，就会发生这种情况。例如下列两个函数：

   ```c++
   SpinLock g_lock;
   
   void A(){
       ScopedLock<decltype(g_lock)> janitor(g_lock);
       //do something...
   }
   void B(){
       ScopedLock<decltype(g_lock)> janitor(g_lock);
       A();  //死锁
   }
   ```

   我们让自旋锁类缓存锁定它的线程ID，这样，当有一个线程再次获取该锁时，锁就能知道是否是同一个线程在重入。同时，我们还需要确保`Acquire`和`Release`的调用总是成对的，通过添加引用计数来保证。最终的可重入锁实现如下：

   ```c++
   class ReentrantLock32{
       std::atomic<std::size_t> m_atomic;           //线程id的哈希值
       std::int32_t             m_refCount;
   public:
       ReentrantLock32(): m_atomic(0), m_refCount(0) {}
       void Acquire(){
           std::hash<std::thread::id> hasher;
           std::size_t tid = hasher(std::this_thread::get_id());
           if(m_atomic.load(std::memory_order_relaxed) != tid){//其他线程或者没有线程锁定拥有它
               //自旋
               std::size_t unlockedValue = 0;
               while(!m_atomic.compare_exchange_weak(unlockValue, tid, std::memory_order_relaxed, std::memory_order_relaxed)){
                   unlockValue = 0;
                   PAUSE();
               }
           }
           ++m_refCount;
           std::atomic_thread_fence(std::memory_order_acquire); //保证之前的读操作不会越过这里
       }
       void Release(){
           std::atomic_thread_fence(std::memory_order_release); //保证之前的写操作不会越过这里
           std::hash<std::thread::id> hasher;
           std::size_t tid = hasher(std::this_thread::get_id());
           std::size_t actual = m_atomic.load(std::memory_order_relaxed);
           ASSERT(actual == tid);
           --m_refCount;
           if(m_refCount == 0){
               m_atomic.store(0, std::memory_order_relaxed);
           }
       }
       bool TryAcquire(){
           std::hash<std::thread::id> hasher;
           std::size_t tid = hasher(std::thread::get_id());
           bool acquired = false;
           if(m_atomic.load(std::memory_order_relaxed) == tid){
               acquired = true;
           }
           else{
               std::size_t unlockValue = 0;
               acquired = m_atomic.compare_exchange_strong(unlockValue, tid, std::memory_order_relaxed, std::memory_order_relaxed);
           }
           if(acquired){
               ++m_refCount;
               std::atomic_thread_fence(std::memory_order_acquire);
           }
           return acquired;
       }
   };
   ```

4. 读写锁

   多个线程读写共享数据时，我们希望允许多个线程同时读取它，每当一个写线程试图获取锁时，应该等所有读线程执行完毕后，再以“独占”模式获取锁。这种锁称为读写锁（排他锁）。我们只保存一个读者的引用计数，使用一个保留值来表示写入者持有该锁（`0xFFFFFFFFU`）。**读写锁存在饥饿问题**。

5. Lock-Not-Needed Assertions

   无论无何，不管什么样的锁都很贵。实践中，我们根据先验和经验来判断是否需要锁。比如某线程在帧生成前期独占某变量，另一个线程在帧生成后期访问同一变量。但为了防止我们判断错误或者之后重构代码，需要用断言来检查是否真的需要锁，这种断言称为*Lock-Not-Needed* 断言。我们可以使用一个原子`bool`变量来实现这一想法，向互斥锁一样：**获取时断言它为假，并将它赋值为真；释放时断言它为真，并赋值它为假**。但实际上，这种实现方式与没有竞争的自旋锁一样昂贵。可以使用一个“Trick”：**我们只关心同一共享对象上的关键操作是否有重叠**。因此，使用`volatile bool`而不是原子`bool`，这样能很快的检测，但不能做到$100\%$准确。

   ```c++
   class UnnecessaryLock{
       volatile bool m_locked;
   public:
       void Acquire(){
           ASSERT(!m_locked);
           m_locked = true;
       }
       void Release(){
           ASSERT(m_locked);
           m_locked = false;
       }
   };
   ```

### Lock-Free Transactions

​	无锁编程的目标是：避免使用会使线程进入阻塞状态的锁。我们可以将关键操作视为“事务”，“事务”要么全部成功，要么全部失败。失败时重新尝试执行。首先，我们本地地（使用局部变量）执行大部分工作，尽可能将关键操作放在一起，然后执行一个原子指令（例如CAS）。如果原子指令执行成功，意味着我们成功地提交了“事务”。如果执行失败，意味着同一时刻，其他线程正在提交“事务”。“事务”能保证系统中至少有一个线程正在向前推进。

​	实现一个支持`push_front()`的无锁链表作为事务的例子，准备事务的过程相当于：我们分配一个节点并填充它，将它的next指针指向当前的头节点。有一个原子指针指向头节点，提交事务的过程相当于：对头指针执行`compare_exchange_weak()`调用，如果调用成功，则表示提交完成，否则提交失败重试，重试前需要修改next指针的值。

```c++
template<typename T>
class SList{
    struct Node{
        T m_data;
        Node* m_pNext;
    };
    std::atomic<Node*> m_head{nullptr};
public:
    void push_front(T data){
        auto pNode = new Node();
        pNode->m_data = data;
        pNode->m_pNext = m_head;
        while(!m_head.compare_exchange_weak(pNode->m_pNext, pNode)) { }
    }
};
```

# 基于物理的建模与动画

## 碰撞

### 弹性物体的碰撞响应

**与静态物体碰撞**

​	**静态碰撞比较容易做碰撞确定**，得到碰撞点的具体位置。如果移动物体在顶点处发生碰撞，与粒子的点-面的碰撞响应一致。如果移动物体在边或者面上发生碰撞，首先通过插值计算出碰撞点处的速度，然后用处理粒子的方式计算该点的碰撞响应，此时需要法线信息，对于面-点碰撞，使用面的法线，对于边-边碰撞，使用两边的叉积。最后将碰撞点的碰撞响应反应到相关的点上，具体方法是：假设碰撞点$\mathbf{p}$位于$\mathbf{p}_1\mathbf{p}_2$上的某一点，有$\mathbf{p}=u\mathbf{p}_1+v\mathbf{p}_2$，如下图所示：

![image-20221012171254676](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221012171254676.png)

$\mathbf{p}$点的速度变化量为：$\Delta{\mathbf{v}}=\mathbf{v}^+-\mathbf{v}^-$，我们希望**按照同样的影响因子将速度反馈给$\mathbf{p}_1$和$\mathbf{p}_2$**，即找到一个新的速度变化量$\Delta{\mathbf{v}}'$，使得$\mathbf{v}^+_1=\mathbf{v}^-_1+u\Delta{\mathbf{v}}'$且$\mathbf{v}^+_2=\mathbf{v}^-_2+v\Delta{\mathbf{v}}'$。**我们希望$\mathbf{p}$点的速度变化量是由$\mathbf{p}_1$、$\mathbf{p}_2$的速度变换量插值产生的**，即：
$$
\begin{align}
\Delta{\mathbf{v}}&=u\Delta{\mathbf{v}}_1+v\Delta{\mathbf{v}}_2\\
&=u(u\Delta{\mathbf{v}}')+v(v\Delta{\mathbf{v}}')
\end{align}
$$
所以：
$$
\Delta{\mathbf{v}}'=\frac{\Delta{\mathbf{v}}}{u^2+v^2}
$$
同理对于三角形而言：

![image-20221012172814093](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221012172814093.png)
$$
\Delta{\mathbf{v}}'=\frac{\Delta{\mathbf{v}}}{u^2+v^2+w^2}
$$
**移动物体的碰撞**

<u>怎么做碰撞确定？</u>