# Vulkan Tutorial

## 着色器模块

### 创建着色器模块

​	当我们获取到着色器的二进制代码以后，需要将其包装进`VkShaderModule`对象中，该对象的`createInfo`定义如下所示：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkShaderModuleCreateInfo{
    VKStructureType            sType;
    const void*                pNext;
    VkShaderModuleCreateFlags  flags;
    size_t                     codeSize;
    const uint32_t*            pCode;
} VkShaderModuleCreateInfo;
```

有一个问题是：字节码的大小`codeSisze`是以字节为单位的，而指向字节码的指针却是`uint32_t*`。因此，需要使用`reinterpret_cast`将字节码数据转换为`uint32_t*`，需要注意在强制转换时必须确保被转换的数据满足`uint32_t`的对齐要求，由于我们使用`vector<char>`保存数据，恰好是满足要求的。

​	图形管线创建完成之后，**指定的着色器字节码将被自动地上载到GPU中，并被GPU编译链接到机器码中**。这意味着我们可以将着色器模块定义为局部变量并在图形管线创建完成之后手动销毁它们。

### 着色器（可编程）管线阶段的创建

​	为了实际使用创建的着色器，我们需要将它们分配到特定的图形管线阶段。填充`VkPipelineShaderStageCreateInfo`结构用来创建着色器阶段（可编程阶段），该结构定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkPipelineShaderStageCreateInfo {
	VkStructureType                     sType;
    const void*                         pNext;
    VkPipelineShaderStageCreateFlags    flags;
    VkShaderStageFlagBits               stage;
    VkShaderModule                      module;
    const char*                         pName;
    const VkSpecializationInfo*         pSpecializationInfo;
} VkPipelineShaderStageCreateInfo;
```

`stage`用于指定具体哪个可编程阶段；`module`指定对应的着色器模块；`pName`指定着色器的入口函数；`pSpecializationInfo`允许你设定着色器常量的值。可以指定不同的`pName`意味着可以将多个片段着色器合并到一个着色器模块中，通过指定不同的`pName`来区分它们的行为。也可以通过配置不同的着色器常量值来实现不同的效果。目前只需要创建顶点着色器和片段着色器两个阶段。

## 固定管线阶段

### 顶点输入

​	`VkPipelineVertexInputStateCreateInfo`结构描述了将要传递给顶点着色器的顶点数据格式。通过以下两种方式描述：

- Bindings：描述数据间的间距以及数据是逐顶点还是逐实例
- 属性描述：传递给顶点着色器的属性类型，从哪个binding加载这些属性以及对应的偏移量

该结构定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkPipelineVertexInputStateCreateInfo {
	VkStructureType                             sType;
    const void*                                 pNext;
    VkPipelineVertexInputStateCreateFlags       flags;
    uint32_t                                    vertexBindingDescriptionCount;
    const VkVertexInputBindingDescription*      pVertexBindingDescriptions;
    uint32_t                                    vertexAttributeDescriptionCount;
    const VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;
} VkPipelineVertexInputStateCreateInfo;
```

### 输入配置

​	`VkPipelineInputAssemblyStateCreateInfo`结构描述了图元类型以及是否应该启用图元重启，前者在`topology`成员中指定。具体定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkPipelineInputAssemblyStateCreateInfo {
    VkStructureType                             sType;
    const void*                                 pNext;
    VkPipelineInputAssemblyStateCreateFlags     flags;
    VkPrimitiveTopology                         topology;
    VkBool32                                    primitiveRestartEnable;
} VkPipelineInputAssemblyStateCreateInfo;
```

`topology`的值主要有：

- `VK_PRIMITIVE_TOPOLOGY_POINT_LIST`：以点作为图元
- `VK_PRIMITIVE_TOPOLOGY_LINE_LIST`：以线作为图元，每隔两个顶点表示一条线，不重用
- `VK_PRIMITIVE_TOPOLOGY_LINE_STRIP`：以线作为图元，重用顶点
- `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST`：以三角形作为图元，三个顶点表示一个三角形，不重用
- `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP`：以三角形作为图元，重用顶点

如果选择重用顶点并启用图元重启，则可以通过`0xFFFF`或`0xFFFFFFFF`顶点索引值将不同的物体分开。

### 视口与裁剪

​	视口描述了帧缓冲的可用区域，几乎总是$(0, 0)$到$(width, height)$。具体定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkViewport {
    float x;
    float y;
    float width;
    float height;
    float minDepth;
    float maxDepth;
} VkViewport;
```

$(x,y)$表示屏幕左上角坐标。

​	裁剪矩形定义了帧缓冲中哪些区域的像素被实际存储，裁剪矩形之外的所有像素都会被丢弃。视口与裁剪的关系如下图所示：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221006154526442.png" alt="image-20221006154526442" style="zoom: 67%;" />

​	结合视口与裁剪便可以定义视口状态`VkPipelineViewportStateCreateInfo`。由于可能存在多视口渲染，所以二者应该以数组方式指定，具体定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkPipelineViewportStateCreateInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkPipelineViewportStateCreateFlags    flags;
    uint32_t                              viewportCount;
    const VkViewport*                     pViewports;
    uint32_t                              scissorCount;
    const VkRect2D*                       pScissors;
} VkPipelineViewportStateCreateInfo;
```

### 光栅化

​	目前，光栅化将顶点着色器的输出作为输入，并将其离散化为片元作为片段着色器的输入。使用`VkPipelineRasterizationStateCreateInfo`配置相关状态，具体定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkPipelineRasterizationStateCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
	VkPipelineRasterizationStateCreateFlags    flags;
	VkBool32                                   depthClampEnable;
	VkBool32                                   rasterizerDiscardEnable;
	VkPolygonMode                              polygonMode;
	VkCullModeFlags                            cullMode;
	VkFrontFace                                frontFace;
	VkBool32                                   depthBiasEnable;
	float                                      depthBiasConstantFactor;
	float                                      depthBiasClamp;
	float                                      depthBiasSlopeFactor;
	float                                      lineWidth;
} VkPipelineRasterizationStateCreateInfo;
```

​	`depthClampEnable`指定是否将近、远平面之外的片元放到平面上，而不是丢弃它们；`rasterizerDiscardEnable`指定是否在光栅化之前丢弃所有图元；`polygonMode`决定了如何生成片元，有以下几种模式：

- `VK_POLYGON_MODE_FILL`：用片元填充多边形区域
- `VK_POLYGON_MODE_LINE`：用片元填充多边形的边
- `VK_POLYGON_MODE_POINT`：用片元填充多边形的点

需要注意的是，**除了填充模式以外的任何模式都需要启用GPU特性**；`cullMode`指定表面剔除的类型，可以是：禁用剔除、剔除前面、剔除背面、前后都剔除；`frontFace`指定被视为正面的顶点顺序，可以是顺时针或逆时针；`depthBias...`可以通过添加常量或根据片元的斜率来改变深度值，可以用于阴影映射，目前不使用它们；`lineWidth`指定线的宽度，任何大于$1.0$的值都需要启用GPU特性。

### 超采样

​	超采样的原理是：**混合不同多边形光栅化到同一个像素的颜色**。显然这种情况主要出现在物体边缘。开启该功能需要启用GPU特性。暂时不需要超采样，后续再解释具体定义。

### 深度和模板测试

​	暂时不需要深度和模板测试。

### 颜色混合

​	片段着色器返回颜色之后，需要与帧缓冲中已经存在的颜色相混合，有两种方式：

- 将新颜色与旧颜色混合，产生新颜色
- 使用位运算组合新旧颜色值

​	有两种类型的结构可以配置颜色混合，`VkPipelineColorBlendAttachmentState`包含每个附加的帧缓冲的配置，`VkPipelineColorBlendStateCreateInfo`包含全局的颜色混合配置。