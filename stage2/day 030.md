# Game Engine Architecture

## Multiprocessor Game Loops

### Job Systems

​	作业系统维护一个已提交的作业队列，作业系统将作业提交到线程池的某个工作线程，来实现对作业的调度。作业的细粒程度可以是任意的，但不同的作业间要保持相互独立。

1. Typical Job System Interface

   一个典型的作业系统提供的API应该与线程库提供的API类似，比如：创建作业、`join`作业、提前结束作业等。一个作业系统必须支持线程同步“锁”，用于在并发线程中原子地执行关键操作。

   为了驱动作业系统，我们必须告诉它执行什么作业，怎么执行作业，通常情况下，将这些信息包装进作业声明，并传递给`KickJob()`函数。

   一个作业声明必须包括一个作业的入口函数，还需要能像作业传递任意的参数，一般通过一个`uintptr_t`参数实现。作业系统还应该提供优先级机制，就像线程库那样。一个简单的作业系统伪代码：

   ```c++
   namespace job{
       typedef void EntryPoint(uintptr_t param);
       
       enum class Priority{
           LOW, NORMAL, HIGH, CRITICAL
       };
       
       struct Counter;
       Counter* AllocCounter();
       void FreeCounter();
   
       struct Declaration{
           EntryPoint*    m_pEntryPoint;
           uintptr_t      m_param;
           Priority       m_priority;
           Counter*       m_pCounter;
       };
   
       void KickJob(const Declaration& decl);
       void KickJobs(int count, const Declaration aDecl[]);
       void KickJobAndWait(const Declaration& decl);
       //......
   }
   ```

   `job::Counter`用于允许一个作业休眠自己来等待其他作业执行完毕。

   