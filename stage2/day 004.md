# 游戏引擎架构

# 显式并行

​	显式并行硬件允许**并行处理多个指令流**。

### 超线程

​	当流水线CPU遇到指令依赖时，会创建一个“延迟时间段”来处理没有依赖的指令。CPU向前看并选择合适的指令“乱序执行”。当只有一个指令流时，显然“乱序执行”会有诸多限制且非常保守。如果CPU可以同时处理两个不同的指令流呢？
​	一般而言，一个超线程CPU核心拥有两套寄存器文件和两个指令解码单元，但只有一个相同的“后端”来执行指令，还拥有相同的L1缓存。核心架构如下图：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220921095522058.png" alt="image-20220921095522058" style="zoom:80%;" />

### 多核CPU

​	目前为止所学的CPU设计都是“单核”。当一个CPU中包含多个核心时，称之为多核CPU。每个核心的内部设计都可以是目前所学的任何一种——串行、流水线、超标量、超长指令字、超线程。

### 对称与非对称多核

​	对称多核是指机器中可用的CPU核心在设计和指令集上都是相同的，并且被操作系统平等对待。任何线程都可以被安排在任何核心上运行。非对称多核中，CPU不一定是同质的，操作系统也不平等地对待它们。一个“主”核通常运行操作系统，其他核心被视为“从”核，工作负载由主核心分配。

## 操作系统基础

### 内核

​	内核是操作系统的核心，处理**最基本和最低级别操作的部分**。操作系统的其余部分和所有用户程序都构建在内核提供的服务之上。

#### 内核态与用户态

​	内核及其设备驱动运行在内核态，其他所有程序运行在用户态。运行在内核态下的程序能完全访问计算机中的所有硬件。**运行在用户态下的程序只能通过系统调用（Kernel Calls）来请求内核执行底层操作。**操作系统实现多个保护等级，等级的数量因CPU和操作系统的不同而不同。比如：
内核的保护等级为0，是最受信任的等级；驱动程序的等级为1；具有I/O权限的程序保护等级为2；“不可信”的程序等级为3。

#### 内核态的特权

​	内核程序可以访问CPU指令集中的所有机器指令，包括*特权指令*。特权指令可以修改某些通常被禁用的寄存器（如：屏蔽或取消屏蔽中断，控制虚拟内存映射），或者可能允许访问特定区域的内存。内核程序通过使用特权指令来保证系统的安全性。

### 中断

​	**中断是发送给CPU的信号，用来通知它发生了重要的“低级”事件**，比如：键盘按键、外部设备的信号等。当一个事件发生时，一个*中断请求* 被抛出，如果操作系统希望响应此事件，它将暂停当前的程序并调用**中断服务程序**。中断服务程序负责响应事件，然后控制权返回到中断发生前的程序。

​	中断分为硬件中断和软件中断。硬件中断通过在CPU的一个引脚设置非零电压来请求的，硬件中断由外部设备（如键盘鼠标）触发，可以发生在任何时候。软件中断是由软件触发的，可以通过**执行“中断”机器指令**显式触发或者当CPU运行时检测到错误时也会触发中断，称为*异常*。

### 系统调用（Kernel Calls）

​	在大多数系统中，系统调用是通过中断来完成的，用户程序将输入参数放在特定的位置（内存或寄存器），然后发出一个“软中断”，该指令带有一个整数参数，指定哪种底层操作被内核执行。CPU调用恰当的中断服务程序，如果内核允许执行请求，内核将执行请求后将控制权返回给发出请求的程序。现代的操作系统中，用户程序不会手动执行系统调用指令，是通过调用一个内核API的函数，该函数负责编排参数和触发软件中断。此时对于用户程序而言，系统调用就像是常规的函数调用。

# 基于物理的建模与动画

## 级数展开与积分

​	我们的积分目标是：**给定$t$时刻的状态$\mathbf{s}(t)$，想得到$\mathbf{s}(t+h)$**。我们需要做的计算是：
$$
\mathbf{s}(t+h)=\mathbf{s}(t)+\int_t^{t+h}\dot{\mathbf{s}}(\tau)d\tau
$$
​	但我们根本无法获取$\dot{\mathbf{s}}(\tau)$的解析形式，因此无法计算积分。只能对积分做近似。函数$f(x)$的泰勒展开可写作：
$$
f(x+\Delta{x})=\sum_{n=0}^\infty\frac{f^{(n)}(x)}{n!}(\Delta{x})^n
$$
​	令$f=s$，$x=t$，$\Delta{x}=h$，可得：
$$
\mathbf{s}(t+h)=\mathbf{s}(t)+\dot{\mathbf{s}}(t)h+\frac{1}{2}\ddot{s}(t)h^2+\cdots
$$
常见的近似方式有：

- $\mathbf{s}(t+h)=\mathbf{s}(t)+\dot{\mathbf{s}}(t)h$
- $\mathbf{s}(t+h)=\mathbf{s}(t)+\dot{\mathbf{s}}(t+h)h$
- $\mathbf{s}(t+h)=\mathbf{s}(t)+\frac{\dot{\mathbf{s}}(t)+\dot{\mathbf{s}}(t+h)}{2}h$
- $\mathbf{s}(t+h)=\mathbf{s}(t)+\dot{\mathbf{s}}(t+0.5h)h$
- $\mathbf{s}(t+h)=\frac{1}{3}\left(\mathbf{s}(t)+\frac{\dot{\mathbf{s}}(t)+\dot{\mathbf{s}}(t+h)}{2}h\right)+\frac{2}{3}\left(\mathbf{s}(t)+\dot{\mathbf{s}}(t+0.5h)h\right)$

​	还有一个问题，只有当加速度是常数时，我们才能知道给定状态在未来某时刻的导数。因此我们还需要可以估计未来状态的积分方法。

## 韦尔莱积分与蛙跳积分

​	**韦尔莱积分假设加速度仅由位置决定，**也就是说，**力是位置的函数，即$f(\mathbf{x})$**。因此这个方式无法处理空气阻力或群集的速度匹配等问题。

### 基础韦尔莱积分

​	在韦尔莱积分中，我们单独计算位置和速度，并且先计算位置。假设$\mathbf{x}(t)$、$\mathbf{x}(t+h)$、$\mathbf{x}(t+2h)$已知，则可以估计速度：$\mathbf{v}(t+0.5h)=\frac{\mathbf{x}(t+h)-\mathbf{x}(t)}{h}$，$\mathbf{v}(t+1.5h)=\frac{\mathbf{x}(t+2h)-\mathbf{x}(t+h)}{h}$。然后两个速度间的加速度估计为：
$$
\begin{align}
\mathbf{a}(t+h)&=\frac{\mathbf{v}(t+1.5h)-\mathbf{v}(t+0.5h)}{h}\\
&=\frac{\mathbf{x}(t+2h)-2\mathbf{x}(t+h)+\mathbf{x}(t)}{h^2}
\end{align}
$$
这可以用来求解$\mathbf{x}(t+2h)$的值：
$$
\mathbf{x}(t+2h)=\mathbf{a}(t+h)h^2+2\mathbf{x}(t+h)-\mathbf{x}(t)
$$
即，韦尔莱积分的基础算法为：
$$
\mathbf{x}^{[i+2]}=-\mathbf{x}^{[i]}+2\mathbf{x}^{[i+1]}+\mathbf{a}^{[i+1]}h^2
$$
显然，韦尔莱积分的问题是：

1. 如果要计算$t$时刻速度，需要先计算出$t+h$时刻的位置，大多数情况下这样都太迟了
2. 仅有初始条件$\mathbf{x}(0)$、$\mathbf{v}(0)$和$\mathbf{a}(0)$时，使用$\mathbf{x}(h)=\mathbf{x}(0)+\mathbf{v}(0)h+\mathbf{a}(0)h^2$来估计$\mathbf{x}(h)$
3. 利用估计出的速度计算加速度，损失了理论精度

### 速度韦尔莱积分

​	多数情况下我们都需要知道速度。假设已知$\mathbf{x}^{[i]}$、$\mathbf{a}^{[i]}$和$\mathbf{v}^{[i]}$，需要计算$\mathbf{x}^{[i+1]}$和$\mathbf{v}^{[i+1]}$。使用欧拉积分计算速度：$\mathbf{v}^{[i+1]}=\mathbf{v}^{[i]}+\mathbf{a}^{[i]}h$，使用梯形公式计算位置：
$$
\mathbf{x}^{[i+1]}=\mathbf{x}^{[i]}+\frac{\mathbf{v}^{[i]}+\mathbf{v}^{[i+1]}}{2}h\\
=\mathbf{x}^{[i]}+\mathbf{v}^{[i]}h+\frac{1}{2}\mathbf{a}^{[i]}h^2
$$
​	得到位置的近似之后，**由于只考虑加速度是位置的函数**，可以计算出新的加速度，再用梯形公式计算新的速度：
$$
\mathbf{a}^{[i+1]}=\frac{1}{m}\mathbf{f}(\mathbf{x}^{[i+1]})\\
\mathbf{v}^{[i+1]}=\mathbf{v}^{[i]}+\frac{\mathbf{a}^{[i]}+\mathbf{a}^{[i+1]}}{2}h
$$

### 跳蛙积分

​	“跳蛙”是指，随着时间推进，位置和速度的计算相互“跳跃”过对方。跳蛙积分使用半时速度对韦尔莱积分作了小修正，假设$\mathbf{x}^{[i]}$、$\mathbf{a}^{[i]}$、$\mathbf{v}^{[i+0.5]}$已知，计算方式如下：
$$
\mathbf{x}^{[i+1]}=\mathbf{x}^{[i]}+\mathbf{v}^{[i+0.5]}h\\
\mathbf{a}^{[i+1]}=\frac{1}{m}\mathbf{f}(\mathbf{x}^{[i+1]})\\
\mathbf{v}^{[i+1.5]}=\mathbf{v}^{[i+0.5]}+\mathbf{a}^{[i+1]}h
$$
​	可以使用半步欧拉估计$\mathbf{v}^{[0.5]}$。

## 龙格-库塔（Runge-Kutta）积分

​	韦尔莱积分有个非常大的缺点是**无法处理加速度与速度有关**的情况。

# C++ Primer

> 顶层const也可以定义新的重载函数。某些操作应该同时提供const和非const两个函数。

# Vulkan编程指南

## 物理设备和队列族

​	创建`VkInstance`后，我们需要查询系统中的显卡设备，选择一个**或多个**支持我们所需特性的设备使用。**需要检查所选的设备是否支持需要的队列族以及设备级扩展。**还要检查设备是否支持以后所需的属性(`VkPhysicalDeviceProperties`)与特性(`VkPhysicalDeviceFeatures`)。

## 逻辑设备和队列

​	选择物理设备后，我们还需要一个逻辑设备来作为和物理设备交互的接口。对于同一个物理设备，我们可以根据需求的不同，创建多个逻辑设备。创建逻辑设备需要指定：**要创建的队列、要使用的设备特性、需要的设备级扩展**。

​	指定要创建的队列时，需要填充`VkDeviceQueueCreateInfo`结构体，每个结构体都针对单个的队列族描述所需的队列数量。一般而言单个队列族所需的队列数量始终为$1$。每个队列都需要一个$0.0$到$1.0$的浮点数作为优先级来控制指令缓冲的执行顺序。创建逻辑设备时，指定的队列会被一同创建，别忘记获取创建出来的队列句柄。

## 窗口表面

​	由于Vulkan是一个平台无关的API，他不能直接和窗口系统交互。为了将Vulkan渲染的图像显示在窗口上，我们需要使用`VK_KHR_surface`实例级扩展，**它通过`VkSurfaceKHR`对象抽象出可供Vulkan渲染的表面**。GLFW提供了获取`VkSurfaceKHR`对象的函数。由于窗口表面对物理设备的选择有一定影响，它的创建只能在Vulkan实例创建之后进行。

​	保守起见，我们需要扩展`isDeviceSuitable`函数来确保设备可以在我们创建的表面上显示图像。支持绘制指令的队列族和支持呈现的队列族并不一定重叠。

## 交换链

​	Vulkan没有默认帧缓冲的概念，它需要一个能够缓冲渲染操作的组件，称为交换链。**它的本质是一个包含了若干等待被呈现的图像队列**。应用程序从交换链获取一张图像，然后渲染，最后将图像返回到交换链的队列中。**交换链在合适的时机将图像呈现到窗口表面。**

​	交换链并非Vulkan核心的一部分，因为图像呈现非常依赖于窗口系统以及窗口表面。必须保证`VK_KHR_swapchain`**设备级扩展**被启用。在选择物理设备时对其进行检查。（实际上，如果设备支持呈现队列，那么它就一定支持交换链。）

​	

​	
