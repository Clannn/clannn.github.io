# Game Engine Architecture

## Strings

### 字符串的问题

​	字符串在C/C++中被实现为字符数组，通常情况下字符串都是可变长的，意味着需要动态分配字符串缓冲区。还有本地化的问题，翻译后的字符串长度可能差很多，而且不一定是“从左到右”书写的。**字符串在引擎内部还用于资源文件名和对象ID**。

​	字符串的一些操作是比较昂贵的（比如比较运算），复制字符串还可能需要动态分配内存。`strcmp()`与`strcpy()`是非常昂贵的函数。

### C++ string类

​	使用`std::string`有很多“隐藏”的成本，比如传递字符串对象时，可能会导致一个或多个拷贝构造函数的开销。而字符数组只需要传递一个指针即可。**请避免在游戏引擎中直接使用`std::string`**。如果一定要用，请以引用方式传递字符串。**使用一个专门的字符串类来表示文件系统的路径名是非常有必要的**`std::filesystem::path`。

### Unique ID

​	任何虚拟世界中的对象都需要被某种方式唯一地标识。不管游戏设计者还是引擎开发者都可以方便地追踪某个对象。由于字符串的一些操作非常慢，我们显然不能用字符串作为全局唯一标识。我们需要一种像字符串一样灵活的标识，但处理它的速度却跟整数一样快。

1. 字符串哈希

   将实际的字符串存储在哈希表中，这样就可以用哈希值恢复原始的字符串。选择合适的哈希算法来避免碰撞，确实遇到碰撞时，只需要稍微修改一下字符串就行。

2. 一些实现思路

   虽然获取字符串的哈希值很容易，但实际要考虑的是何时对字符串进行哈希处理。最好不要在运行时才做字符串哈希，因为它挺慢的。可以**将字符数组的指针和字符串对应的哈希值保存在一个小类中**（Unreal中叫做`FName`）。

   一般情况下，有`GUID`的字符串只有在开发过程中需要用到字符串的值，发布游戏时，只是用`GUID`就够了。

# C++ Primer

- 移动赋值运算符执行析构和移动构造函数相同的工作，并且不抛出任何异常，能正确处理自赋值
- 在移动操作完成后，源对象会被销毁，我们自己编写移动操作时，请确保移后源对象进入一个可析构的状态
- **不要操作移动后的对象**，编译器对它的值不做任何保证
- **当一个类没有定义任何自己的拷贝控制成员，并且类的每个非static数据成员都可以移动时，编译器才会合成默认的移动构造函数**
- 编译器可以移动内置成员，如果类对象定义了移动操作，编译器也可以移动它
- 移动操作永远不会隐式定义为删除的函数，只有当我们将其指定为`=default`且编译器不能移动所有成员时，移动操作才会被定义为删除的
- 如果一个类没有定义移动操作，那么类会使用拷贝操作来代替移动操作
- 定义了一个移动构造函数或移动赋值的类必须也定义自己的拷贝操作，**否则，这些拷贝操作默认定义为删除的**
- 值传递时，**右值被移动，左值被拷贝**，如果没有移动构造函数，右值也被拷贝
- 如果一个类定义了自己的拷贝操作，那么它就应该定义所有$5$个操作

