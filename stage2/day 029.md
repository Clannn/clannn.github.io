# Game Engine Architecture

## Measuring and Dealing with Time

### From Frame Rate to Speed

​	关于$\Delta t$的一些计算方式

1. Updating Based on Elapsed Time

   上一帧的结束（这一帧的开始）时间减去上一帧的开始时间，可以通过全局变量或单例类成员的方式保存$\Delta t$。本质在于，我们在用绘制上一帧所需的时间来估计绘制这一帧所需的时间。这会有一个问题，对于$30$帧的游戏而言，由于某个突发情况使得上一帧的渲染时间为$61ms$，为了物理的稳定性，可能需要做$4$次物理模拟，这又会导致当前帧需要更多的时间，陷入恶性循环。

2. Using a Running Average

   使用前几帧的平均时间来估计$\Delta t$，这可以让游戏的帧率变化（看起来）更平滑，同时对于帧率变化的响应也会比较慢。

3. Governing the Frame Rate

   我们可以强制规定每一帧的绘制时间，比如$33.3ms$。如果绘制时间小于规定时间，则让主线程`sleep`，如果绘制时间大于规定时间，则直接提交并估计下一帧的绘制时间为剩余时间加$33.3ms$，只有当实际帧率与规定帧率比较接近时，才能稳定的工作。保持帧率稳定非常重要，当帧率趋于稳定时再进行帧率控制，当帧率不稳定时切换到其他方式。

   稳定的帧率是实现回放功能的前提，实现回放需要记录所有的事件以及发生的时间点，使用相同的初始条件和随机数，重新运行游戏。

4. Screen Tearing and V-Sync

   当前后缓冲区交换时，仅有部分内容被绘制，就会出现画面撕裂，屏幕中一部分是上一帧内容，一部分是当前帧内容。垂直空白是指屏幕呈现完上一帧与开始呈现下一帧的间隔时间。等待垂直空白期间交换缓冲区，称为垂直同步。开启垂直同步时，屏幕刷新率一定是帧率的整数倍，因此垂直同步也是另一种控制帧率的方法。

计算$\Delta t$时可能会遇到两个问题：

- 每个CPU核心可能拥有独立的时间寄存器，导致多线程程序$\Delta t$计算出错
- 当程序遇到断点时会暂停，然后CPU时钟一直在增加，当程序继续运行时，$\Delta t$会非常大，解决方法是当$\Delta t$很大时（比如超过$1$秒），将其设置为$1/60$秒。

## Multiprocessor Game Loops

### Task Decomposition

​	为了利用并行硬件，我们需要将大量的任务分解为一个个小任务。并行的方式有任务并行和数据并行两种，任务并行适合解决多种不同的问题，数据并行适合解决大量数据执行相同的运算。

### One Thread per Subsystem

​	每个子系统占据一个线程，主线程用来控制和同步子系统线程，主线程可以同时做一些逻辑运算。显然该方法不是最好的，存在的问题有：

- 子系统数量与CPU核心的数量不相等，会导致有的核心空闲或者有的核心必须分时
- 不同子系统所需的执行时间不同，最慢的子系统会拖累所有子系统
- 子系统之间有数据依赖关系，比如动画、物理和碰撞子系统执行完毕之前，渲染子系统不能执行

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221101134316704.png" alt="image-20221101134316704" style="zoom:80%;" />

### Scatter/Gather

​	当我们绘制一帧时，许多任务都是数据密集的。比如要做$9000$次光线投射，我们将任务分解为$6$组$1500$次的光线投射，然后将结果组合起来。一般情况下，主线程启动$m$个工作线程，为每个线程提供起点索引和数量。

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221101134914842.png" alt="image-20221101134914842" style="zoom:80%;" />

​	这种方法的问题在于：启动一个线程和`join`一个线程是非常耗时的操作，包含系统调用。我们可以用线程池来解决该问题，线程池里包含预生成的线程。由于我们要在主循环中执行多次分散与组合，我们希望线程池里的每个线程不仅仅只是执行一个设定好的功能，而是能适配不同的任务。虽然可以用一个`switch case`来解决，但很蠢。我们希望有一个通用的系统，可以并行执行提交的各种工作，将工作分配到空闲的CPU核心上。

# Foudations of Animation

## Properties of rigid bodies

​	为了模拟刚体，我们需要计算刚体的质心和转动惯量

### Center of mass

​	计算质心是为了确保物体再模型坐标系下的原点与质心重合。假设物体的质量均匀分布在各个方向，可将物体的质心定义为：
$$
\mathbf{c}=\frac{\int_V{\rho(\mathbf{x})\mathbf{x}}dV}{\int_V{\rho(\mathbf{x})}dV}
$$
​	如果我们假设物体由质点组成，则显然有：
$$
\mathbf{c} = \frac{\sum{m_i\mathbf{x}_i}}{\sum{m_i}}
$$
介绍两种计算质心的方法：

- **体素化**：**假设物体的密度为常数**，将物体划分为体素，虚拟一个位于体素中心的质点，假设物体是由所有位于物体内部的质点组成，并且所有质点的质量相同，则有：
  $$
  \mathbf{c}=\frac{1}{m}\sum{\mathbf{x}_i}
  $$
  判断某点是否位于物体内部的一般方法是：从该点向任意方向发射一条射线，若射线与物体表面产生的交点个数为奇数，则该点位于物体内部，反之，位于物体外部。由于所有体素网格都是规则的立方体，我们可以大大简化这一过程。具体方法如下：从包围体的外部，沿着坐标轴方向，过体素中心射出一条射线，当射线第一次与物体表面相交时，所有经过的点都位于物体外部，当射线第二次与物体表面相交时，两个交点间的所有点都位于物体内部，以此类推。

  显然这是一种估计的方法，体素越小，估计越准。

- **直接计算**：**假设物体的密度为常数，且由三角面构成**。选择任意一点（通常为原点），该点与任意三角形面可构成一个四面体，四面体的体积和质心很好计算。计算物体的每个三角面与该点构成的每个四面体的体积和质心，将质心按体积比加权即可得到物体的质心。假设该点为原点，逆时针顺序的三角形顶点坐标分别为$\mathbf{d}$、$\mathbf{e}$、$\mathbf{f}$，则四面体的体积为：
  $$
  V=\frac{1}{6}\mathbf{d}\cdot\left(\mathbf{e}\times\mathbf{f}\right)
  $$
  四面体的质心为：
  $$
  \mathbf{x}=\frac{1}{4}(\mathbf{d}+\mathbf{e}+\mathbf{f})
  $$

### Moment of Inertia

​	将物体的质心置于原点后，物体的惯性矩阵计算公式为：
$$
I=\left[\begin{array}{lll}
\int_V\left(\mathbf{x}_y^2+\mathbf{x}_z^2\right) \rho(\mathbf{x}) d V & -\int_V\left(\mathbf{x}_x \mathbf{x}_y\right) \rho(\mathbf{x}) d V & -\int_V\left(\mathbf{x}_x \mathbf{x}_z\right) \rho(\mathbf{x}) d V \\
-\int_V\left(\mathbf{x}_x \mathbf{x}_y\right) \rho(\mathbf{x}) d V & \int_V\left(\mathbf{x}_x^2+\mathbf{x}_z^2\right) \rho(\mathbf{x}) d V & -\int_V\left(\mathbf{x}_y \mathbf{x}_z\right) \rho(\mathbf{x}) d V \\
-\int_V\left(\mathbf{x}_x \mathbf{x}_z\right) \rho(\mathbf{x}) d V & -\int_V\left(\mathbf{x}_y \mathbf{x}_z\right) \rho(\mathbf{x}) d V & \int_V\left(\mathbf{x}_x^2+\mathbf{x}_y^2\right) \rho(\mathbf{x}) d V
\end{array}\right]
$$
同理，一般将密度视为常数（$1$），注意该矩阵是对称矩阵，实际只需要算$6$个元素。

​	假设物体是由质点组成，则惯性矩阵的计算公式为：
$$
I=\left[\begin{array}{ccc}
\sum\left(y_i^2+z_i^2\right) m_i & -\sum\left(x_i y_i\right) m_i & -\sum\left(x_i z_i\right) m_i \\
-\sum\left(x_i y_i\right) m_i & \sum\left(x_i^2+z_i^2\right) m_i & -\sum\left(y_i z_i\right) m_i \\
-\sum\left(x_i z_i\right) m_i & -\sum\left(y_i z_i\right) m_i & \sum\left(x_i^2+y_i^2\right) m_i
\end{array}\right]
$$
同理，实践中一般有两种计算惯性矩阵的方法：

- **体素化**：与计算质心的方法一样，当我们获取到所有位于物体内部的质点后，带入上式即可，注意这里还有质量，由于每个质点质量相等，可以把质量提到矩阵外面

- **直接计算**：思路与计算质心一样，首先将三角面组成的物体划分为四面体，分别计算每个四面体的贡献，最后将它们组合起来。然而计算四面体的贡献比计算质心时要复杂很多。由于每个四面体原本都要在其模型坐标系下计算惯性矩阵，必须利用平行移轴定理计算关于刚体总体的局部坐标系的惯性矩阵。

  > Eberly [2003]

​	某些规则的刚体可以直接用公式计算其惯性矩阵，比如：

球体：
$$
I=\left[\begin{array}{ccc}
\frac{2}{5} m r^2 & 0 & 0 \\
0 & \frac{2}{5} m r^2 & 0 \\
0 & 0 & \frac{2}{5} m r^2
\end{array}\right]
$$
长方体：
$$
I=\left[\begin{array}{ccc}
\frac{m}{12}\left(l_y^2+l_z^2\right) & 0 & 0 \\
0 & \frac{m}{12}\left(l_x^2+l_z^2\right) & 0 \\
0 & 0 & \frac{m}{12}\left(l_x^2+l_y^2\right)
\end{array}\right]
$$
**世界坐标系下的惯性矩阵**：由于物体朝向的改变，世界坐标系下的惯性矩阵会发生变化。假设模型坐标系下物体的惯性矩阵为$I_0$，物体在世界坐标系下的朝向为$R$，则物体在世界坐标系下的惯性矩阵$I$为：
$$
I=RI_0R^T
$$
我们经常会求惯性矩阵的逆$I^{-1}$：
$$
I^{-1}=RI_0^{-1}R^T
$$

# C++ Primer

- 派生类必须通过**类派生列表**指明它的基类。`class B: public A, private C {};`
- 如果一个基类由`public`派生，则基类的公有成员也是派生类的公有成员，还可以将派生类对象绑定到基类对象
- 如果派生类没有覆盖其基类的某个`virtual`函数，则派生类会直接继承其在基类中的版本
- 编译器会隐式地执行派生类到基类的转换
- 一般情况下，派生类不允许直接初始化从基类继承的成员，必须使用基类的构造函数初始化
- 派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化的
- 基类部分会首先被初始化，然后再按照定义顺序初始化派生类的成员
- 派生类的作用域嵌套在基类的作用域之内
- 类中的每个静态成员都只存在唯一的实例
- 如果某基类的静态成员是可访问的，则既能通过基类访问，也能通过派生类访问
- 如果想将某个类作为基类，则该类必须已经被定义而不仅是被声明。（为什么？）
- 可以使用`final`关键字定义一个不能被继承的类`class Base final {};`

# Vulkan Tutorial

## Image Layout transitions

​	创建完image之后，需要执行`vkCmdCopyBufferToImage`将图像数据从staging buffer拷贝到image memory中，但这个函数对image的布局有要求，因此，需要先转换image的布局。最简单的方法是使用image内存”屏障“，`VkImageMemoryBarrier`定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkImageMemoryBarrier {
	VkStructureType            sType;
	const void*                pNext;
	VkAccessFlags              srcAccessMask;
	VkAccessFlags              dstAccessMask;
	VkImageLayout              oldLayout;
	VkImageLayout              newLayout;
	uint32_t                   srcQueueFamilyIndex;
	uint32_t                   dstQueueFamilyIndex;
	VkImage                    image;
	VkImageSubresourceRange    subresourceRange;
} VkImageMemoryBarrier;
```

`QueueFamilyIndex`是用来转移image的拥有权的，如果你只是用来转换布局，必须将之置为`VK_QUEUE_FAMILY_IGNORED`。`subresourceRange`用于指定image中受到影响的部分。

### Copying buffer to image

​	布局转换完成后，需要填充`VkBufferImageCopy`结构，具体定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkBufferImageCopy {
	VkDeviceSize                bufferOffset;
	uint32_t                    bufferRowLength;
	uint32_t                    bufferImageHeight;
	VkImageSubresourceLayers    imageSubresource;
	VkOffset3D                  imageOffset;
	VkExtent3D                  imageExtent;
} VkBufferImageCopy;
```

​	`bufferOffset`指定数据在buffer中的偏移量，`bufferRowLength`和`bufferImageHeight`用于描述像素在内存中的布局方式，都置为$0$表示像素紧密排列，没有填充数据。`image...`描述我们要将像素复制到图像的哪个部分。

​	拷贝完成之后，为了能在shader中快速的对纹理进行采样，我们还需要转换image的布局。
