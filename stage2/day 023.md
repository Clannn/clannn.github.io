# Game Engine Architecture

## The Resource Manager

​	资源管理器由两个组件构成，其中一个是离线工具链，用于创建资源并将其转换为引擎可用的格式。另一个组件用于管理运行时的资源，确保它们在使用之前已经被导入内存，以及不需要时从内存中卸载。

​	在某些引擎中，资源管理器是一个单独的子系统，另外有些引擎，资源管理分散在各个不同的子系统中。

### 离线资源管理器以及工具链

1. Assets版本控制

   有些团队使用源码版本控制系统（比如git）来管理离线的assets。此方法最大的问题在于，数据量巨大。因为许多版本控制系统都需要将文件从中央repository拷贝到本地机器上。有些版本控制系统专门处理非常大的数据量（比如Alienbrain）。如果硬盘和网络带宽非常大，也可以减少拷贝和上传所造成的问题。有些团队在版本控制的基础上做了更复杂的设计，只同步那些真正需要的资源。

2. 资源数据管理

   引擎中使用的大部分assets都不是它们原生的数据格式，这些assets需要被转换为二进制文件以供引擎使用，这个转换工具叫做资产调节管线。**对于需要通过资产调节管线的资源，需要一些`metadata`来描述资源应该如何被处理**。比如纹理压缩时，我们需要知道对于特定的图片类型，最适合哪种压缩方式。当导出一段动画时，我们需要知道导出的帧范围。我们需要管理所有资源及其metadata。在某些引擎中，特定资源的metadata可能被直接嵌入到资源本身（比如Maya）。或者每个资源文件都附带一个包含metadata的文件。管理器应该包含以下功能：

   - 以某种一致的方式处理各种类型的资源
   - 创建/删除资源
   - 查看和修改现有资源
   - 将资源文件从一个位置移动到另一个位置
   - 正确处理和维护资源的交叉引用
   - 日志
   - 搜索和查询

### 运行时资源管理

1. 运行时资源管理的责任

   运行时资源管理所负责的事情几乎都与资源加载到内存有关：

   - 确保任何资源在任意时刻，在内存中最多仅有一个副本。确保资源存储在内存中适当的位置
   - 管理每个资源的生命周期
   - 处理复合资源的加载，比如一个3D模型是由网格、多种材质、多种纹理、和多个骨头组成
   - 正确处理资源之间的交叉引用
   - 允许加载资源后对每个资源类型执行自定义处理，称为加载初始化
   - 提供统一的接口处理各种资源类型，同时满足接口的易扩展性
   - 异步加载资源（流）

2. 资源文件

   当从文件中加载数据时，包括三个非常耗时的操作：1. 寻道时间（SSD没有这个问题）；2. 打开文件；3. 将数据加载进内存。有些引擎将所有资源打包成一个文件，所有数据都顺序存储在硬盘中，降低寻道时间。不需要在打开单独的资源文件，避免打开文件的时间。一般可以用`zip`打包所有数据，`zip`的主要优点有：打包后也能通过文件的相对地址访问它们；数据压缩；模块化。

   Unreal中，所有资源都必须打包进被称为包（`pak`）的大型复合文件中，通过编辑器管理包以及其中的资源

3. 资源文件格式

   每个类型的资源都可能有不同的文件格式，每个引擎都可能有自己的一套文件格式。不管怎样，要**最大限度地减少运行时加载和处理资源数据所需的时间**。

# Rigid Body Simulation

## 刚体基本概念

​	如果$\mathbf{a}$、$\mathbf{b}$都是三维向量，则$\mathbf{a}\times\mathbf{b}$可以表示为：
$$
\mathbf{a}\times\mathbf{b}=\left( \begin{matrix}
0 & -a_z & a_y \\
a_z & 0 & -a_x \\
-a_y & a_x & 0 \\
\end{matrix}\right)\left( \begin{matrix}
b_x \\
b_y \\
b_z \\
\end{matrix}\right)
$$
因此，$\dot{R}(t)$可以表示为：
$$
\begin{align}
\dot{R}(t)&=\left( \begin{matrix}
\mathbf{\omega}(t)\times\left( \begin{matrix}r_{xx} \\ r_{xy} \\ r_{xz}\end{matrix}\right) &
\mathbf{\omega}(t)\times\left( \begin{matrix}r_{yx} \\ r_{yy} \\ r_{yz}\end{matrix}\right) &
\mathbf{\omega}(t)\times\left( \begin{matrix}r_{zx} \\ r_{zy} \\ r_{zz}\end{matrix}\right)
\end{matrix}\right)\\
&=\left( \begin{matrix}
\mathbf{\omega}(t)^*\left( \begin{matrix}r_{xx} \\ r_{xy} \\ r_{xz}\end{matrix}\right) &
\mathbf{\omega}(t)^*\left( \begin{matrix}r_{yx} \\ r_{yy} \\ r_{yz}\end{matrix}\right) &
\mathbf{\omega}(t)^*\left( \begin{matrix}r_{zx} \\ r_{zy} \\ r_{zz}\end{matrix}\right)
\end{matrix}\right)\\
&=\mathbf{\omega}(t)^*R(t)
\end{align}
$$

# C++ Primer

- 重载输入运算符必须处理输入可能失败的情况，而输出运算符不需要
- 前置自增/自减运算符返回对象的引用，后置返回非引用
- 前置和后置声明的区别是：`T& operator++()`与`T operator++(int)`
- lambda是一个函数对象，当我们编写一个lambda之后，编译器将该表达式翻译成一个未命名类的未命名对象
- lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数
- 当lambda通过引用捕获变量时，由程序负责保证执行时所引的对象确实存在，因此编译器可以直接使用该引用
- 标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的模板类![image-20221024170012776](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221024170012776.png)

- c++的可调用对象有：函数、函数指针、lambda表达式、重载调用运算符的类对象、<u>bind创建的对象</u>
- 不同的可调用对象可以共享同一种**调用形式**，即使它们是不同的类型

# Vulkan Tutorial

## Vertex input description

​	当顶点数据上载到显存之后，我们需要告诉GPU这些数据的“格式”。首先需要用到`VkVertexInputBindingDescription`，定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkVertexInputBindingDescription {
    uint32_t             binding;
    uint32_t             stride;
    VkVertexInputRate    inputRate;
} VkVertexInputBindingDescription;
```

一个binding描述了逐顶点还是逐实例，以及每个顶点/实例所占据的字节数。由于我们的所有顶点都在一个数组中，因此只需要一个binding，`binding`成员用于指定描述的binding在binding数组中的索引。`inputRate`用于描述逐顶点还是逐实例。

​	之后我们需要一个结构体`VkVertexInputAttributeDescription`来描述顶点属性，具体定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkVertexInputAttributeDescription {
	uint32_t    location;
	uint32_t    binding;
	VkFormat    format;
	uint32_t    offset;
} VkVertexInputAttributeDescription;
```

一个顶点属性结构体对应一个顶点属性，指明了如何从某binding描述的一个顶点/实例中提取出一个属性。`binding`用于指定哪个binding，`location`与vertex shader中的`location`对应，`offset`表示该属性开始的字节数，`format`用于描述该属性的数据类型，也隐式的指定了属性的字节大小，`format`常用的值有：

- `float`：`VK_FORMAT_R32_SFLOAT`
- `vec2`： `VK_FORMAT_R32G32_SFLOAT`
- `vec3`：`VK_FORMAT_R32G32B32_SFLOAT`
- `vec4`：`VK_FORMAT_R32G32B32A32_SFLOAT`

​	记得把顶点输入的描述添加到图形管线的顶点输入中。

## Vertex buffer creation

​	虽然我们已经描述好了整个binding，但是没有vertex buffer绑定它，意味着我们的顶点数据还无法上载到GPU。**Vulkan中的缓冲区是指显卡可读的内存区域**，并且缓冲区不会自动地分配内存。创建一个缓冲区需要填充`VkBufferCreateInfo`结构体，具体定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkBufferCreateInfo {
	VkStructureType          sType;
	const void*              pNext;
	VkBufferCreateFlags      flags;
	VkDeviceSize             size;
	VkBufferUsageFlags       usage;
	VkSharingMode            sharingMode;
	uint32_t                 queueFamilyIndexCount;
	const uint32_t*          pQueueFamilyIndices;
} VkBufferCreateInfo;
```

`size`用于指定缓冲区的字节大小，`usage`指定缓冲区中的数据将用于何种目的，可以用或运算指定多个用途。与交换链中的图像一样，vertex buffer也可能被多个queue family共享，需要通过`sharingMode`指定共享模式。当前，显然vertex buffer只会被graphics queue所使用。

​	**即使缓冲区创建完成了，它也没有实际分配内存**。首先需要通过`vkGetBufferMemoryRequirements`来获取缓冲区的内存需求。`VkMemoryRequirements`拥有三个字段：

- `size`：所需的内存空间（字节）
- `alignment`：内存对齐，取决于创建缓冲区时指定的`usage`与`flags`
- `memoryTypeBits`：适合缓冲区的内存类型

显卡可以提供不同类型的内存进行分配，每种类型的内存允许的操作和性能方便有所不同。因此，我们需要找到适合的内存类型。`VkPhysicalDeviceMemoryProperties`结构体有两个数组字段`memoryTypes`和`memoryHeaps`，`memoryHeap`用于区分专用显存还是内存中的共享GPU内存。

​	我们还需要将顶点数据写入对应的显存中，因此，CPU必须要能映射这块内存。`VkMemoryType`有一些属性定义了这些特殊功能。

​	现在我们可以填充`VkMemoryAllocateInfo`来真正的分配显存，具体定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkMemoryAllocateInfo {
	VkStructureType    sType;
	const void*        pNext;
	VkDeviceSize       allocationSize;
	uint32_t           memoryTypeIndex;
} VkMemoryAllocateInfo;
```

只需要指定内存的大小以及类型即可。分配显存后再调用`vkBindBufferMemory`将显存与缓冲区绑定，最后再将顶点数据拷贝到显存中即可。

​	现在我们已经将顶点数据上载到显存，最后只需要在渲染过程中绑定顶点缓冲区即可。