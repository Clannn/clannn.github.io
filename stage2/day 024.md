# Game Engine Architecture

## The Resource Manager

### Runtime Resource management

4. Resource GUIDs

   游戏中的每个资源都必须拥有一个全局唯一标识，最常见的方法是文件路径的字符串哈希值。但是，为了提高加载资源的速度，大部分引擎都将所有资源打包进一个文件中，比如Unreal的`pkg`文件。它的解决方法是：包内的文件也组织成虚拟的文件夹层次结构，并且每个资源拥有不同的文件名，GUID就是包名与包内虚拟路径的组合。

5. The Resource Registry

   为了确保任意时刻任一资源在内存中最多只有一个副本，资源管理器应该维护一个已加载资源的注册表。通常使用`map`来实现，`key`对应GUID，`value`对应内存地址。有一个非常直观的想法是，当某资源被请求且注册表中没有该资源时，自动地将该资源上载到内存。这里有一个严重地问题，上载资源是一个非常耗时地操作（寻道、打开文件、上载），可能会导致帧数骤降甚至卡住。有两个方法解决该问题：

   1. 某关卡开始之前，加载该关卡所有资源，不允许在交互过程中加载资源
   2. 异步加载资源，需要处理资源未加载完毕时，屏幕上应该显示的内容

6. Resource Lifetime

   可以自动管理资源的生命周期，也可以在游戏中提供一个API手动调用。不同的资源有不同的生命周期需求：

   - 全局资源需要在游戏开始时就被加载进内存，在游戏结束时才能被回收。比如玩家角色相关的资源、字体等
   - 某些资源的生命周期与特定关卡相匹配，需要在关卡开始和结束时加载和卸载
   - 某些资源的生命周期比关卡还短，比如特定的动画、音效
   - 背景音乐、环境音乐这种类型的资源，虽然存在于整个游戏的生命周期，但是一小段时间内只需要一小部分。因此可以一"块"一“块”地读取这种资源，内存中只同时存在两"块"。一块正在播放、一块正在加载

   每个资源都维护一个引用计数，可以在切换关卡时进行内存资源的回收。

7. Memory Management for Resources

   资源管理与内存管理息息相关，因为加载资源时，我们必须决定资源应该在内存中的什么位置。某些资源必须在显存中，比如纹理、着色器代码、vertex buffers、index buffers。大多数其他资源可以驻留在主存中。任何资源管理器面临的主要问题之一是避免产生内存碎片，下面是一些常见的解决方法：

   ***Heap-Based Resource Allocation***

   如果只打算将游戏运行在支持虚拟内存的计算机上，那么可以使用通用的堆内存分配（`malloc`或`new`）。虽然物理内存会被碎片化，但操作系统能把不连续的页面映射到连续的虚拟地址。主机不保证支持虚拟内存

   ***Stack-Based Resource Allocation***

   如果满足以下两个条件，则可以在加载资源时使用栈分配器：

   - 游戏是线性的，并且以关卡为中心
   - 每个关卡的资源一次性载入内存

   游戏开始时首先加载全局资源，在加载下一个关卡之前释放当前关卡。可以扩展成一个双端的栈，一端用于加载关卡，另一端用于分配每帧刷新的临时内存。或者一端保存当前关卡，另一端保存下一关卡的压缩文件，这样能减少关卡的加载时间。

   ***Pool-Based Resource Allocation***

   在支持异步加载的引擎中，**将资源数据加载到相同大小的块中**是比较常见的一种分配方式。当资源释放时，释放整块内存，这样也不会产生内存碎片。这要求**比较大的资源能被划分成相同大小的块进行存储**，对于大型数组或大型结构体来说比较困难。

   分配池中的每个块通常都与特定的游戏关卡相关联（为每个关卡提供其块列表的头节点），这样引擎可以管理每个块的生命周期，即使这些块位于具有不同生命周期的关卡中。

   ![image-20221025135509992](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221025135509992.png)

   **块分配有一个比较大的代价是浪费内存空间**，无论多小的文件最少占据一个块。块的大小最好是I/O缓冲区大小的整数倍，这样能以最高的效率加载单个块。

   ***Resource Chunk Allocators***

   我们可以设置一个特殊的内存分配器，它专门分配一个“块”中未使用的内存。这样可以减少块分配浪费的空间。我们需要维护一个链表，这个链表包含所有没有完全使用的块，保存其中每个块的空闲位置和大小。每当特定关卡有内存请求时，扫描对应关卡中所有未完全使用的块，找到合适的内存分配它。

   ***Sectioned Resource Files***

   一个资源文件通常可能包含$1$到$4$个部分，每个部分又被分为一个或多个块。不同的部分有不同的属性，比如：应该分配到主存还是显存、临时数据等。Granny SDK的文件系统可以简单灵活的实现文件分段。

# Foundations of Animation

## Rigid Body Dynamics

### Rigid Body State

​	当我们表示一个粒子的状态时，我们只需要粒子的位置$\mathbf{x}$和速度$\mathbf{v}$。利用状态对时间的导数来更新下一时刻的状态。

​	为了表示刚体的状态，首先我们需要追踪物体的质心$\mathbf{x}$以及质心的速度$\mathbf{v}$，这部分和粒子一样。除此之外，刚体具有**朝向**，即物体绕其质心旋转的方式。目前我们用一个旋转矩阵$R$来表示物体的朝向。

​	假设每个物体都是在模型坐标系中描述的，这个坐标系以物体的质心为原点，有一个初始朝向。我们模拟的每个物体，都会被转换到世界坐标系下，刚体的朝向和刚体质心的位置就定义了从模型坐标转换到世界坐标的方式：
$$
\mathbf{p} = \mathbf{x}+R\mathbf{p}_0
$$
​	为了更新物体的状态，我们需要对刚体的质心位置进对时间进行求导，即：
$$
\dot{\mathbf{p}} = \dot{\mathbf{x}}+R\dot{\mathbf{p}}_0+\dot{R}\mathbf{p}_0
$$
注意$\mathbf{p}_0$是模型坐标系下的某一点，不会随时间改变，即$\dot{\mathbf{p}}_0=0$，因此有：
$$
\dot{\mathbf{p}}=\dot{\mathbf{x}}+\dot{R}\mathbf{p}_0=\mathbf{v}+\dot{R}\mathbf{p}_0
$$
​	其中还有一个未知量，是朝向随时间的变化率。为了理解朝向如何随时间变换，我们需要引入角速度的概念。就像线速度是用来描述位置随时间的变换量，**角速度是用来描述朝向随时间的变化量**，一般用希腊字母$\boldsymbol{\omega}$表示。角速度也是三维向量，但角速度的方向并不是物体运动方向，而是旋转轴的方向。角速度的模表示旋转的速度，一般是弧度/秒。

​	由于模型坐标系的原点就是物体的质心，**则矩阵$R$的三个列向量分别表示模型坐标系的$\mathbf{x}$、$\mathbf{y}$、$\mathbf{z}$轴在世界坐标系下的方向**，即：
$$
R=\left[ \begin{matrix} \hat{\mathbf{u}}_x & \hat{\mathbf{u}}_y & \hat{\mathbf{u}}_z \end{matrix} \right]\\
\dot{R}=\left[ \begin{matrix} \dot{\hat{\mathbf{u}}}_x & \dot{\hat{\mathbf{u}}}_y & \dot{\hat{\mathbf{u}}}_z \end{matrix} \right]
$$
现在，**确定旋转矩阵$R$随时间的变换量就只需要确定一个向量在刚性旋转下随时间的变化量**。

​	首先考虑一个点$\mathbf{p}$在角速度$\boldsymbol{\omega}$的影响下如何随时间变化，假设旋转中心为$\mathbf{x}$，如下图所示：

![image-20221025153028622](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221025153028622.png)

**$\mathbf{p}$点在$\boldsymbol{\omega}$的作用下产生的瞬时速度必须同时垂直于$\mathbf{r}$和$\boldsymbol{\omega}$，否则$\mathbf{r}$的模长就会发生变化**，因此，$\mathbf{p}$点的速度方向与$\boldsymbol{\omega}\times\mathbf{r}$平行。由于$\mathbf{p}$点的旋转半径为$b=||\mathbf{r}||sin\phi$，则$\mathbf{p}$点的速度大小为$||\boldsymbol{\omega}||b=||\boldsymbol{\omega}\times\mathbf{r}||$。则：
$$
\dot{\mathbf{r}}=\boldsymbol{\omega}\times\mathbf{r}
$$
把这个结论用在旋转矩阵$R$上可得：
$$
\dot{R}=\left[ \begin{matrix} \boldsymbol{\omega}\times\hat{\mathbf{u}}_x & \boldsymbol{\omega}\times\hat{\mathbf{u}}_y & \boldsymbol{\omega}\times\hat{\mathbf{u}}_z \end{matrix} \right]
$$
这种形式不太适合计算，幸运的是，可以把向量叉乘写成矩阵形式：
$$
\mathbf{a}\times\mathbf{b}=a^*\mathbf{b}
$$
其中，
$$
\mathbf{a}^*=\left[ \begin{matrix}
0 & -a_z & a_y \\
a_z & 0 & -a_x \\
-a_y & a_x & 0 \\
\end{matrix}\right]
$$
因此，旋转矩阵$R$随时间的导数为：
$$
\dot{R}=\omega^*R
$$
​	至此，我们已经可以求出质心位置$\mathbf{x}$、线速度$\mathbf{v}$和朝向$R$随时间的变化率，还需要求出角速度$\boldsymbol{\omega}$随时间的变化率。为了求出角速度随时间的变化率，需要引入“惯性”$I$。与动量$\mathbf{P}=m\mathbf{v}$相似，角动量$\mathbf{L}$定义为：$\mathbf{L}=I\boldsymbol{\omega}$。惯性张量$I$是一个$3\times3$的矩阵，描述了质量在物体中的分布。如果角速度的方向改变，角动量可能会发生非常大的改变。

​	可以总结出与刚体平移和旋转相关的物理量：

![image-20221025163524600](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221025163524600.png)

# C++ Primer

- 只有一个实参的构造函数定义了一种隐式类型转换，可以将实参类型转换为类类型
- 可以定义类型转换运算符`operator type()const`，可以将类类型转换为`type`类型
- 不允许将类类型转换为数组或函数类型
- 类型转换运算符没有显式的返回类型和形参，必须定义为成员函数
- 类型转换运算符也应该定义为`explicit`，防止编译器做隐式转换
- 当表达式作为条件语句时，显式的类型转换运算符也可以隐式地执行
- 尽可能避免类型转换的二义性，尽可能不要定义类型转换
- OOP的核心思想是数据抽象（封装）、继承和动态绑定（多态）
- 基类将类型相关的函数与派生类不做改变直接继承的函数区分对待，对于某些函数，基类希望它的派生类各自定义适合的版本，此时基类就应该将这些函数声明为虚函数`virtual`
- 派生类必须在其内部对所有**重新定义**的虚函数进行声明，此时`virtual`关键字是可选的，形参列表后应该加上`override`关键字
- 使用基类的引用（或指针）调用一个虚函数时将发生动态绑定
- 基类通常会定义一个虚析构函数，即使该函数不执行任何操作
- 基类希望派生类覆盖的函数通常定义为虚函数，任何除构造函数之外的非静态函数都可以是虚函数
- `virtual`只能出现在函数声明的时候，该函数在派生类中隐式的也是虚函数
- 如果成员函数没被声明为虚函数，则其解析过程发生在编译时
- 派生类继承基类中的所有成员，但只能访问`public`和`protected`成员，不能访问`private`成员

# Vulkan Tutorial

## Staging buffer

​	之前在选择vertex buffer的内存类型时，要求CPU能够映射到那块内存，但这对GPU来说不是很好的选择。最优的选择是`VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`，但这对于CPU来说通常是不可访问的。我们创建一个CPU可访问的暂存缓冲区，将顶点数据写进去，然后使用buffer copy命令将暂存缓冲区中的数据拷贝到显存中。

​	拷贝缓冲区的命令需要提交到支持传输操作的队列，好消息是图形队列和计算队列隐式的支持内存传输操作，因此暂时不需要寻找一个新的队列族。

​	需要注意的是，不应该为每个单独的缓冲区都调用一次`vkAllocateMemory`，这样会降低性能。一次分配大块内存，并使用`offset`区分不同的缓冲区。
