# 游戏引擎架构

## 线程同步原语

### 临界区

​	互斥锁是一个由内核管理的数据结构，在互斥锁上执行的所有操作都涉及内核调用，这使得互斥锁非常昂贵。Windows提供了一个低成本的互斥锁，称为临界区。临界区的API如下所示：

- `InitializeCriticalSection()`：构建一个临界区对象
- `DeleteCriticalSection()`：销毁初始化的临界区对象
- `EnterCriticalSection()`：调用线程锁定临界区，如果临界区当前被另一个线程持有，则阻塞调用线程
- `TryEnterCriticalSection()`：尝试锁定临界区，如果无法获取则立即返回
- `LeaveCriticalSection()`：释放临界区

​	当一个线程第一个尝试进入一个已经被锁定的临界区时，使用**自旋锁**来等待，直到另一个线程离开临界区。自旋锁不涉及内核上下文切换。只有当线程忙等待的时间过长时，线程才会阻塞。这种方法有效的原因是：**临界区不能跨进程共享，而互斥锁可以**。

### 条件变量

​	我们经常需要在线程之间发送信号，以便同步它们的活动。在生产者-消费者问题中，如果消费者以轮询的方式检查是否有生产出的数据，那将非常浪费CPU。我们希望生产者在工作时阻塞消费者线程，然后在数据准备好时将其唤醒。可以通过被称为条件变量的内核对象来实现。

​	条件变量是一个队列，它包含被特定条件阻塞的线程，允许运行的线程在满足条件的时候唤醒被阻塞的线程。阻塞和唤醒一定是原子操作。条件变量的API一般包含：

- `create() or init()`：创建条件变量的函数或构造函数
- `destroy()`：销毁条件变量的函数或析构函数
- `wait()`：将调用该函数的线程阻塞
- `notify()`：唤醒正在等待条件变量的所有线程

使用条件变量的生产者-消费者程序可能如下所示：

```c++
Queue g_queue;
pthread_mutex_t g_mutex;
bool g_ready = false;
pthread_cond_t g_cv;

void Producer(){
    while(true){
        pthread_mutex_lock(&g_mutex);
        ProduceDataInto(&g_queue);
        g_ready = true;
        pthread_cond_signal(&g_cv);    //唤醒阻塞线程
        pthread_mutex_unlock(&g_mutex);
    }
}

void Consumer(){
    while(true){
        pthread_mutex_lock(&g_mutex);
        while(!g_ready){
            //阻塞当前线程，内核会释放它的互斥锁
			pthread_cond_wait(&g_cv, &g_mutex);
            //唤醒时内核保证当前线程拥有互斥锁
        }
        ConsumeDataFrom(&g_queue);
        g_ready = false;
        pthread_mutex_unlock(&g_mutex);
    }
}
```

**只有当使用条件变量时，才能阻塞持有互斥锁的线程，否则一定会导致死锁。**注意，需要用`while`来检查`g_ready`而不能用`if`的原因是：内核有时会虚假的唤醒线程，此时`g_ready`的值可能还不是`true`。

### 信号量

​	可以把信号量看成一种特殊的互斥锁，**它允许多个线程同时获取信号量，共享有限的资源**。如果某资源池最多可由$N$个线程访问，则可以创建一个信号量并将其计数器初始化为$N$。信号量的API主要包括：

- `init()`：初始化信号量，设置计数器的初始值
- `destroy()`：销毁信号量对象
- `take() or wait()`：如果信号量计数器大于$0$，则计数器减$1$并立即返回，否则阻塞调用线程直到信号量计数器大于$0$
- `give(), post() or signal()`：信号量计数器加$1$，如果调用`give`时存在等待该信号量的线程，则会唤醒一个线程

**互斥锁与二进制信号量**

​	如果信号量计数器的初始值为$1$，则被称为二进制信号量。它与互斥锁是不对等的，通常以完全不同的目的使用。两者的主要区别是：**互斥锁只能由锁定它的线程解锁，而二进制信号量可以由不同的线程“解锁”**。互斥锁使操作具有原子性，而**二进制信号量通常用于向另一个线程发送信号**。再次考虑生产者-消费者问题，我们可以设置两个二进制信号量，分别表示允许对缓冲区进行读和写的数量。主要代码如下所示：

```c++
sem_t g_semRead = 0;
sem_t g_semWrite = 1;

void Producer{
    //......
    sem_wait(&g_semWrite);
    ProduceDataToQueue(&g_queue);
    sem_post(&g_semRead);
    //....
}
void Consumer{
    //......
    sem_wait(&g_semRead);
    ConsumeDataFrom(&g_queue);
    sem_post(&g_semWrite);
    //....
}
```

​	信号量可以通过互斥锁和条件变量来实现，具体如下：

```c++
#include <pthread.h>
class Semaphore{
private:
    uint32_t m_count;
    pthread_mutex_t m_mutex;
    pthread_cond_t m_cv;
public:
    explicit Semaphore(uint32_t initialCount){
        m_count = initialCount;
        pthread_mutex_init(&m_mutex, nullptr);
        pthread_cond_init(&m_cv, nullptr);
    }
    void Take(){
        pthread_mutex_lock(&m_mutex);
        while (m_count == 0)
            pthread_cond_wait(&m_cv, &m_mutex);
        --m_count;
        pthread_mutex_unlock(&m_mutex);
    }
    void Give(){
        pthread_mutex_lock(&m_mutex);
        ++m_count;
        if (m_count == 1)
            pthread_cond_signal(&m_cv);
        pthread_mutex_unlock(&m_mutex);
    }
};
```

 <u>二进制信号量与条件变量的区别？</u>

## 基于锁的并发所存在的问题

​	即使所有共享数据的操作都被锁保护了，并发系统仍然可能出现问题。

# 基于物理的建模与动画

## 弹性网格

​	通过将网格中多边形模型的边替换成弹簧-物体-阻尼系统，我们便能构造一个弹性网格，如下图所示。为了保持模型形状的稳定性，还需要一些额外的支持。

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220930150736329.png" alt="image-20220930150736329" style="zoom:67%;" />

### 支撑杆——闭门器模型的三维扩展

​	我们将之前研究的模型扩展到三维，如下图所示，支撑杆两端连接这质点$m_i$和$m_j$，并且有三个关联的常数：$k_{ij}$表示弹簧刚度，$d_{ij}$表示阻尼强度，$l_{ij}^0$表示支撑杆的平衡长度。两个质点分别位于$x_i$、$x_j$，速度分别为$v_i$、$v_j$，距离为$l$。

![image-20220930152335078](C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20220930152335078.png)

支撑杆产生的力与$\hat{\mathbf{x}}_{ij}$对齐，并且只跟两个顶点的位置和速度有关。物体$i$收到的弹力为：
$$
\mathbf{f}_i^s=k_{ij}(l_{ij}-l_{ij}^0)\hat{\mathbf{x}}_{ij}
$$
根据牛顿第三定律，物体$j$收到的弹力为：
$$
\mathbf{f}_j^s=-\mathbf{f}_i^s
$$
​	阻尼器所产生的力源自于**对抗支撑杆长度变化速率时所产生的阻力**，它的大小取决于两个物体的速度差在支撑杆方向上的分量，即：$\left(\mathbf{v}_j-\mathbf{v}_i\right)\cdot\hat{\mathbf{x}}_{ij}$。因此，阻尼器作用于物体$i$上的力为：
$$
\mathbf{f}_i^d=d_{ij}\left[ \left( \mathbf{v}_j-\mathbf{v}_i \right)\cdot\hat{\mathbf{x}}_{ij} \right]\hat{\mathbf{x}}_{ij}
$$
根据牛顿第三定律，作用域物体$j$上的阻尼力为：
$$
\mathbf{f}_j^d = -\mathbf{f}_i^d
$$

### 用支撑杆构造一个弹性网格

​	想要将多边形网格转换成一个弹性网格，只需将两顶点间的每条边表示成一个支撑杆，其中支撑杆由顶点索引来标识，每个顶点由粒子表示，即可完成转换。一般情况下，每个支撑杆的平衡长度设置为原始网格中对应边的边长。可以用下图方式存储这些信息：

![image-20220930193258643](C:\Users\Clan\AppData\Roaming\Typora\typora-user-images\image-20220930193258643.png)

三个数组s、f、p分别存储弹性网格的支撑杆（边）、面、顶点粒子的相关信息。在处理空气阻力、扭转弹簧以及分配顶点质量时，如果保存每个支撑杆邻接的面以及每个面所有顶点的夹角，将会非常有用。

​	如果每个支撑杆都需要一个一致的弹性，那么弹簧和阻尼常数的选择应该基于标称长度为$L$的支撑杆的长度。从而，每个支撑杆的弹簧和阻尼常数都应该以$L/l_{ij}^0$成比例缩放。

### 空气阻力与风

​	跟单个粒子不同，弹性网格受到的空气阻力横跨每个多边形面，不仅仅作用在粒子上。考虑一面由弹性网格构成的旗子，如果风力仅作用于顶点粒子，那么粒子就只会沿着风的方向被推动，不会产生旗子摆动的效果。实际上，旗子的每个多边形面都应该被看成一个小翅膀，施加作用在多边形上的升力和拖拽力。这些力会随着面与风的朝向而变化，并且有一个垂直于风向的分量。

​	假设所有多边形都是三角形，$\mathbf{w}$为局部空气速度向量，$\mathbf{v}$为三角形的速度，则三角形中心穿过空气的相对速度为：$\mathbf{v}_r=\mathbf{v}-\mathbf{w}$。