# Vulkan编程指南

## 实例

​	通过创建一个实例来初始化Vulkan库，这个实例指定了一些驱动程序需要使用的应用程序信息。**创建一个实例需要指定：1. 应用程序信息（可选）；2. 需要使用的全局扩展；3. 需要使用的验证层。**全局扩展至少应该包含窗口系统相关的扩展。

​	创建Vulkan对象的函数参数的一般形式是：

- 一个包含创建信息的结构体
- 一个自定义的分配器回调函数
- 一个指向新对象句柄存储位置的指针
- 返回创建结果的状态码

## 验证层

​	验证层常被用来做以下工作：

- 检测参数值是否合法
- 追踪对象的创建和清除操作，发现资源泄漏问题
- 追踪调用来自的线程，检测是否线程安全
- 将API调用和调用的参数写入日志
- 追踪API调用进行分析和回放

​	Vulkan库本身没有提供任何内建的验证层，但LunarG的Vulkan SDK提供了一个非常不错的验证层实现。可以通过`VK_LAYER_KHRONOS_validation`来隐式地开启所有可用的校验层。

​	只开启校验层还不够，还需要添加`VK_EXT_debug_utils`扩展来获取调试信息。接受调试信息的回调函数的原型为：

```c++
static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback (
VkDebugUtilsMessageSeverityFlagBitsEXT       messageSeverity,
VkDebugUtilsMessageTypeFlagsEXT              messageType ,
const VkDebugUtilsMessengerCallbackDataEXT   ∗pCallbackData ,
void                                         ∗pUserData);
```

​	第一个参数指定了消息的级别，它可以是：

- `VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT`：诊断信息
- `VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT`：资源创建之类的信息
- `VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT`：警告信息
- `VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT`：不合法和可能造成崩溃的信息

​	这些值可以使用比较运算符来过滤。

​	第二个参数`messageType`可以是下面这些值：

- `VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT`：发生了一些与规范和性能无关的事件
- `VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT`：出现了违反规范的情况或发生了一个可能的错误
- `VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT`：进行了可能影响Vulkan性能的行为

​	第三个参数`pCallbackData`是一个指向`VkDebugUtilsMessengerCallbackDataEXT`结构体的指针，这一结构包含了下面这些非常重要的成员：

- `pMessage`：一个`NULL`结尾的包含调试信息的字符串
- `pObjects`：存储和消息有关的Vulkan对象句柄的数组
- `objectCount`：数组中对象的个数

​	最后一个参数是用来传递用户数据的指针。一般可以传递当前类对象

​	回调函数返回一个布尔值，用来表示引发验证层处理的Vulkan API调用是否应该被中断。通常情况都返回`VK_FALSE`。

​	然后我们需要创建一个名为`DebugMessenger`的对象，指明哪些类型和级别的消息会触发回调函数，指定用户定义的回调函数以及`pUserData`。

# 游戏引擎架构

## 隐式并行

### 延迟和吞吐量

​	流水线的延迟指的是处理完一条指令所需的时间。用变量$T$来表示延迟，对于有$N$个阶段的流水线而言：$T_{pipeline}=\sum_{i=0}^{N-1}T_i$

​	流水线的吞吐量（带宽）是指单位时间内能够处理的指令数量。**吞吐量是由流水线中最慢的阶段的延迟决定的。**吞吐量也可以看作频率$f$，即：$f=\frac{1}{max(T_i)}$

### 流水线深度

​	如果CPU每个流水线阶段所需的时间都不同，当某个阶段完成时，它还需要等待最长那个阶段完成才能处理新的内容。因此，**我们希望CPU中所有的流水线阶段都有大致相同的延迟。**CPU制造商应该在流水线深度与流水线延迟之间找到平衡点。有时CPU在一个新的时钟周期不能处理新的指令，这被称为“阻塞”。

### 指令依赖之数据依赖

​	阻塞是由指令之间的依赖关系引起的。比如：

```assembly
mul eax, 10                    ;;寄存器EAX中的内容乘以10
add eax, 7	                   ;;寄存器EAX中的内容加上
```

​	原本应该在两个时钟周期内将两条指令送到流水线中，但由于第二条指令需要用到第一条指令的结果。因此第二条指令必须在第一条指令运行结束后才能送进流水线。

​	这种指令间的依赖被称为数据依赖。一共有三种指令依赖：数据依赖、分支依赖、结构依赖。

#### 重排指令以减轻数据依赖

​	我们可以在CPU等待依赖指令时找一些其他的指令来执行。这可以通过重新排序程序中的指令来实现（不改变结果），在两个互相依赖的指令间处理不依赖它们的指令。这件事已经被编译器做了。现在的很多CPU也支持一种称为“乱序执行”的特性，这使它们能够动态地检测指令之间的数据依赖关系，并自动解析它们。编译器优化和“乱序执行”可能会在并发程序中产生bug。

### 指令依赖之分支依赖

​	当流水线CPU遇到条件分支指令（if，for等）时会发生什么？对于语句`return (b!=0?a/b:defaultVal);`，假设汇编代码为：

```assembly
	; 将默认值放入返回寄存器
	mov eax, [defaultVal]
	; 判断 b!= 0
	mov esi, [b]
	cmp esi, 0
	jz SkipDivision ; jump if equal to zero
	; 除法
	mov eax [a]
	cdq
	idiv esi
SkipDivision:
	ret
```

​	这里的`cmp`与`jz`指令互相依赖，只有等`cmp`指令执行完毕之后才能执行`jz`指令。

