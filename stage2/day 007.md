# 游戏引擎架构

## 操作系统基础

#### 线程优先级和关联性

​	虽然线程调度由内核负责，但程序员可以通过*优先级和关联性* 来影响线程调度。不同的操作系统提供不同数量的优先等级。Windows提供$6$种不同的优先级类别，每个类别又提供$7$种不同的优先级别。两个值组合产生$32$种不同的“基本优先级”。最简单的线程调度规则是：只要至少存在一个高优先级的就绪态线程，就不会调度低优先级线程。这个策略可行的原因是：大多数线程都在某个默认的优先级上创建。但显然这种策略会导致低优先级线程长时间无法运行。

​	<u>线程的关联性是指内核将线程锁定到某个特定的CPU核心上，或者在调度线程时优先选择一个或多个CPU核心</u>。

#### 线程局部存储

​	每个线程都有一个被称为线程局部存储（TLS）的私有内存块，允许线程追踪不应该与其他线程共享的数据。实际上，TLS内存块也是映射到进程的虚拟地址空间，对进程中的所有线程可见。操作系统提供一个系统调用来允许线程获取自己的TLS地址。

#### 线程调试

​	在VS中，线程窗口（*Threads Window*）用于实现线程调试。

### <u>Fibers</u>

​	有些操作系统提供了一种协作多任务机制：*Fibers*。Fibers很像线程，也表示机器语言指令流的运行实例，但Fibers不直接由内核调度，它运行在线程的上下文中，彼此协作调度。

### 用户级线程和协程

​	大多数操作线程的函数都涉及内核空间的上下文切换，这个操作很花时间。用户级线程是一个轻量的替代，用户级线程完全在用户空间实现，内核对它们一无所知。每个用户级线程都由一个普通的数据结构表示，该结构包含：线程ID、名字、执行上下文（CPU寄存器和调用栈中的内容）。用户级线程库提供了用于创建和销毁线程以及在线程之间切换的API。**每个用户级线程都在操作系统提供的“真正的”线程中运行**。

#### 协程

​	**协程是一种特殊类型的用户级线程，对于编写固有的异步程序非常有用**。当一个协程产生时，它的执行上下文被维护在内存中，下一次调用协程（被其他协程让步）时，它从停止的地方继续执行。两个协程间可以互相调用，如下所示：

```c++
Queue g_queue;
Coroutine void Produce()
{
    while(true){
		while(!g_queue.full()){
			CreateItemAndAddToQueue(g_queue);
        }
        YieldToCoroutine(Consume);
    }
}
Coroutine void Consume()
{
    while(true){
		while(!g_queue.empty()){
			ConsumeItemFromQueue(g_queue);
        }
        YieldToCoroutine(Produce);
    }
}
```

​	协程通常由Ruby，Lua等语言提供。c++ Boost库提供了协程实现。

#### 内核线程与用户线程

​	内核线程有两种不同的定义：

- 在Linux上，内核线程是内核本身创建的一种特殊线程，它只在CPU处于特权模式时运行。任何以特权模式运行的线程都是内核线程，任何以用户模式运行的线程都是用户线程
- 内核线程也指由内核调度的任何线程，使用这个定义，用户线程就是指由用户管理，不涉及内核控制流的用户级线程，例如协程。

## 并发编程

​	为了使一个软件具有并发资格，它必须涉及共享数据的多个读取器和写入器。并发系统中的多个控制流通常是半独立运行的，它们的计算是通过共享数据和“同步”组成的。并发可以采取多种形式，比如：进程内的多个线程并发；GPU上的数千个线程并发；多人游戏共享游戏状态等。

### 并发编程模型

​	并发线程通过两种基本的方式进行沟通：

- 消息传递。通过传递消息来共享数据并同步它们的活动。消息可以通过网络、管道以及进程之间传递。
- 共享内存。两个或多个线程能访问同一物理内存块，因此也就可以对该内存块中的任何数据进行操作。**只有当所有线程都具有所有CPU核心都能“看到”的物理内存块时，共享内存才有效**。单个进程下的不同线程“天然的”共享内存。

​	两种方法有各自的优缺点，共享内存是共享大量数据的最有效方式，因为不必复制这些数据在线程之间传输。但共享会带来许多同步问题，而消息传递更倾向于减少同步的负担。

# 基于物理的建模与动画

## 数值积分

#### 阻尼与稳定性

​	对于欧拉积分或者其他低阶的积分方法，如果要积分的系统中存在类似于正弦振荡的行为，就会有不稳定的问题。常用的解决方法是引入阻尼，类似于空气阻力降低粒子的动能。引入阻尼的正弦振荡方程可以写成：
$$
f(\mathbf{s})=\dot{\mathbf{s}}=
\left[
\begin{matrix}
\dot{\mathbf{x}}\\
\dot{\mathbf{v}}
\end{matrix}
\right]
=
\left[
\begin{matrix}
\mathbf{v}\\
-\omega^2\mathbf{x}-d\mathbf{v}
\end{matrix}
\right]
$$
其中，$d$是阻尼常数。引入阻尼可能并不符合实际情况，而且阻尼过大也会造成积分不稳定。

### 隐式积分

​	当下一个状态依赖于下一个状态本身时，就是一个隐式积分。最简单的隐式积分是隐式欧拉：
$$
\mathbf{S}^{[n+1]}=\mathbf{S}^{[n]}+\mathbf{F}(\mathbf{S}^{[n+1]})h
$$
通常情况，隐式积分是当前状态和未来状态的某种组合关系，我们可以把这个关系写作$\mathbf{G}(\mathbf{S}^{[n]}, \mathbf{S}^{[n+1]})=0$。以上式为例：$\mathbf{G}(\mathbf{S}^{[n]}, \mathbf{S}^{[n+1]})=\mathbf{S}^{[n+1]}-\mathbf{S}^{[n]}-\mathbf{F}(\mathbf{S}^{[n+1]})h$。

#### 直接求解隐式积分

​	假如导数$\mathbf{F}$是状态的线性函数，即对于$n\times1$的状态向量$\mathbf{S}$有：$\mathbf{F}(\mathbf{S})=M\mathbf{S}$，其中$M$是$n\times n$的矩阵。上式可以重写为：
$$
\begin{align}
\mathbf{S}^{[n+1]}-\mathbf{S}^{[n]}-\mathbf{F}(\mathbf{S}^{[n+1]})h &= 0 \\
\mathbf{S}^{[n+1]}-h\mathbf{F}(\mathbf{S}^{[n+1]}) &= \mathbf{S}^{[n]} \\
\mathbf{S}^{[n+1]}-hM\mathbf{S}^{[n+1]} &= \mathbf{S}^{[n]} \\
(I-hM)\mathbf{S}^{[n+1]} &= \mathbf{S}^{[n]}
\end{align}
$$
最后一个方程变为$Ax=b$的形式。矩阵A通常维度很大而且非常稀疏。选择针对稀疏矩阵做过优化的算法非常重要，**共轭梯度法**是一个常用的算法。

​	显然，指数衰减和振荡都具有线性性质。对于振荡而言：
$$
\begin{align}
\left[\begin{matrix}x^{[n+1]}\\v^{[n+1]}\end{matrix}\right]&=\left[\begin{matrix}x^{[n]}\\v^{[n]}\end{matrix}\right]+\left[\begin{matrix}v^{[n+1]}\\-\omega^2x^{[n+1]}-dv^{[n+1]}\end{matrix}\right]h\\
\left[\begin{matrix}x^{[n+1]}\\v^{[n+1]}\end{matrix}\right]&=\left[\begin{matrix}x^{[n]}\\v^{[n]}\end{matrix}\right]+\left[\begin{matrix}0&1\\-\omega^2&-d\end{matrix}\right]\left[\begin{matrix}x^{[n+1]}\\v^{[n+1]}\end{matrix}\right]h
\end{align}
$$

#### 雅可比和线性化函数

​	不是所有问题都具有线性性质，比如两个物体间的引力。但是在状态空间的任意一点，我们可以用雅可比矩阵把非线性系统近似展开为线性的。基于当前状态$\mathbf{S}^{[n]}$，我们可以把$\mathbf{F}(\mathbf{S}^{[n+1]})$近似表达为：
$$
\begin{align}
\mathbf{F}(\mathbf{S}^{[n+1]})&=\mathbf{F}(\mathbf{S}^{[n]}+\Delta \mathbf{S}) \\
&=\mathbf{F}(\mathbf{S}^{[n]})+\frac{\mathrm{d}\mathbf{F}}{\mathrm{d}\mathbf{S}}\Delta \mathbf{S} \\
&=\mathbf{F}(\mathbf{S}^{[n]})+\mathbf{J}\Delta \mathbf{S}
\end{align}
$$
​	其中$\mathbf{J}$是雅可比矩阵，对于$n\times1$的状态向量$\mathbf{S}$，$\mathbf{J}$是$n\times n$的矩阵。其中$J_{i,j}=\frac{\part{f_i}}{\part{s_j}}$。注意：**$\mathbf{J}$是状态向量$\mathbf{S}$的函数，每一步都需要重新计算$\mathbf{J}$**。知道$\mathbf{J}$之后，可以按照以下步骤求解隐式欧拉中的$\Delta \mathbf{S}$：
$$
\begin{align}
\mathbf{S}^{[n+1]}&=\mathbf{S}^{[n]}+h\mathbf{F}\left(\mathbf{S}^{[n+1]}\right) \\
\mathbf{S}^{[n]}+\Delta \mathbf{S}&=\mathbf{S}^{[n]}+h\left(\mathbf{F}(\mathbf{S}^{[n]})+\mathbf{J}\Delta \mathbf{S}\right) \\
\Delta \mathbf{S}&=h\mathbf{F}\left(\mathbf{S}^{[n]}\right)+h\mathbf{J}\Delta \mathbf{S} \\
\left(I-h\mathbf{J}\right)\Delta \mathbf{S}&=h\mathbf{F}\left(\mathbf{S}^{[n]}\right)
\end{align}
$$
​	总结，对于任一系统，首先组织状态向量$\mathbf{S}$并写出导函数$\mathbf{F}$，进一步求雅可比矩阵$\mathbf{J}$，最后带入上式求$\Delta \mathbf{S}$。注意**每一个步长都要重复计算$\mathbf{F}$和$\mathbf{J}$**。

#### 求根法求解隐式积分

​	当系统很难用雅可比矩阵线性近似时，可以考虑用求根法求解隐式积分。将$\mathbf{S}^{[n+1]}=\mathbf{S}^{[n]}+\mathbf{F}(\mathbf{S}^{[n+1]})h$中的$\mathbf{F}$展开，使用求根的方法求解上式（如牛顿法）。

# C++ Primer

### unique_ptr

​	一个`unique_ptr`“拥有”它所指向的对象，某个时刻只能有一个`unique_ptr`指向一个给定的对象。因此，**`unique_ptr`不支持拷贝和赋值操作**。可以通过以下方式改变或放弃对象的控制权（只有非const的`unique_ptr`才能改变或放弃对象的控制权）：

- `unique_ptr<T>::release()`，放弃对象的控制权，返回指向对象的指针并将自己置为`nullptr`。
- `unique_ptr<T>::reset(T* q=nullptr)`，释放当前指向的对象，并重新控制指针`q`指向的对象。

​	不能拷贝`unique_ptr`有一个例外：**可以拷贝或赋值一个将要被销毁（右值）的`unique_ptr`**。常见的例子是从函数返回一个`unique_ptr`。

​	`unique_ptr`默认情况下也用`delete`释放他所指向的对象，指定自定义删除器的方式与`shared_ptr`有点不一样。`unique_ptr<T, delT> p(new T(), delFun);`。

> **当我们把函数名作为一个值使用时，该函数自动地转换成指针**。可以直接使用指向函数的指针调用函数，不需要解引用。

### weak_ptr

​	`weak_ptr`不控制所指向对象的生存期，它指向一个由`shared_ptr`管理的对象。将一个`weak_ptr`绑定到一个`shared_ptr`不会改变`shared_ptr`的引用计数。即使还有`weak_ptr`指向对象，一旦最后一个指向对象的`shared_ptr`被销毁，对象仍然会被释放。

​	创建`weak_ptr`时，需要用一个`shared_ptr`来初始化它。由于对象可能不存在，我们不能使用`weak_ptr`直接访问对象，必须调用`lock`函数。此函数检查`shared_ptr`指向的对象是否存在，如果存在，则返回一个指向共享对象的`shared_ptr`，否则，返回空`shared_ptr`。

### 智能指针和动态数组

​	可以用如下方式管理`new`分配的数组：`unique_ptr<T[]> p(new T[n]);`或`shared_ptr<T[]> p(new T[n]);`。**使用智能指针管理数组时，不能使用点和箭头运算符，可以用下标运算符来访问数组中的元素**。
