# Game Engine Architecture

## SIMD/Vector Processing

### SSE指令集及其寄存器

​	SSE是Intel CPU上的SIMD指令集，我们只讨论SSE指令用于处理打包的$32$位浮点数据。对应的指令用p(打包)s(浮点)后缀表示。SSE寄存器命名为XMMi，其中i是$0$到$15$之间的整数，每个XMMi寄存器包含128位，即4个32位单浮点数，将这四个浮点数分别命名为[x, y, z, w]，就像齐次坐标一样。

1. `__m128`数据类型

   为了方便处理SSE数据，C++编译器提供了特殊的数据类型来封装浮点数组，还可能有`__m256`或`__m512`。

2. SSE数据对齐

   每当XMMi寄存器要使用的数据存储在内存中时，它必须是16字节对齐的。编译器确保`__m128`类型的全局变量和局部变量自动对齐。**当动态分配`__mm128`类型或包含该类型成员的类时，需要手动内存对齐**。同样，与SSE指令一起使用的浮点数组也必须正确对齐。

3. SSE编译器内部函数

   要使用SSE的内部函数，必须在VS中包含`<xmmintrin.h>`头文件或者gcc的`<x86intrin.h>`头文件。常用的函数有：

   - `__m128 _mm_set_ps(float w, float z, float y, float x);`：赋值`__m128`变量
   - `__m128 _mm_load_ps(const float* pData);`：赋值，此数组必须是16字节对齐的
   - `void _mm_store_ps(float* pData, __m128 v);`：读取`__m128`变量的值，数组必须16字节对齐
   - `__m128 _mm_add_ps(__m128 a, __m128 b);`：四个浮点数相加
   - `__m128 _mm_mul_ps(__m128 a, __m128 b);`：四个浮点数相乘

   `__m128`以小端序存储在内存或寄存器中，这也是`set`函数接收的参数是逆序的原因。

### 使用SSE向量化一个循环

​	可以使用SSE加速计算，对于两个浮点数组相乘：

```c++
void MulArrays(int count, float* results, const float* a, const float* b){
    for(int i=0;i<count;i++)
        results[i] = a[i]*b[i];
}
//使用SSE
void MulArrays_SSE(int count, float* res, const float* a, const float* b){
    int i = 0;
    for(;i<count;i+=4){
        __m128 x = _mm_load_ps(&a[i]);
        __m128 y = _mm_load_ps(&b[i]);
        __m128 r = _mm_mul_ps(x, y);
        _mm_store_ps(&res[i], r);
    }
    while(i<count){
        res[i] = a[i]*b[i];
        ++i;
    }
}
```

**对于齐次坐标的点积，可以非常方便的使用SSE来加速**。不过需要特殊的数据组织方式，将[x, y, z, w]分开存储，如下所示：

```c++
void DotArray_SSE(int n, float res[], const float a[4][], const float b[4][]){
    for(int i=0;i<n;i+=4){
        __m128 ax = _mm_load_ps(&a[0][i]);
        __m128 ay = _mm_load_ps(&a[1][i]);
        __m128 az = _mm_load_ps(&a[2][i]);
        __m128 aw = _mm_load_ps(&a[3][i]);
        __m128 bx = _mm_load_ps(&b[0][i]);
        __m128 by = _mm_load_ps(&b[1][i]);
        __m128 bz = _mm_load_ps(&b[2][i]);
        __m128 bw = _mm_load_ps(&b[3][i]);
        __128 r;
        r = _mm_mul_ps(ax, bx);
        r = _mm_add_ps(r, _mm_mul_ps(ay, by));
        r = _mm_add_ps(r, _mm_mul_ps(az, bz));
        r = _mm_add_ps(r, _mm_mul_ps(aw, bw));
        _mm_store_ps(&res[i], r);
    }
}
```

将[x, y, z, w]分开存储是非常麻烦的事情，VS提供了`_MM_TRANSPOSE()_PS`函数帮助我们做这件事，具体如下：

```c++
void DotArray_SSE(int n, float res[], const float a[], const float b[]){
    for(int i=0;i<n;i+=4){
        __m128 ax = _mm_load_ps(&a[(i+0)<<2]); //a[0, 1, 2, 3]
        __m128 ay = _mm_load_ps(&a[(i+1)<<2]); //a[4, 5, 6, 7]
        __m128 az = _mm_load_ps(&a[(i+2)<<2]); //a[8, 9, 10, 11]
        __m128 aw = _mm_load_ps(&a[(i+3)<<2]); //a[12, 13, 14, 15]
        __m128 bx = _mm_load_ps(&b[(i+0)<<2]); //b[0, 1, 2, 3]
        __m128 by = _mm_load_ps(&b[(i+1)<<2]); //b[4, 5, 6, 7]
        __m128 bz = _mm_load_ps(&b[(i+2)<<2]); //b[8, 9, 10, 11]
        __m128 bw = _mm_load_ps(&b[(i+3)<<2]); //b[12, 13, 14, 15]
        _MM_TRANSPOSE_PS(ax, ay, az, aw); //转置
        _MM_TRANSPOSE_PS(bx, by, bz, bw); //转置
        __m128 r;
        r = _mm_mul_ps(ax, bx);
        r = _mm_add_ps(r, _mm_mul_ps(ay, by));
        r = _mm_add_ps(r, _mm_mul_ps(az, bz));
        r = _mm_add_ps(r, _mm_mul_ps(aw, bw));
        _mm_store_ps(&res[i], r);
    }
}
```

<u>实测：VS中没什么区别（Release），甚至SSE反而慢了$50\%$（Debug）</u>？？？

#  基于物理的建模与动画

## 可形变弹性网格的碰撞

### 碰撞响应

<u>**移动物体的碰撞**</u>

<u>两个移动的物体怎么做碰撞确定</u>？

动量：系统的动量$\mathbf{P}=m\mathbf{v}$是系统所受的外力$\mathbf{f}=m\mathbf{a}$对时间$t$的积分，即$\mathbf{P}(t)=\mathbf{P}_0+\int\mathbf{f}dt$。

动量守恒：当物理系统受到的合外力为$0$时，系统满足动量守恒定律，即总动量不变。系统质心维持原本的运动状态。

首先要计算两个碰撞点处的质量，通过对顶点质量进行加权质心混合得到：
$$
m=\frac{um_1+vm_2}{u^2+v^2}\ or\ m=\frac{um_1+vm_2+wm_3}{u^2+v^2+w^2}
$$
然后计算碰撞点碰撞后的速度$\mathbf{v}_p^+$和$\mathbf{v}_q^+$。整体过程如下：

1. 计算动量中心$\mathbf{c}_m$
2. 计算$\mathbf{p}$、$\mathbf{q}$相对于$\mathbf{c}_m$的速度
3. 找到速度的法向和切向分量
4. 根据弹性和摩擦，计算出碰撞响应
5. 将$\mathbf{c}_m$加回到计算出的速度中

最后，再将计算出的速度分配到顶点上。

对于静态物体，我们设置它的速度为$0$，质量为$+\infin$。

## 晶格形变器

​	显然，想要模拟一个稳定的弹性网格，计算开销是非常大的。当模型非常精细时，还会出现不稳定的情况。可以直接对物体进行四面体网格建模。或者用四面体网格包围物体，先用包围体代替整个物体，移动四面体的顶点，最后通过线性插值移动物体真正的顶点。效果如下：

<img src="C:\Users\Clan\OneDrive\桌面\study\研二\day by day\pictures\image-20221013150226340.png" alt="image-20221013150226340" style="zoom: 50%;" />

## 刚体状态

​	为了表示一个刚体，首先我们需要知道刚体的质心位置$\mathbf{x}$以及刚体移动的速度$\mathbf{v}$，其次，刚体具有方向（姿态），刚体在姿态上具有三个自由度。目前暂时使用旋转矩阵$R$来描述刚体的姿态。

​	选择一个相对刚体固定，原点在刚体质心的坐标系，称为局部坐标系，用于描述刚体本身。我们正在模拟的世界有一个世界坐标系。为了指定刚体在世界坐标系中的放置方式，我们指定刚体在世界坐标系中的位置$\mathbf{x}$和方向$R$。因此局部坐标系下的点$\mathbf{p}_0$在世界坐标系下的坐标为：
$$
\mathbf{p}=\mathbf{x}+R\mathbf{p}_0
$$

# C++ Primer

## 拷贝控制和资源管理

​	管理类外资源的类（比如堆内存）必须定义拷贝控制成员。定义拷贝时，可以让类的行为看起来像一个指针或像一个值。定义赋值运算符时，一定要确保当对象赋值给自己时，赋值运算符能正常工作。一般在销毁左侧对象之前先拷贝右侧对象。

​	当我们希望类的行为看起来像一个指针时，需要注意，只有当最后一个指向外部资源的对象销毁时，析构函数才能释放响应的资源。最好用`shared_ptr`来管理外部资源。如果自己实现引用计数，那么**引用计数器应该保存在动态内存中**。

​	管理资源的类通常还应该定义一个名为`swap`的函数（*为什么？*），对象的每个成员都执行`swap`，如果定义了自己的`swap`就调用自己的，如果没有就调用`std::swap`。具体如下：

```c++
class T{
    friend void swap(T&, T&);
};
inline void swap(T& l, T& r){
	using std::swap;
    swap(l.a, r.a);
    swap(l.b, r.b);
    ....
}
```

​	还可以利用`swap`函数来实现赋值函数。

# Vulkan Tutorial

## Command buffer allocation

​	创建command pool 之后便可从中分配command buffer，分配出来的command buffer不需要手动销毁，pool销毁时，所有从中分配的buffers都会被销毁。分配command buffer需要填充`VkCommandBufferAllocateInfo`，具体定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkCommandBufferAllocateInfo {
	VkStructureType            sType;
	const void*                pNext;
	VkCommandPool              commandPool;
	VkCommandBufferLevel       level;
	uint32_t                   commandBufferCount;
}VkCommandBufferAllocateInfo;
```

`level`指定分配出的命令缓冲区是Primary还是Secondary：

- `VK_COMMAND_BUFFER_LEVEL_PRIMARY`：可以提交到队列执行，但不能从其他命令缓冲区调用
- `VK_COMMAND_BUFFER_LEVEL_SECONDARY`：不能直接提交，但可以被主命令缓冲区调用。

辅助命令缓冲区对于经常重用的指令非常有帮助。

## Command buffer recording

​	通过调用`vkBeginCommandBuffer`来告诉Vulkan开始录入命令，该函数需要一个`BeginInfo`参数，具体定义如下：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkCommandBufferBeginInfo {
	VkStructureType                          sType;
	const void*                              pNext;
	VkCommandBufferUsageFlags                flags;
	const VkCommandBufferInheritanceInfo*    pInheritanceInfo;
} VkCommandBufferBeginInfo;
```

`flag`用于指定将如何使用command buffer，可能的取值有：

- `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT`：命令缓冲区将在执行一次后立即重置。
- `VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT`：这是一个次级缓冲区，并且只存在于某个render pass中。
- `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`：命令缓冲区可以在它等待被执行时，重新提交

`pInheritanceInfo`只跟辅助命令缓冲区有关，<u>它指定从调用它的主缓冲区的继承状态</u>。

如果命令缓冲区已经被记录过一次，调用`vkBeginCommandBuffer`将隐式的重置它，之后将不能向这个缓冲区添加命令。

### Starting a render pass

录入`vkCmdBeginRenderPass`来开始渲染，同样需要配置一些参数：

```c++
// Provided by VK_VERSION_1_0
typedef struct VkRenderPassBeginInfo {
	VkStructureType        sType;
	const void*            pNext;
	VkRenderPass           renderPass;
	VkFramebuffer          framebuffer;
	VkRect2D               renderArea;
	uint32_t               clearValueCount;
	const VkClearValue*    pClearValues;
} VkRenderPassBeginInfo;
```

参数含义都非常直观。所有记录命令的函数都以`vkCmd`作为前缀，都返回void。

### Basic drawing commands

使用`vkCmdBindPipeline`函数绑定一个渲染管线

使用`vkCmdDraw(VkCommandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)`函数绘制三角形。`instance`参数与实例渲染有关。

### Ending render pass and Command buffer

调用`vkCmdEndRenderPass`结束render pass

调用`vkEndCommandBuffer`结束命令录入

## Rendering and Presentation

​	概括得说，在Vulkan中渲染一帧需要以下步骤：

- 等待上一帧渲染完毕
- 从交换链中获取一张图像
- 为这张图像记录命令到命令缓冲
- 提交命令缓冲
- 呈现图像

### 同步

​	Vulkan需要显式地对GPU的执行进行同步，需要在GPU上工作的Vulkan调用都是异步执行的，当工作提交完成后函数就直接返回了。需要手动控制GPU上的执行顺序。比如：

- 从交换链中获取一张图像
- 执行绘制所需的命令
- 将图像返回到交换链，并呈现到屏幕

这些操作都是异步执行的，但因为每个操作都依赖于上一个操作，所以需要我们手动进行同步。

​	信号量用于同步“队列操作”之间的顺序，队列操作是指需要提交到队列的操作，可以是命令缓冲区中或者函数中的操作。不同队列中的操作也可用通过信号量来同步。我们使用Vulkan中的二进制信号量。比如：

```c++
VkCommandBuffer A, B = ...; // record command buffers
VkSemaphore S = ...; // create a semaphore

vkQueueSubmit(work: A, signal: S, wait: None);
vkQueueSubmit(work: B, signal: None, wait: S);
```

​	wait到信号量之后，信号量将自动重置为"unsigned"状态。

​	注意，`vkQueueSubmit`的两个调用都会立即返回，CPU继续运行。若想让CPU等待GPU的运行结束，则需要一个不同的同步原语`Fences`。Fence也是二进制的，提交工作时可以附加一个fence，GPU完成口，fence会发出信号。CPU提交工作后等待fence的信号。但一般来说，最好不要主动阻塞CPU。fence需要手动重置到"unsigned"状态。

​	因为我们目前只有一个命令缓冲区，而且每帧都重新记录命令缓冲区，意味着我们一次只能绘制一帧。CPU需要等待GPU绘制完成才能继续录入命令。同时需要两个信号量来同步交换链中图像的读写状态。

​	现在，渲染一帧需要做的是：

1. `vkWaitForFences(device, 1, &inFlightFence, VK_TRUE, UINT64_MAX);`：等待上一帧绘制完毕，最后一个参数表示最长等待时间。`VK_TRUE`表示等待所有fences。

2. `vkResetFences(device, 1, &inFlightFence);`：手动重置fence。

3. `vkAcquireNextImageKHR(device, swapChain, UINT64_MAX,imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex);`：从交换链中获取图像，获取完成后标记`imageAvailable`信号量。

4. `vkResetCommandBuffer(commandBuffer, 0); recordCommandBuffer(commandBuffer, imageIndex);`：录入命令

5. 提交命令缓冲，需要填充`VkSubmitInfo`，具体定义如下：

   ```c++
   // Provided by VK_VERSION_1_0
   typedef struct VkSubmitInfo {
   	VkStructureType                sType;
   	const void*                    pNext;
   	uint32_t                       waitSemaphoreCount;
   	const VkSemaphore*             pWaitSemaphores;
   	const VkPipelineStageFlags*    pWaitDstStageMask;
   	uint32_t                       commandBufferCount;
   	const VkCommandBuffer*         pCommandBuffers;
   	uint32_t                       signalSemaphoreCount;
   	const VkSemaphore*             pSignalSemaphores;
   } VkSubmitInfo;
   ```

   `pWaitDstStageMask`指定在图形管线的哪些阶段等待信号量，阶段数量必须与信号量的数量相同。

6. 呈现，需要填充`VkPresentInfoKHR`，具体定义如下：

   ```c++
   // Provided by VK_KHR_swapchain
   typedef struct VkPresentInfoKHR {
   	VkStructureType          sType;
   	const void*              pNext;
   	uint32_t                 waitSemaphoreCount;
   	const VkSemaphore*       pWaitSemaphores;
   	uint32_t                 swapchainCount;
   	const VkSwapchainKHR*    pSwapchains;
   	const uint32_t*          pImageIndices;
   	VkResult*                pResults;
   } VkPresentInfoKHR;
   ```

   `pSwapchains`用于指定将渲染好的图像呈现到的交换链，`pImageIndices`指定交换链中的索引，几乎总是一张图片。`VkResult`用以检查是否呈现成功，如果只有一个交换链，可以指定为NULL。

